.TL
Frankenstein Cross Assemblers Users Manual
.AU "Mark Zenier"
.AF
.MT 4
.H 1 "Disclaimer"
This software is in the public domain.  Any prior copyright claims
are relinquished.  
.P
This software is distributed with no warranty whatever.  The author
takes no responsibility for the consequences of its use.
.H 1 "Introduction"
.H 2 "This Manual"
This manual covers the basic features for the Frankenstein cross assemblers.
The specific features for a given target architecture will be covered
in the appendix for that cross-assembler.
.H 2 "Notation"
Items enclosed in [] are optional. The "[]" are not entered in the
source statement or command line, and are just a notation.
.H 1 "Invocation"
name [-o binary] [-l listing] [-s symbols] [-d] input
.P
The optional operands on the command line can be in any order.
.H 2 "Input File"
The input file must appear after the optional entries on the command line.
Only one input file is used with this version. 
If the file name is a single minus sign, the standard input is used.
.H 2 "Listing File"
.DS I N
-l filename
.DE
.P
An annotated listing will only be produced if an optional list file is
provided, otherwise the error messages and summary will be output to the
console.
There is no required suffix or default extension for the file name.
.H 2 "Hex Output File"
.DS I N
-h filename or
-o filename
.DE
.P
The binary output will only be produced if the optional file is provided.
See the section in the description of the output files for the format
of the data records.
If any errors occur, the hex output file is either not created
or is deleted depending on whether the error occurred in the
input or output phases of processing.
There is no required suffix or default extension for the file name.
.H 2 "Symbol Listing File"
.DS I N
-s filename
.DE
.P
The symbol table is dumped with one entry per line for whatever use is 
desired, normally with the sort utility to produce symbol listings in 
a different order that the one provided.
See the section on the output files for a description of the format.
There is no required suffix or default extension for the file name.
.H 2 "Debug"
.SP 
The -d debug option
.DL
.LI
Saves the intermediate file in the /usr/tmp directory
.LI
Calls the abort() system call to produce a "core" file
.LE
.H 2 "Processor Selection"
.DS I N
assembler name or
-p string
.DE
.P
Some of these assemblers support related families of processors, and
can be limited to specific subsets of the total instructions by sending
the processor number or name as an operand.  The operand is scanned for
unique substrings which identify the target processor.
The operand can be either the name of the executable, or the operand
of the -p option, with the operand of the -p having precedence.
The name of the executable may not available in some operating systems.
The CPU pseudo-operation has precedence over both the name scan and
the -p operand [see the appendix for the specific processor].
.DS I N
Example
.SP
a6800 for the mc6800 instruction set
a6801 for the 6801/6803 instruction set
a6811 for the mc68hc11 instruction set
.DE
.H 1 "Source Input File"
The source input is a text file a with one statement per line.
Adjacent symbols must be separated by spaces or tabs or special characters 
such as operators or parenthesis. 
.H 2 "Input Lines"
.SP
Source lines consist of up to four parts
.DS I N
[Label] [Opcode [Operands] ] [; comments]
.DE
.VL +10
.LI Labels
A symbol that starts in the first column of the line is a
label.  
A label is used as the defining instance of a symbol, the place
where it is given a value, normally the address of the location
in memory where the data generated by the rest of the statement is placed.
Labels are optional for target machine instructions statements.
Label are required on some pseudo-operations, and are not allowed on others.
.LI Opcode
The first symbol in a line that doesn't start in
column 1 is treated as an opcode, all symbols after that are
treated as symbol references.
Opcodes are treated as a separate set of symbols, so a label
can have the same character string as an opcode.  
Opcodes are converted to uppercase for comparison, so case is not 
significant.
.LI Operands
The rest of the line is the operands associated with the opcode.
These are expressions, symbol references, or other syntactic elements
determined by the specific operation.
.LI Comments
Comments start with a ';', anything on a line after a
semicolon is ignored.
Lines that consist of only a comment are treated as empty lines.
.LE
.DS I N
Example

; just a little example
	org $700
label	equ *  ; set label to current location
	adda	#$21 ; a 6800 example
	end
.DE
.H 3 "Limitations"
Input lines should be shorter than 256 characters.
An error message is issued if lines are longer.
.H 3 "Empty"
Empty lines are ignored as input, but are copied to the listing
file.
.H 2 "Syntactic Elements"
.H 3 "Symbols"
Symbols are strings of characters.  The first of which is one of
the following.
.DS I N
A-Z a-z ! & ^ _ ~
.DE
.P
The rest of the string consists of zero or more of the 
following.
.DS I N
0-9 A-Z a-z ! & ^ _ ~
.DE
.P
There is no length limit to symbols, all characters are
significant.  Case is significant.
.H 3 "Reserved Variables Names"
Machine specific names, and operator names that can appear in
symbolic expressions share the same symbol table with labels,
and cannot be used as labels.  The list will vary from machine
to machine.  Case is significant for these symbols. 
.DS I F
Examples
.SP
and defined eq ge gt high le low lt mod ne
not or shl shr xor AND DEFINED EQ GE GT HIGH
LE LOW LT MOD NE NOT OR SHL SHR XOR
.DE
.H 3 "Numeric Constants"
numeric constants can be specified in decimal, hexadecimal,
octal, and binary.  Constants are maintained as long 
variables, but the instruction generation will cause an error
if the value is too big to fit in its destination field.
.H 4 "Decimal Constants"
.DL
.LI
one or more decimal characters (0-9) followed by an
optional "d" or "D" base designator.
.LE
.H 4 "Hexadecimal Constants"

.P 1
Either 
.DL
.LI
one or more hexadecimal characters
(0-9 a-f A-F) preceded by a "$" base designator.
.LI
a decimal character (0-9) followed by zero or
more hexadecimal characters (0-9 a-f A-F) 
followed by a "h" or "H" base designator
.LE
.H 4 "Octal Constants"

.P 1
Either
.DL
.LI
one or more octal characters (0-7) preceded
by a "@" base designator
.LI
one or more octal characters (0-7) followed
by a "o" or "O" or "q" or "Q" base designator.
Note: this is the letter "O" not the number "0".
.LE
.H 4 "Binary Constants"

.P 1
Either
.DL
.LI
one or more binary characters (0 or 1) preceded
by a "%" base designator.
.LI
one or more binary characters (0 or 1) followed
by a "b" or "B" base designator.
.LE
.H 4 "Examples"
.VL +15 +5 1
.LI 123
decimal number
.LI 123d
decimal number
.LI $faf 
hexadecimal number
.LI 0fafh
hexadecimal number, note leading zero used to differentiate this from symbol 
"fafh"
.LI @1234
octal number
.LI 1234Q
octal number
.LI %010101
binary number
.LI 010101b
binary number
.LE
.H 3 "String Constants"
String constants are specified using either the quotation mark
" or the apostrophe '.  A string starting with one of these 
character is terminated by only that character and can contain
the other string delimiter as data.  
A string with no characters is valid.
.P
The values generated in the binary output can be different from
the host computers character set (the default).  
See the section on Defining Target Character Sets.
.P
Within the character string, the backslash is an escape character.
.VL +20 +5 1
.LI " \ec Character escapes"
.LI "\ "
The only characters defined for
the default (no) translation are \e\e \e" \e\'.  
Any other translation, (the control characters '\en', '\er', etc.) require
a translation table be defined.
Values can be set up for any character following the backslash escape 
except x and 0 through 7.  
.SP
.LI " \e777 Octal character escapes"
.LI "\ "
An one, two or three character octal constant.  The one byte value
is the binary representation of the number. 
The value is masked off for a maximum value of 255.
.SP
.LI " \exFF Hexadecimal character escapes"
.LI "\ "
A one or two character hexadecimal constant, preceded by a lower
case x.  Upper and lower case characters A through F are valid.
The one byte value is the binary representation of the number. 
.SP
.LE
.DS I N
Examples
.SP
	"this isn't illegal"
	'this is the other delimiter'
	'"'
	"\exfe\e0\en"
.DE
.H 2 "Expressions"
.SP
Expressions consist of
.DL "" 1
.LI
Symbolic References
.LI
Location Counter References
.LI
Numeric Constants
.LI
String Constants
.LI
Operators
.LE
.P
Expressions are used as operands in statements where any numeric value or 
memory address is desired.
.H 3 "Symbols"
A symbol reference is the name of an item in the symbol table, which
has a numeric value associated with it.
This value is either the memory address of the statement which has this
symbol as a label, or the value of the expression defined in a SET or EQU
statement which has this symbol as a label. 
.H 4 "Forward References"
During the input phase of processing, a symbol value may not be known if the 
definition of the symbol has not yet occurred.
Some pseudo-operations require that their operand expressions have a value
at the input phase, so no references to as yet undefined symbols can occur
in this case.
In the output phase of processing, it will result in an error if any of the
symbols used in expressions do not have values defined.
.H 4 "Reserved Symbols for Operators"
Using reserved symbols as labels will result in a syntax error as they
are predefined as a different type of syntactic element than the rest
of the symbol table.  
Operators for which there is no special character representation, and items 
like machine register names and condition code types will be represented by
reserved symbols.
The set of the reserved symbols will vary for
each target machine, and will be documented in the appendix for each target.
.H 3 "Location Counter"
The special name '*' used in an expression represents the location of the
first byte of the binary output for the current statement.
Some assemblers use some other character for source code compatiblity.
.H 3 "Constants"
The form of numeric constants is defined in the previous section.
.H 3 "Strings"
String constants, as defined in the previous section, are valid in
expressions.
However, at most the first two characters are used.
If the string is the null string, i.e. "", the numeric value is zero.
If the string is one character long, the value is the value of
the current character set translation, or the host computers character
set if no translation is active.
If the string is two or more characters long, the value is 
256*(the first character) + (the second character).
.H 3 "Operators"
.H 4 "Description"
.VL +20 +5 1
.LI " '+' expression "
.LI "\ "
Unary plus. No real effect.
.SP
.LI " '-' expression"
.LI "\ "
Unary minus, the result is the negative of the expression.
.SP
.LI " NOT expression"
.LI "\ "
Logical negation. The result is 0 if the expression is nonzero, 1 if the
expression is 0.
.SP
.LI " HIGH expression"
.LI "\ "
Result is the High half of a two byte number, equivalent to 
(expression SHR 8) AND $FF.
.SP
.LI " LOW expression"
.LI "\ "
Result is the Low order byte of the expression, equivalent to
(expression AND $FF)
.SP
.LI " expression '*' expression"
.LI " expression '/' expression"
.LI " expression '+' expression"
.LI " expression '-' expression"
.LI "\ "
Standard arithmetic operations.
.SP
.LI " expression MOD expression"
.LI "\ "
Result is the remainder of the division of the value of the left expression 
by the right.
.SP
.LI " expression SHL expression"
.LI " expression SHR expression"
.LI "\ "
Shift the value of the left expression left or right by the number of bit
positions given by the right operation.
.SP
.LI " expression GT expression"
.LI " expression GE expression"
.LI " expression LT expression"
.LI " expression LE expression"
.LI " expression NE expression"
.LI " expression EQ expression"
.LI " expression '>'  expression"
.LI " expression '>=' expression"
.LI " expression '<'  expression"
.LI " expression '<=' expression"
.LI " expression '='  expression"
.LI " expression '<>' expression"
.LI "\ "
Relational expressions.  
If the relation is true, the value is 1. 
If false, the value is 0.
The operators are nonassociative, the  expression " 1 < 3 < 5 " is not legal.
.SP
.LI " expression AND expression"
.LI " expression OR expression"
.LI " expression XOR expression"
.LI "\ "
Bitwise logical operations.
.SP
.LI " DEFINED symbol"
.LI "\ "
If the symbol (not an expression) is defined, i.e. used as a label, before 
this point in the input the value is 1.
If not, the value is 0.
.SP
.LI " '(' expression ')'"
.LI "\ "
Parenthesis are available to override the operator precedence.
.LE
.H 4 "Precedence"
The precedence of the operators from lowest to highest.
.AL 1 "" 1
.LI
 HIGH LOW
.LI
 OR XOR
.LI
 AND
.LI
 NOT
.LI
 GT GE LE LT NE EQ '>' '>=' '<' '<=' '=' '<>'   
.LI
 '+' '-'
.LI
 '*' '/' MOD SHL SHR
.LI
 unary '+' '-'
.LI
 ( expression )
.LE
.H 1 "Statements"
The names for the operations and pseudo-operations for each assembler are
specified in the adaptation files,
and can be different from the examples given here.
.H 2 "Label Only Line"
A line with only a label starting in column 1 will define that symbol
with the current value of the location counter.
.H 2 "End"
.DS I N
[Label] END 
.DE
.P
The End statement terminates the processing of the current file.
For an include file, the file is closed and input resumes in the
file that contained the include statement.
For the main file, processing shifts to the following passes of the
assembly.
The end statement is optional, as the end of file condition is treated in the
same fashion.
If the optional label is present, The symbol specified is used as the
execution start address that is output in the binary file.  
The symbol must be used as a label somewhere else in the file.
When more than one start address is specified, the last one in the file is 
used.
.H 2 "File Inclusion"
.DS I N
INCLUDE "filename"
INCL "filename"
.DE
.P
The include statement shifts input from the current file to the file
specified. 
Input resumes from the file containing the include statement when
the end of file or the End statement is reached in the included file.
Includes can be nested up to the limits of the include file stack,
currently a limit of 20 deep, or the limits of the operating system,
whichever comes first.
Includes can be recursive, i.e., a file can include itself.
If a file cannot be opened, either do to an bad filename or a lack of
system resources, an error is issued.
.H 2 "Conditional Assembly"
.H 3 "If"
.DS I N
IF expression 
.DE
.P
The IF statement allows selective assembly.
If the expression evaluates to a nonzero value, all statements between the 
IF and the matching ELSE or ENDI are assembled.
If the expression evaluates to zero, or the expression in noncomputable due
to a forward reference, all statements between the IF and the matching
ELSE or ENDI are ignored.
.P
Note: it is safer to use the DEFINED operator when testing for the existence
of a symbol than to rely on the noncomputability of an expression.
.P
IF statements can be nested to a depth determined by a configuration 
constant, currently 32.
No label is allowed on an IF statement.
.H 3 "Else"
.DS I N
ELSE 
.DE
.P
The ELSE statement causes all statements between it and its corresponding
ENDI statement to be treated the opposite of the statements between the
matching IF and this statement.
When the expression on the matching IF is nonzero, the statements between
the ELSE and ENDI are ignored.
If the IF expression failed, the statements between the ELSE and the ENDI
are assembled.
Labels are not allowed on ELSE statements.
.H 3 "End If"
.DS I N
ENDI 
.DE
.P
The ENDI statement terminates processing of its matching IF statement.
Labels are not allowed on ENDI statements.
.H 2 "Symbolic Constants"
Symbols can be assigned numeric values with the SET and EQU statements.
The expressions cannot have forward references to as yet undefined symbols.
.H 3 "Equate"
.DS I N
Label EQU expression
.DE
.P
The EQU statement takes the value of the expression and creates a symbol
with that value.
Symbols defined in EQU statements cannot already exist, or be redefined.
.H 3 "Set"
.DS I N
Label SET expr 
.DE
.P
The SET statement sets the symbol specified in the label field with the
numeric value of the expression.
The SET statement can change the value of a symbol, but only if the
symbol is originally defined in a previous SET statement.
.DS I N
Example
.SP
counter set 1
counter set counter+1
counter set counter+1
.DE
.H 2 "Location Counter Value Setting"
The address of the generated binary data can be changed with the ORG and
reserve statements.
.H 3 "Org"
.DS I N
[Label] ORG expression
.DE
.P
The location counter is set to the numeric value of expression.
It is an error if the expression contains references to symbols not
yet defined.
The optional label is set to the new value of the location counter.
.H 3 "Reserve Memory"
.DS I N
[Label] RMB expression
[Label] RESERVE expression
.DE
.P
The reserve memory statement moves the location counter forward by
the number of bytes specified in the expression.
The label is set to the first location of this area.
.H 2 "Data Definitions"
.H 3 "Define Byte Data"
.DS I N
[Label]  BYTE  expression [, expression] ...
[Label]  FCB   expression [, expression] ...
[Label]  DB  expression [, expression] ...
.DE
.P
The define byte statement generates one character of data for each
expression in the expression list.
There can be up to 128 expressions on a line, more than the line length will
allow.
The optional label is set to the first location of this area.
.H 3 "Define Word Data"
.DS I N
[Label]  WORD  expression [, expression] ...
[Label]  FDB   expression [, expression] ...
[Label]  DW  expression [, expression] ...
.DE
.P
The define word statement generates a two byte integer for each expression
in the expression list.
There can be up to 128 expressions on a line, more than the line length will
allow.
The byte order of the data is determined by the adaptation files for
the target processor.
The optional label is set to the first location of this area.
.H 3 "Define String Data"
.DS I N
[Label] STRING string [, string] ...
[Label] FCC string [, string] ...
.DE
.P
The define string statement generates data encoded in the current character 
set translation,
one byte per character, excluding the delimiter characters.
The optional label is set to the first location of this area.
.H 2 "Defining Target Character Sets"
The values generated for String Constants in both the Define String
Data and in expressions can be specified on a character by character
basis.  This is to support cross assembly where the target system
has a different character set from the host computer.
.H 3 "Define Character Set Translation"
.DS I N
.DE
Label CHARSET
.P
The define character set translation statement defines a name and creates 
an internal table for a character set.  
The label symbol is treated like the label on an EQU statement.
The value is from an internal counter and has little or no meaning
outside of using it on a CHARUSE statement to specify which translation
to use.  There can be up to 5 [configurable] character
translation sets.
A CHARSET statement must precede any CHARDEF statements.
.H 3 "Define Character Value"
.DS I N
CHARDEF string, expression [, expression ] ...
CHD string, expression [, expression ] ...
.DE
.P
The define character value statement set the translation for one
or more characters in the table defined by the preceding CHARSET
statement.
There can be more than one character in the string, but the
number of expression in the value list must match the number
of characters.
Octal and Hexadecimal escape sequences cannot occur in the string.
.P
There are two sets in each translation table.  
The first is for the characters, the second for characters escaped with 
the backslash.
.P
Note: the characters '"' and '\e"' (and "'" and "\e'") each have an entry in 
different halves of the translation tables.
.H 3 "Use Character Translation"
.DS I N
CHARUSE
CHARUSE expression
.DE
.P
The use character translation statement changes the translation for the
following statements.
The statement without an expression turns off the translation, so
the host character set is used.
The statement with an expression (the name given on the CHARSET statement)
sets the translation to the set defined in the respective CHARSET.
.DS I N
Example
.SP
ascii	charset
	chardef	" !\e"#$%&\e'",$20,$21,$22,$23,$24,$25,$26,$27
	chardef	"()*+,-./",$28,$29,$2a,$2b,$2c,$2d,$2e,$2f
	chardef	"01234567",$30,$31,$32,$33,$34,$35,$36,$37
	chardef	"89:;<=>?",$38,$39,$3a,$3b,$3c,$3d,$3e,$3f
	chardef	"@ABCDEFG",$40,$41,$42,$43,$44,$45,$46,$47
	chardef	"HIJKLMNO",$48,$49,$4a,$4b,$4c,$4d,$4e,$4f
	chardef	"PQRSTUVW",$50,$51,$52,$53,$54,$55,$56,$57
	chardef	"XYZ[\e\e]^_",$58,$59,$5a,$5b,$5c,$5d,$5e,$5f
	chardef	"`abcdefg",$60,$61,$62,$63,$64,$65,$66,$67
	chardef	"hijklmno",$68,$69,$6a,$6b,$6c,$6d,$6e,$6f
	chardef	"pqrstuvw",$70,$71,$72,$73,$74,$75,$76,$77
	chardef	"xyz{|}~",$78,$79,$7a,$7b,$7c,$7d,$7e
	chardef	'"', $22 ; not the same table entry as '\e"'
	chardef	"'", $27 ; 
	chardef	"\en\et\ev\eb\er\ef\ea", $0a,$09,$0b,$08,$0d,$0c,$07
	charuse ascii
.DE
.H 2 "Machine Instructions"
.DS I N
[Label] opcode operands?
.DE
.P
Machine instructions generate the binary output by evaluating the expressions
for the operands, and matching the opcode with the entry in the instruction 
generation tables. 
.P
If the instruction has more than one format which is selected by the
value of the operands, the selection criteria must able to be determined at
the input phase of processing.
For example, in the mc6800 architecture direct address mode, any memory 
variables that are have an address between 0 and 255 must be defined before 
any reference to these symbols. 
.P
The optional label is set to the first location of the generated instruction.
.H 1 "Output"
.H 2 "Program Generated Messages and Errors"
.H 3 "Messages"
.VL 10 5 1
.LI "`` ERROR SUMMARY - ERRORS DETECTED {count}''"
.LI "``               -  WARNINGS       {count}''"
.LI "\ "
output at the end of the listing and on the console.
.LE
.H 3 "System Errors"
.VL 10 5 1
.LI "``cannot open hex output {filename}''"
.LI "\ "
file cannot be opened for output. The assembly continues
as if the -[oh] option was not specified.
.SP
.LI "``cannot open input file {filename}''"
.LI "\ "
file cannot be opened for reading. Fatal error.
.SP
.LI "``cannot open list file {filename}''"
.LI "\ "
file cannot be opened for output. The assembly continues
as if the -l option was not specified.
.SP
.LI "``cannot open symbol file {filename}''"
.LI "\ "
file cannot be opened for output. The assembly continues
as if the -s option was not specified.
.SP
.LI "``cannot open temp file {filename}''"
.LI "\ "
file cannot be opened for input or output. Fatal error.
.SP
.LI "``no input file''"
.LI "\ "
no input operand specified. Fatal error.
.SP
.LI "``no match on CPU type {string}, default used''"
.LI "\ "
operand for a -p option can't be matched.
.SP
.LI "``cannot allocate string storage''"
.LI "\ "
Request to operating system for more memory failed.
Fatal error.  The string storage pool is where the
character representation of symbols and names for
include files are stored.
.SP
.LI "``cannot allocate symbol space''"
.LI "\ "
Request to operating system for more memory failed.
Fatal error.  The symbol table is full. The symbol
space is the set of arrays where the symbol values
and other numeric information is stored.
.SP
.LI "``cannot redefine reserved symbol''"
.LI "\ "
Error in defining reserved symbols. Two calls to
"reservedsym()" with the same character string value
exist in the setup. Fatal error.  Should not occur
in a production executable.
.SP
.LI "``excessive number of subexpressions''"
.LI "\ "
The first pass ran out of element storage for the expression 
parse tree.  The expression is too complex.  Internal error 
which should never occur.  Fatal error.
.SP
.LI "``unable to allocate symbol index''"
.LI "\ "
Request to operating system for more memory failed.
Fatal error.  The symbol table is full.  The symbol index
is used in the output pass to direct symbol references to
the symbol table entry.
.LE
.H 3 "Error"
.VL 10 5 1
.LI "``ELSE with no matching if''"
.LI "``ENDI with no matching if''"
.LI "\ "
mismatched if/else/endi results in an else/endi left over
.SP
.LI "``IF stack overflow''"
.LI "\ "
more than IFSTKDEPTH (32) nested if statements
.SP
.LI "``Overlength/Unterminated Line''"
.LI "\ "
line longer than input buffer, or not terminated with newline
character.
.SP
.LI "``active IF at end of file''"
.LI "\ "
mismatched if/else/endi results in an unclosed if
.SP
.LI "``cannot change symbol value with EQU''"
.LI "\ "
symbol is already defined.
.SP
.LI "``cannot change symbol value with SET''"
.LI "\ "
symbol is already defined, but not with a Set statement.
.SP
.LI "``cannot create character translation table''"
.LI "\ "
the internal table for a character translation set
cannot be allocated due to lack of space, or
more translation sets than the assembler is
configured for.
.SP
.LI "``cannot open include file''"
.LI "\ "
The include file cannot be opened for reading, or not enough 
system resources are available to open the file.
.SP
.LI "``character already defined 'char' ''"
.LI "\ "
the character is already present in a previous CHARDEF
statement for this translation set.
.SP
.LI "``expression exceeds available field width''"
.LI "\ "
The value of an expression is too large to fit into
the field of the instruction.  Relative branch target
is too far away.
.SP
.LI "``expression fails validity test''"
.LI "\ "
An explicit test programmed in the generation string for the instruction 
failed.
These conditions are documented in the appendix for the specific instruction
set.
.SP
.LI "``expression stack overflow''"
.LI "\ "
Too many level of parenthesis or complex expression
with operator precedence that results in the expression
evaluation stack overflowing.  
.SP
.LI "``include file nesting limit exceeded''"
.LI "\ "
include files are nested to more than FILESTKDPTH (20)
levels deep.  "cannot open include file" usually occurs first.
.SP
.LI "``invalid char in instruction generation''"
.LI "\ "
Internal error, instruction generation string is not
defined properly.  Should not occur in a production executable.
.SP
.LI "``invalid character constant 'char' ''"
.LI "\ "
A character specification in a string constant isn't 
properly formed.
.SP
.LI "``invalid character to define 'char' ''"
.LI "\ "
a constant in the string in a CHARDEF statement is of a form
(octal, hex, or improperly formed) that does not have a
translation table entry.
.SP
.LI "``invalid opcode''"
.LI "\ "
No such string occurs in the opcode symbol table.  Opcode 
strings are converted to uppercase before comparison, and 
therefore are case insensitive.
.SP
.LI "``invalid operands''"
.LI "``invalid operands/illegal instruction for cpu''"
.LI "\ "
statement has a valid opcode, with the correct syntax, but
no code generation can be found in the table for these operands
.SP
.LI "``invalid syntax for instruction''"
.LI "\ "
opcode is valid, but not for this syntax form
.SP
.LI "``more characters than expressions''"
.LI "``more expressions than characters''"
.LI "\ "
A mismatch between the string constant and the number of expressions
in a CHARDEF statement.
.SP
.LI "``multiple definition of label''"
.LI "\ "
label symbol is already defined.
.SP
.LI "``no CHARSET statement active''"
.LI "\ "
a CHARDEF statement occurs before any CHARSET statement.
.SP
.LI "``noncomputable expression for EQU''"
.LI "``noncomputable expression for ORG''"
.LI "``noncomputable expression for SET''"
.LI "``noncomputable result for RMB expression''"
.LI "\ "
expression contains reference to symbols that have not
yet been defined, and thus has no numeric value.
.SP
.LI "``nonexistent character translation table''"
.LI "\ "
expression in a CHARUSE statement does not
correspond to any CHARSET statements label.
.SP
.LI "``overflow in instruction generation''"
.LI "``overflow in polish expression conversion''"
.LI "\ "
The intermediate file line being built exceeds the length
of the buffer.  The expression is too complex.
.SP
.LI "``syntax error at/before character ^{character}''"
.LI "``syntax error at/before character {character}''"
.LI "``syntax error at/before token {symbol/constant}''"
.LI "``syntax error at invalid token {constant/string} ''"
.LI "``syntax error at/before string {string} ''"
.LI "``syntax error at/before End of Line''"
.LI "``syntax error at/before {relational op}''"
.LI "``syntax error at/before Undeterminable Symbol''"
.LI "``syntax error - undetermined yyerror type''"
.LI "\ "
statement is in a form that the first pass parser cannot
recognize.  The next syntactic element is inappropriate for
whatever language element the parser is working on.  
.SP
.LI "``error or premature end of intermediate file''"
.LI "``syntax error - cannot backup''"
.LI "``unimplemented width''"
.LI "``unknown intermediate file command''"
.LI "``yacc stack overflow''"
.LI "\ "
Internal errors, should not occur.
.SP
.LI "``undefined character value 'char' ''"
.LI "\ "
A string constant contains a character not defined in
a CHARDEF statement for the current character translation.
.SP
.LI "``undefined symbol {symbolname}''"
.LI "\ "
symbol has no definition anywhere in file.
.LE
.H 3 "Warnings"
.VL 10 5 1
.LI "``character translation value truncated''"
.LI "\ "
An expression in a CHARDEF statment has a value less than zero
or greater then 255.
.SP
.LI "``forward reference to SET/EQU symbol''"
.LI "\ "
A symbol in an expression is defined in a set/equ statement 
that occurs after the line.  For set statements, the value 
of the symbol is that defined in the set statement closest 
to the end of the file.
.SP
.LI "``string constant in expression more than 2 characters long''"
.LI "\ "
The first two characters are used as the numeric value of
the subexpression.
.LE
.H 2 "Listing"
When the -l option is used, the detailed listing is output
to the given file.
This consists of the symbol listing followed by the annotated listing.
.H 3 "Symbol Table"
The symbol listing is printed three symbols across, with the
value then name of the symbol.  
Undefined symbols will have "????????" in their value field.
The symbols are listed in order of first occurrence in the input.
Only the first fifteen characters of a symbol are printed.
.H 3 "Instruction Lines"
The source statements are printed in the same form as they were input with
no reformatting.
Following the source line, will be any error or warning messages associated
with the line.
Statements which generate data will be preceded with the address and
data for them in hexadecimal format.
If more than six bytes of data are generated, the remainder will be
printed on the following lines, with up to sixteen bytes per line.
All data generated is printed in the file.
Statements that don't generate data but have some value oriented operation, 
like EQU, SET, ORG, or RESERVE, will print that value in the first 24 
columns of the source line.
.H 2 "Symbol File"
When the -s option is used, the symbol table is printed to the given
file.  The format is one symbol per line, address then symbol name.
If the symbol is undefined, "????????" is printed for the address.  The
symbols are printed in the order of first occurrence, either definition 
or reference, in the source file.  This feature is provided so the
system sort utility can be used to produce symbol tables sorted by
either address or name.
The entire symbol name is printed.
.H 2 "Binary Output"
.H 3 "Intel Hex Record Format"
The Intel hex record is a printable text string with an ASCII character
representing 4 bits of a byte.
The characters used are "0" through "9" and "a" through "f", representing 
binary data 0000 to 01001, and 1010 through 1111.
There are always two ASCII characters used to represent 1 byte, the high
half, then the low half.
There is one record per line in a text file. 
This format is accepted by most of prom programmers.
.P
Record Layout
.VL 15 5
.LI :ccaaaattddddddddddkk
.LI ':'
indicator character
.LI cc
ascii-hex representation of an 8 bit count of data characters
.LI aaaa
ascii-hex representation of 16 bit address
.LI tt
ascii-hex representation of an 8 bit type
.VL +10
.LI 00 is a data record
the address is the first location to store the data
.LI 01 is an end of file record
the address is the location to start execution, the
count is 00, no data is present.
.LE
.LI dd...
ascii-hex representation of the data, two characters per byte. 
The number of 8 bit bytes is given by the count field.
.LI kk
ascii-hex representation of an 8 bit checksum.  The sum of the
binary representation, modulo 256, of the count, the high half 
of the address, the low half of the address, the type, all the 
data bytes, and the checksum must be zero.
.LE
.H 1 "Program Limits"
.VL +30 ""
.LI "Line Length"
256 characters including end of line control characters
.LI "Number of Symbols"
.DL +2
.LI
The maximum allocatable block size divided by the size of a pointer.
For a iAPX286, about 16000 entries.
.LI
The amount of allocatable memory divided by the amount of space per symbol.
For an iAPX286, 22 + 1 + the length of the string bytes.
.LE
.LI "Symbol Length"
See line length
.LI "Output"
A 16 bit address in the output record format limits output to 65536 
binary bytes.
.LI "Expressions per Line"
128 (in BYTE and WORD statements)
.LI "Strings per Line"
128 (in STRING statements)
.LI "Nested If Statements"
32 levels
.LI "Nested Include Files"
20 or whatever the operating system allows 
.LI "Subexpressions per Line"
258 symbols, constants, operators (total)
.LI "Character Translation Sets"
5 sets, plus the default (host) character set
.LE
.TC 1 1 7
