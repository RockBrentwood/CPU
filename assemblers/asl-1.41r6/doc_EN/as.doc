Hello altogether,

this is the first release of the english AS manual.  I haven't done
the entire translation myself, large parts of it are the work of some
other people around the net who deserve my deep appreciation for this
job. My parts of the translation are the results of a brute-force
attempt, so there are surely tons of spelling errors and passages
that will make people with english as their mother tongue either
laugh or smile...

Alfred Arnold

        translation by: Oliver Sellke (OSIP, D-65199 Wiesbaden)
                          (proof-read in parts by Stefan Hilse, Wiesbaden)
                        Alfred Arnold
                        Stephan Kanthak
                        Vittorio De Tomasi

        thanks to the authors of:
                        FB-translator
                        GNU-ispell

------------------------------------------------------------------------------


                   Macro Assembler AS  Version 1.41

                           User's manual

                        Edition July 1997



                                Contents




     1. Introduction

      1.1. License Agreement

      1.2. General Capabilities of the Assembler

      1.3. Supported Plattforms

     2. Assembler Usage

      2.1. Hardware Requirements

      2.2. Delivery

      2.3. Installation

      2.4. Start-Up Commands, Parameters

      2.5. Format of the Input Files

      2.6. Format of the Listing

      2.7. Symbol Conventions

      2.8. Formula Expressions

      2.9. Forward References and Other Disasters

      2.10. Sharefile

      2.11. Processor Aliases

     3. Pseudo Instructions

      3.1. Definitions

       3.1.1. SET and EQU
       3.1.2. SFR and SFRB
       3.1.3. XSFR and YSFR
       3.1.4. LABEL
       3.1.5. BIT
       3.1.6. DBIT
       3.1.7. PORT
       3.1.8. REG
       3.1.9. LIV and RIV
       3.1.10. CHARSET
       3.1.11. ENUM
       3.1.12. PUSHV and POPV

      3.2. Code Modification

       3.2.1. ORG
       3.2.2. CPU
       3.2.3. SUPMODE, PMMU, FPU
       3.2.4. FULLPMMU
       3.2.5. PADDING
       3.2.6. MAXMODE
       3.2.7. EXTMODE and LWORDMODE
       3.2.8. SRCMODE
       3.2.9. BIGENDIAN
       3.2.10. SEGMENT
       3.2.11. PHASE and DEPHASE
       3.2.12. SAVE and RESTORE
       3.2.13. ASSUME
       3.2.14. EMULATED

      3.3. Data Definitions

       3.3.1. DC[.size]
       3.3.2. DS[.size]
       3.3.3. DB, DW, DD, DQ, and DT
       3.3.4. DS
       3.3.5. BYT or FCB
       3.3.6. BYTE
       3.3.7. ADR or FCB
       3.3.8. WORD
       3.3.9. LONG
       3.3.10. SINGLE and EXTENDED
       3.3.11. FLOAT and DOUBLE
       3.3.12. EFLOAT, BFLOAT, and TFLOAT
       3.3.13. Qxx and LQxx
       3.3.14. DATA
       3.3.15. ZERO
       3.3.16. FB and FW
       3.3.17. ASCII and ASCIZ
       3.3.18. STRING and RSTRING
       3.3.19. FCC
       3.3.20. DFS or RMB
       3.3.21. BLOCK
       3.3.22. RES
       3.3.23. BSS
       3.3.24. DSB and DSW
       3.3.25. ALIGN
       3.3.26. LTORG

      3.4. Macro Commands

       3.4.1. MACRO
       3.4.2. IRP
       3.4.3. REPT
       3.4.4. WHILE
       3.4.5. EXITM
       3.4.6. FUNCTION

      3.5. Conditional Assembly

       3.5.1. IF / ELSEIF / ENDIF
       3.5.2. SWITCH / CASE / ELSECASE / ENDCASE

      3.6. Listing Control

       3.6.1. PAGE
       3.6.2. NEWPAGE
       3.6.3. MACEXP
       3.6.4. LISTING
       3.6.5. PRTINIT and PRTEXIT
       3.6.6. TITLE

      3.7. Local Symbols

       3.7.1. Basic Definition (SECTION/ENDSECTION)
       3.7.2. Nesting and Scope Rules
       3.7.3. PUBLIC and GLOBAL
       3.7.4. FORWARD
       3.7.5. Performance Aspects

      3.8. Miscellaneous

       3.8.1. SHARED
       3.8.2. INCLUDE
       3.8.3. BINCLUDE
       3.8.4. MESSAGE, WARNING, ERROR and FATAL
       3.8.5. READ
       3.8.6. RELAXED
       3.8.7. END

     4. Processor-specific Hints

      4.1. 6811
      4.2. PowerPC
      4.3. DSP56000
      4.4. H8/300
      4.5. SH7000/7600
      4.6. MELPS-4500
      4.7. MELPS-740
      4.8. MELPS-7700/65816
      4.9. M16
      4.10. MCS-48
      4.11. MCS-51
      4.12. MCS-251
      4.13. 8086..V35
      4.14. 8X30x
      4.15. XA
      4.16. Z80UNDOC
      4.17. Z380
      4.18. TLCS-900(L)
      4.19. TLCS-90
      4.20. TLCS-870
      4.21. TLCS-47
      4.22. TLCS-9000
      4.23. 29XXX
      4.24. 80C16x
      4.25. PIC16C5x/16C8x
      4.26. PIC17C4x
      4.27. ST62xx
      4.28. ST7
      4.29. ST9
      4.30. 6804
      4.31. TMS3201x
      4.32. TMS3202x
      4.33. TMS32C03x
      4.34. TMS9900
      4.35. TMS70Cxx
      4.36. TMS370xxx
      4.37. MSP430
      4.38. COP8 & SC/MP
      4.39. 75K0
      4.40. 78K0

     5. File Formats

      5.1. Code Files

      5.2. Debug Files

     6. Utility Programs

      6.1. PLIST

      6.2. BIND

      6.3. P2HEX

      6.4. P2BIN

      6.5. AS2MSG


     A. Error Messages of AS

     B. I/O Error Messages

     C. Frequent Asked Questions

     D. Pseudo-Instructions Collected

     E. Predefined Symbols

     F. Acknowledgments

     C. Changes since Version 1.3

     H. Hints for the AS Source Code

      H.1 Language Preliminaries

      H.2 Module Separation

      H.3 New Processor... And Now?

      H.4 RSC...what's that?

     I. Bibliography


----------------------------------------------------------------------------

       1. Introduction
       ===============

This instruction is meant for those people who are already very
familiar with Assembler and those who like to know how to work with
AS.  It is rather a reference than a user's manual and so it neither
tries to explain the "language assembler" nor the processors.  I have
listed further literature in the bibliography which was substantial
in the implementation of the different code generators.  There is no
book I know where you can learn Assembler from the start, so I
generally learned this by "trial and error".

       1.1 License Agreement
       ---------------------

Before we can go "in medias res", first of all the inevitable prologue:

I publish AS, in the present version, as "Public Domain". 
This means, the program and overlay files and also the 
utility and tool programs appended may be copied and use for free (of 
charge).  There exist no plans to convert AS into a commercial or 
shareware program. This permission however is valid only under the 
following premises: 
1.) The start message of the programs - especially the copyright 
    message - must not be removed or overwritten. 
2.) The compensation charged for copying and shipping must not
    exceed D(E)M 20,-- (around US$ 14.00).

On request the source code of this program can also be made
available.  Programs or derivates structured hereon must be passed-on
under the same conditions as this program.

I explicitly encourage you to spread this program by disc or 
mailbox/BBS/network!

May be, you have got this program as enclosure to a commercial 
program. The license agreement for the commercial program in no case 
applies to AS. 

If you took so much pleasure in this assembler that you like to 
send me some money, I would ask you kindly to give the amount 
to Greenpeace.

I have been trying to make the programs as bug free as possible.  
But since there is principally no bug free software (the only people
making no mistakes are lying in the cemetery!), I do not take any 
warranty for the function of the assembler in a particular environment 
(hard or software) or liability for damages.  Naturally I will always 
be thankful for bug-reports or improvements and will work on the fixing.

To accelerate the error diagnose and correction, please add the 
following details to the bug report:

 - hardware:  - processor type  ( with/without coprocessor ) 
              - amount of memory installed
              - video card
              - hard-disk type(s) and their interface(s)

 - software:  - operating system ( MS-DOS, Novell-DOS, DR-DOS, OS/2, 
                Windows ) and version 
              - resident (TSR) programs installed 
              - version of AS including dates of the EXE-files 

 - if possible, the source file, in which the bug occurs 

You can contact me as follows:

  by Surface Mail : Alfred Arnold
                    Bröltalstr. 5a
                    D-53773 Hennef (Sieg)
                    Germany

  by E-Mail : a.arnold@kfa-juelich.de

If someone likes to meet me personally to ask questions and lives
near Aachen (= Aix-la-Chapelle), you will be able to meet me there. 
You can do this most probably on thursdays from 7pm to 9pm at the
computerclub inside the RWTH Aachen (Eilfschornsteinstrasse 16,
cellar of philosophers' building, backdoor entry).

Please don't call me by phone.  First, complex relations are
extremely hard to discuss at phone.  Secondly, the telephone
companies are already rich enough...

The latest german version of AS (DOS,DPMI,OS/2) is available from
the following FTP-Server:

 ftp.uni-stuttgart.de
     directory pub/systems/msdos/programming/as

The C version can be fetched from the following server:

 sunsite.unc.edu
   directory pub/Linux/devel/lang/assemblers/asl-<version>.tar.gz

..and of course thereby from every Sunsite mirror on the world!

Whoever has no access to an FTP-Server can ask me to send the
assembler by mail.  Only requests containing floppies (2 pieces 1.44
Mbytes, for 720Kbytes/1.2Mbytes format 4/3 pieces) and a
self-addressed, (correctly) stamped envelope will be answered.  Don't
send any money!

Now, after this inevitable introduction we can turn to the actual
documentation:


       1.2. General Capabilities of the Assembler
       ------------------------------------------

In contrast to ordinary assemblers, AS offers the possibility to 
generate code for totally different processors.  At the moment, the 
following processor families have been implemented:

 - Motorola 68000..68030,683xx incl. coprocessor and MMU
 - Motorola DSP56000
 - Motorola/IBM MPC601/MPC505/PPC403
 - Motorola 6800, 6805, 68HC08, 6809, 68(HC)11 68HC12, 68HC16, and Hitachi 6301
 - Hitachi 6309
 - Hitachi H8/300(H)
 - Hitachi H8/500
 - Hitachi SH7000/7600
 - Rockwell 6502 and 65(S)C02
 - CMD 65816
 - Mitsubishi MELPS-740
 - Mitsubishi MELPS-7700
 - Mitsubishi MELPS-4500
 - Mitsubishi M16
 - Mitsubishi M16C
 - Intel MCS-48/41
 - Intel MCS-51/251
 - Intel MCS-96/196(Nx)/296
 - Intel 8080/8085
 - Signetics 8X30x
 - Philips XA
 - Atmel AVR
 - AMD 29K
 - Siemens 80C166/167
 - Zilog Z80, Z180, Z380
 - Zilog Z8
 - Toshiba TLCS-900(L)
 - Toshiba TLCS-90
 - Toshiba TLCS-870
 - Toshiba TLCS-47
 - Toshiba TLCS-9000
 - Microchip PIC16C54..16C57
 - Microchip PIC16C84/PIC16C64
 - Microchip PIC17C42
 - SGS-Thomson ST62xx
 - SGS-Thomson ST7
 - SGS-Thomson ST9
 - SGS-Thomson 6804
 - Texas Instruments TMS32010/32015
 - Texas Instruments TMS3202x
 - Texas Instruments TMS320C3x
 - Texas Instruments TMS320C5x
 - Texas Instruments TMS9900
 - Texas Instruments TMS7000
 - Texas Instruments TMS370xxx
 - Texas Instruments MSP430
 - National Semiconductor SC/MP
 - National Semiconductor COP8
 - NEC µPD 78(C)1x
 - NEC µPD 75xxx (alias 75K0)
 - NEC µPD 78xxx (alias 78K0)

under work / planned / in consideration :

 - SGS-Thomson ST20
 - Texas Instruments TMS320C6x
 - Texas Instruments TMS320C4x
 - Texas Instruments TMS320C8x
 - Toshiba TC9331
 - Intel i960
 - Analog Devices ADSP21xx

I'm currently searching for documentation about the following
families:

 - Fujitsu F²MC
 - NEC 78K4
 - the complete set of OKI controllers

unloved, but now, however, present :

- Intel 80x86, 80186, Nec V30&V35 incl. coprocessor 8087

The switch to a different code generator is allowed even within one 
file, and as often as one wants!

The reason for this flexibility is that AS has a history, which may
also be recognized by looking at the version number. AS was created
as an extension of a macro assembler for the 68000 family. On special
request, I extended the original assembler so that it was able to
translate 8051 mnemonics.  On this way (decline ?!) from the 68000 to
8051, some other processors were created as by-products.  All others
were added over time due to user requests.  So, the version number is
not only marketing, but expresses really that this is no 1.0 version
with beta-version bugs like MS-DOS 6.0 (which does not reduce the
importance of what has been said in part 1.1).

This flexibility implies a somewhat exotic code format, therefore I
added some tools to work with it. Their description can be found in
chapter 6.

AS is a macro assembler, which means that the programmer has the
possibility to define new "commands" by means of macros. 
Additionally it masters conditional assembling.  Labels inside macros
are automatically processed as being local.

For the assembler, symbols may have either integer, string or
floating point values. These will be stored - like interim values in
formulas - with a width of 32 bits for integer values, 80 or 64 bits
for floating point values, and 255 characters for strings.  For a
couple of micro controllers, there is the possibility to classify
symbols by segmentation. So the assembler has a (limited) possibility
to recognize accesses to wrong address spaces.

The assembler does not know explicit limits in the nesting depth of 
include files or macros; a limit is only given by the program stack 
restricting the recursion depth.  Nor is there a limit for the 
symbol length, which is only restricted by the maximum line length. 

From version 1.38 on, AS is a multipass-assembler.  This pompous term
means no more than the fact that the number of passes through the
source code need not be exactly two. If the source code does not
contain any forward references, AS needs only one pass.  In case AS
recognizes in the second pass that it must use a shorter or longer
instruction coding, it needs a third (fourth, fifth...) pass to
process all symbol references correctly. There is nothing more behind
the term "multipass", so it will not be used further more in this
documentation.

After so much praise a bitter pill: AS cannot generate linkable code. 
An extension with a linker needs considerable effort and is not planned 
at the moment.

As regards "release of sources": the sources of AS are not
presented in a form which allows easy understanding (== no
comments). So I will emit sources only in case somebody really wants
to work on it (e.g.  to port AS into another computer system) and the
derivates become again Public Domain.  Particularly I want to prevent
that someone changes 5 lines (most popular the copyright entry) and
sell the result commercially as "his own" program.


       1.3. Supported Platforms
       ------------------------

+-----+
+ DOS +
+-----+
Though AS started as a pure DOS program, there are a couple of
versions available that are able to exploit a bit more than the Real
Mode of an Intel CPU.  Their usage is kept as compatible to the DOS
version as possible, but there are of course differences concerning
installation and embedding into the operating system in question. 
Sections in this manual that are only valid for a specific version of
AS are marked with a corresponding, boxed text aheaded to the
paragraph.  In detail, the following further versions exist
(distributed as separate packages):

+------+   
| DPMI |
+------+
In case you run into memory problems when assembling large and
complex programs, there is a DOS version that runs in protected mode
via a DOS extender and can therefore make use of the whole extended
memory of an AT.  The assembly becomes significantly slower by the
extender, but at least it works...

+------+
| OS/2 |
+------+
There is a native OS/2 version of AS for friends of IBM's OS/2
operating system.  This is currently only a 16-bit version, but at
least this way saves the roundtrips via DOS boxes and one does not
have any problems any more with longer file names.

+------+
| UNIX |
+------+
You can leave the area of PCs-only with the C version of AS that was
designed to be compilable on a large number of UNIX systems (this
includes OS/2 with the emx compiler) without too much of tweaking. 
In contrast to the previously mentioned versions, the C version is
delivered in source code, i.e. one has to create the binaries by
oneself using a C compiler.  This is by far the simpler way (for me)
than providing a dozen of precompiled binaries for machines I
sometimes only have limited access to...

+-----+
| ??? |
+-----+
People who have read this enumeration up to this point will notice
that world's best-selling operating system coming from Redmont is
missing in this enumeration.  People who know me personally will know
that I do not regard Windows to be a pat solution (regardless if its
3.X, 95, or NT).  Frankly said, I am a 'windows hater'.  A large
number of people will now regard this to be somewhere between
obsolete and ridiculous, and they will tell me that I withhold AS
from a large part of potential users, but they will have to live with
it: I primarily continue to improve AS because I have fun doing it;
AS is a non-commercial project and I therefore take the freedom not
to look at potential market shares.  I select platforms for me where
I have fun programming, and I definitely do not have any fun when
programming for Windows!  By the way, there was a time when I had to
write Windows programs so I do not simply jabber without having an
idea what I am talking about.  If someone wants to port AS into this
direction, I will not stand in his way, but (s)he should not expect
anything more from me than providing sources (which is why (s)he will
have to deal with questions like 'why does AS not work any more after
I changed the JUNK-CAD 18.53 registry entry from upper to lower
case?').


       2. Assembler Usage
       ==================

      
       2.1. Hardware Requirements
       --------------------------

The hardware requirements of AS vary substantially from version to
version:

+-----+
| DOS |
+-----+
The DOS version will run principally run on any IBM-compatible PC,
ranging from a PC/XT with 4-dot-little megahertz up to a Pentium. 
However, similar to other programs, the fun using AS increases the
better your hardware is.  An XT user without a hard drive will
probably have significant trouble placing the overlay file on a
floppy because it is larger than 500 Kbytes...the PC should therefore
have at least a hard drive, allowing acceptable loading times.  AS is
not very advanced in its main memory needs: the program itself
allocates less than 300 Kbytes main memory, AS should therefore work
on machines with at least 512 Kbytes of memory.

+------+
| DPMI |
+------+
The version of AS compiled for the DOS Protected Mode Interface
(DPMI) requires at least 1 Mbyte of free extended memory.  A total
memory capacity of at least 2 Mbytes is therefore the absolute
minimum given one does not have other tools in the XMS (like disk
caches, RAM disks, or a hi-loaded DOS); the needs will rise then
appropriately.  If one uses the DPMI version in a DOS box of OS/2,
one has to assure that DPMI has been enabled via the box's DOS
settings (set to 'on' or 'auto') and that a sufficient amount of XMS
memory has been assigned to the box.  The virtual memory management
of OS/2 will free you from thinking about the amount of free real
memory.

+------+
| OS/2 |
+------+
The hardware requirements of the OS/2 version mainly result from the
needs of the underlying operating system, i.e. at minimum an 80386SX
processor, 8 Mbytes of RAM (resp. 4 Mbytes without the graphical user
interface) and 100..150 Mbytes of hard disk space.  AS2 is only a
16-bit application and therefore it should also work on older OS/2
versions (thereby reducing the processor needs to at least an 80286
processor); I had however no chance to test this.

+------+
| UNIX |
+------+
The C version of AS is delivered as source code and therefore
requires a UNIX or OS/2 system equipped with a C compiler.  The
compiler has to fulfill the ANSI standard (GNU-C for example is
ANSI-compliant).  You can look up in the README file whether your UNIX
system has already been tested so that the necessary definitions have
been made.  You should reserve about 15 Mbytes of free hard disk
space for compilation; this value (and the amount needed after
compilation to store the compiled programs) strongly differs from
system to system, so you should take this value only as a rough
approximation.


       2.2. Delivery
       -------------

Depending on the platform, the distributions contain a different
amount of files.  One reason for this is that some packets use files
from other packets, on the other hand certain packets have to contain
additional files which are e.g. necessary for the operation of DOS
extenders.  If one of the files listed in the following tables is
missing, someone (in case of doubt me) took a nap while copying the
files...

+-----+
| DOS |
+-----+
The DOS package released by me contains the following files, which
can roughly be divided in program files, documentation, includes, and
test programs:

    File                Function
    ----                --------

   AS.EXE               assembler
   AS.OVR               overlay for assembler

   AS.DOC               this file containing the documentation

   PLIST.EXE            lists contents of code files 
   BIND.EXE             merges code files
   P2HEX.EXE            converts code files into hex files
   P2BIN.EXE            converts code files into binary files
   AS2MSG.EXE           error message filter AS --> Borland-Pascal

   80C50X.INC           register addresses SAB C50x
   80C552.INC           register addresses 80C552
   H8_3048.INC          register addresses H8/3048
   STDDEF04.INC         register addresses 6804 
   STDDEF16.INC         command macros and register addresses PIC16C5x
   STDDEF17.INC         register addresses PIC17C4x
   STDDEF18.INC         register addresses PIC16C8x
   STDDEF2X.INC         register addresses TMS 3202x
   STDDEF37.INC         register & bit addresses TMS370xxx
   STDDEF3X.INC         peripheral addresses TMS 320C3x
   STDDEF47.INC         command macros TLCS-47
   STDDEF51.INC         definition of SFRs and bits for 8051/8052/ 80515
   STDDEF56.INC         register addresses DSP56000
   STDDEF5X.INC         peripheral addresses TMS 320C5x
   STDDEF60.INC         instruction macros & register addresses PowerPC
   STDDEF62.INC         register addresses & macros ST62xx
   STDDEF75.INC         register addresses 75K0 
   STDDEF87.INC         register- & memory addresses TLCS-870
   STDDEF90.INC         register- & memory addresses TLCS-90 
   STDDEF96.INC         register- & memory addresses TLCS-900
   STDDEFXA.INC         SFR & bit addresses Philips XA
   STDDEFZ8.INC         register addresses Z8-family
   REG166.INC           addresses & command macros 80C166/167
   REG251.INC           addresses & bits 80C251
   REG29K.INC           peripheral addresses AMD 2924x
   REG53X.INC           register addresses H8/53x
   REG683XX.INC         register addresses 68332/68340
   REG7000.INC          register addresses TMS70Cxx
   REG78K0.INC          register and memory addresses 78K0
   REG96.INC            register addresses 8096
   REGAVR.INC           register addresses Atmel AVR
   REGCOP8.INC          register addresses COP8
   REGHC12.INC          register addresses Motorola 68HC12...
   REGM16C.INC          register addresses Mitsubishi M16C
   REGMSP.INC           instruction macros & register addresses MSP430
   REGST9.INC           register addresses ST9
   REGZ380.INC          on-chip register Z380
   CTYPE.INC            standard functions to analyze characters
   BITFUNCS.INC         standard functions for bit manipulation

   DEMOCODE.ASM         sample programs for this assembler 
   DEMOMAC.ASM
   DEMOPHAS.ASM
   DEMOLIST.ASM

+------+
| DPMI |
+------+
The package of the DPMI version is significantly smaller as it
neither contains include files nor utility programs nor test
programs.  You may (you even must...) take them from the DOS
version's package.  The utility programs were not compiled as extra
DPMI versions as they would not benefit from the larger memory but
still would experience the slowdown introduced by DPMI.  The package
can therefore reduce itself to the executable of AS and the needed
DOS extender:

    file                function
    ----                --------

   ASX.EXE              protected mode assembler

   DPMI16BI.OVL         DPMI server for the assembler
   DPMILOAD.EXE         loader for the DPMI server
   RTM.EXE              runtime module of the assembler

   RTMRES.EXE           make DPMI server resident

   DPMINST.EXE          install DPMI server for the computer

   DPMIUSER.DOC         information about the DPMI servers's
                        usage

+------+
| OS/2 |
+------+
The OS/2 version of AS is similar to the DPMI version in the sense
that include files and test programs weren't added to the package
(again, take them from the DOS version), but of course the utility
programs were compiled as "native" versions.  AS2MSG is missing due
to the missing base (==no Borland Pascal for OS/2):

    file                function
    ----                --------

   AS2.EXE              assembler, OS/2 version

   PLIST2.EXE           utility programs for AS2; function is analog
   BIND2.EXE            to the MSDOS versions
   P2HEX2.EXE
   P2BIN2.EXE

+------+
| UNIX |
+------+
As the C version is delivered in source code (in contrast to all previous
versions), its package is substantially larger (at least to an extent
that listing all files at this place would primarily result in a
waste of paper...).  For example, it additionally includes a test
suite that is quite complete in contrast to the few test programs
delivered with the DOS version.  The test suite allows to check the
correct operation of a freshly compiled version of AS.


       2.3. Installation
       -----------------

+-----+
| DOS |
+-----+
There is no need for a special installation prior to usage of AS.  It
is sufficient to copy all EXE and OVR files to a directory listed in
the PATH environment variable.  It is irrelevant whether you use an
existing directory or create a new one for this task.  The
documentation, demo programs, and include files may be placed where
you like.  Following is an example for an installation a UNIX guru
would choose:

Create the following directories (I will assume in the following that
you are going to install AS on drive C):

c:\as
c:\as\bin
c:\as\include
c:\as\lib
c:\as\doc
c:\as\demos

First, copy all EXE and OVR files from the archive to the bin
directory; extend your PATH statement in AUTOEXEC.BAT by this
directory.  Move all INC files to the include subdirectory.  Create a
file AS.RC in the lib subdirectory that contains the following line:

-i c:\as\include

This so-called key file tells AS where to look for include files. 
You have to extend your AUTOEXEC.BAT by the statement

set ASCMD=@c:\as\lib\as.rc

to tell AS where to find the key file on invocation.  The following
section will describe what additional options can be set in the key
file.  Finally, move all DOC files to the subdirectory with the same
name and all demo assembler files to the demos subdirectory.  That's
all folks!

+------+
| DPMI |
+------+
As the DPMI version is primarily an Addon to the DOS version designed
for special situations, it is best to previously install the DOS
version according to the scheme outlined above.  Afterwards, on can
copy AS2.EXE and the DPMI server's files to the bin directory
(DPMIUSER.DOC can e.g. be placed in the DOC directory).  If you are
working on an 80286-based system, it is possible that you get the
following message the first time you try to start ASX:

  machine not in database (run DPMIINST)

ASX continually has to switch between real and protected mode; it is
therefore important to find the most efficient way to do this.  For
this purpose (and only for this), you have to run the program
DPMIINST once.  As DPMIINST wants to be the sole master of the
protected mode, you probably have to remove an installed HIMEM driver
before you can do the installation (you may insert HIMEM again after
the run).  Simply follow the instructions DPMIINST prints.  You do not
need this program after the installation any more, only the following
ones are still required:

  - DPMI16BI.OVL :  DPMI server
  - DPMILOAD.EXE :  loader for the DPMI server
  - RTM.EXE      :  runtime control module

+------+
| OS/2 |
+------+
The installation of the OS/2 version can generally be done just like
for the DOS version, with the difference that all EXE and OVR can
rightaway be deleted and replaced by the OS/2 counterparts.  In
contrast to DOS, the setting of the ASCMD variable has to be done
from CONFIG.SYS (the position of the statement is however again
arbitrary).

+------+
| UNIX |
+------+
As the C version comes in source code, the installation is naturally
a bit more complicated.  Roughly said, the necessary steps consist of
an adaption of the makefiles, starting the compilation, doing a
testrun, and installing the executables, includes, and
documentation.  The details can be found in README.  OS/2 users
should also read README.OS2 to avoid unsatisfying failures!

       2.4. Start-Up Command, Parameters
       ---------------------------------

AS is a command line driven program, i.e. all parameters and file
options are to be given in the command line.  

+-----+
| DOS |
+-----+
In order to fulfill AS's memory requirements under DOS, the various
code generator modules were moved for the DOS version to an overlay
file. Its existence is checked by the assembler immediately after
program startup.  If the file is not found, the program run will find
an abrupt end already at this position...  The file AS.OVR should be
always in the same directory as the EXE-file.  Using overlays
naturally results in slight overhead.  AS tries to reduce this by
using possibly existing EMS or XMS memory.  In case this results in
trouble, you may suppress usage of EMS or XMS by setting the
environment variable USEXMS or USEEMS to n.  E.g., it is possible to
suppress the using of XMS by the command:

   SET USEXMS=n

Since AS performs all in- and output via the operating system (and
therefore it should run also on not 100% compatible DOS-PC's) and
needs some basic display control, it emits ANSI control sequences
during the assembly.  

+----------+
| DOS/DPMI |
+----------+
In case you should see strange characters in the messages displayed
by AS, your CONFIG.SYS is obviously lacking a line like this:

   device=ansi.sys 

but the further functions of AS will not be influenced hereby. 
Alternatively you are able to suppress the output of ANSI sequences
completely by setting the environment variable USEANSI to n.

+------+
| DPMI |
+------+
The DOS extender of the DPMI version can be influenced in its memory
allocation strategies by a couple of environment variables; if you
need to know their settings, you may look up them in the file
DPMIUSER.DOC.  ASX is additionally able to extend the available
memory by a swap file.  To do this, set up an environment variable
ASXSWAP in the following way:

  SET ASXSWAP=<size>[,file name]

The size specification is done in megabytes and HAS to be done.  The
file name in contrast is optional; if it is missing, the file is
named ASX.TMP and placed in the current directory.  In any case, the
swap file is deleted after program end.

+------+
| DPMI |
+------+
The longer loading time can be slightly reduced by using the program
RTMRES.  It loads the control programs residently and starts a new
shell, resulting in a reduced loading overhead for subsequent calls. 
A simple EXIT from the shell removes the control programs again.

The parameters can be divided roughly into two categories: switches
and file specifications.  Parameters of these two categories may be
arbitrarily mixed in the command line.  The assembler evaluates at
first all parameters and then assembles the specified files.  From
this follow two things:

 - the specified switches affect all specified source files. If 
   several source files shall be assembled with different switches, 
   this has to be done in separate runs.

 - it is possible to assemble more than one file in one shot and to 
   bring it to the top, it is allowed that the file specs contain 
   wildcards.

Parameter switches are recognized by AS by starting with 
a slash (/) or hyphen (-).  There are switches that are only one
character long and additionally switches composed of a whole word. 
Whenever AS cannot interpret a switch as a whole word, it tries to
interprete every letter as an individual switch.  For example, if you
write 

 -queit

instead of

 -quiet

AS will take the letters q, u, e, i, and t as individual switches. 
Multiple-letter switches additionally have the difference to
single-letter switches that AS will accept an arbitrary mixture of
upper and lower casing, whereas single-letter switches may have a
different meaning depending on whether upper or lower case is used.


At the moment, the following switches are defined:

 -  l : sends assembler listing to console terminal (mostly screen).  
        In case several passes have to be done, the listing of all 
        passes will be send to the console (in opposite to the next
        option).
 -  L : writes assembler listing into a file. The list file will get
        the same name as the source file, only the extension is 
        replaced by LST .

 -  o : Sets the new name of the code file generated by AS.  If this 
        option is used multiple times, the names will be assigned, one
        after the other, to the source files which have to be
        assembled.  A negation (see below) of this option in
        connection with a name erases this name from the list.  A
        negation without a name erases the whole list.

 -  c : SHARED-variables will be written in a format which permits 
        an easy integration into a C-source file.  The extension of 
        the file is "H".
 -  p : SHARED-variables will be written in a format which permits 
        easy integration into the CONST-block of a Pascal program. 
        The extension of the file is "INC". 
 -  a : SHARED-variables will be written in a format which permits 
        easy integration into an assembler source file. The 
        extension of the file is "INC".

Concerning effect and function of the SHARED-symbols please see 
           chapters 2.8. resp. 3.8.1.

 -  g : This switch instructs AS to create an additional file that
        contains debug information for the program.  This info is
        comprised of a symbol table and a table describing the
        assignment of source lines to machine addresses.  A more
        detailed description of the used file format can be found
        in section 5.2.  The file's extension is MAP.

 -  w : suppress issue of warnings;

 -  E [file] : error messages and warnings produced by AS will be 
               redirected to a file. Instead of a file, the 5 standard 
               handles (STDIN..STDPRN) can also be specified as 
               !0 to !4 . Default is !2, meaning STDERR.  If the 
               file option is left out, the name of the error file 
               is the same as of the source file, but with the 
               extension "LOG".

 -  q : This switch suppresses all messages of AS, the exceptions are 
        error messages and outputs which are are forced from the 
        source file.  The time needed for assembly is slightly reduced 
        hereby and if you call AS from a shell there is no redirection 
        required.  The disadvantage is that you may "stay in the dark" 
        for several minutes ... It is valid to write 'quiet' instead
        of 'q'.

 -  h : write hexadecimal numbers in lowercase instead of capital
        letters. This option is primarily a question of personal
        taste.

 -  i <path list> : issues a list of directories where the 
                    assembler shall automatically search for include 
                    files, in case it didn't find a file in the
                    current directory.  The different directories
                    have to be separated by semicolons.

 -  u : calculate a list of areas which are occupied in the segments. 
        This option is effective only in case a listing is 
        produced. This option requires considerable additional 
        memory and computing performance. In normal operation it 
        should be switched off.

 -  C : generates a list of cross references.  It lists which (global)
        symbols are used in files and lines.  This list will also be
        generated only in case a listing is produced.  This option
        occupies, too, additional memory capacity during assembly.

 -  s : issues a list of all sections (see chapter 3.7).  The nesting 
        is indicated  by indentations (Pascal like).

 -  t : by means of this switch it is possible to separate single 
        components of the standard issued assembler-listing.  The
        assignment of bits to parts can be found in the next section,
        where the exact format of the assembly listing is explained.

 -  D : defines symbols.  The symbols which are specified behind this 
        option and separated by commas are written to the 
        global symbol table before starting the assembly.  As default 
        these symbols are written as integer numbers with the 
        value TRUE, by means of an appended equal sign, however, you
        can select other values.  The expression following the equals
        sign may include operators or internal functions, but NOT 
        any further symbols, even if these should have been defined
        before in the list!  Together with the commands for
        conditional assembly (see there) you may produce different
        program versions out of one source file by command line
        inputs.

 -  A : stores the list of global symbols in another, more compact 
        form.  Use this option if the assembler crashes with a stack 
        overflow because of too long symbol tables.  Sometimes this
        option can increase the processing speed of the assembler, but
        this depends on the sources.

 -  x : if present, errors get an extended message, so the 
        identification of the fault should be easily possible.  What 
        kind of added information the error messages contains, is 
        given in the list of error messages (see appendix A).
 
 -  n : If this option is set, the error messages will be issued 
        additionally with their error number (see appendix A).  This 
        is primarily intended for use with shells or IDE's to make
        the identification of errors easier by those numbers.

 -  U : This option switches AS to the case-sensitive mode, i.e. 
        upper and lower case in the names of symbols, sections, macros,
        and user-defined functions will be distinguished.  This is
        not the case by default.

 -  P : instructs AS to write the source text processed by macro 
        processor and conditional assembly into a file.  Additional 
        blank and pure comment lines are missing in this file.  The 
        extension of this file is "I".
 
 -  M : If this switch is given, AS generates a file, that contains 
        definitions of macros defined in the source file that did not
        use the NOEXPORT option.  This new file has the same name as
        the source file, only the extension is modified into "MAC". 

 -  G : this switch defines whether AS should produce code or not. 
        If switched off, the processing will be stopped after the macro 
        processor. This switch is activated by default (logically, 
        otherwise you would not get a code file). This switch can be
        used in conjunction with the P switch, if only the macro
        processor of AS shall be used.

 -  r [n] : issue warnings if situations occur that force a further 
            pass. This information can be used to reduce the number of 
            passes.  You may optionally specify the number of the 
            first pass where issuing of such messages shall start.
            Without this argument, warnings will come starting with
            the first pass.  Be prepared for a bunch of messages!!       

 - alias <new>=<old> :
        defines the processor type <new> to be an alias for the
        type <old>.  See section 2.7. for the sense of processor
        aliases.

As long as switches require no arguments and their concatenation does
not result in a multi-letter switch, it is possible to specify several 
switches at one time, as in the following example :

 as test*.asm firstprog -cl /i c:\as\8051\include

All files TEST*.ASM as well as the file FIRSTPROG.ASM will be 
assembled, whereby listings of all files are displayed on the 
console terminal.  Additional sharefiles will be generated in the C-
format.  The assembler should search for additional include files 
in the directory C:\AS\8051\INCLUDE .

This example shows that the assembler assumes "ASM" as the default 
extension for source files.

Beside from specifying options in the command line, permanently
needed options may be placed in the environment variable ASCMD.  For
example, if someone always wants to have assembly listings and has a
fixed directory for include files, he can save a lot of typing with
the following command:

 set ascmd=-L -i c:\as\8051\include

The environment options are processed before the command line,
so options in the command line can override contradicting ones in the
environment variable.

In the case of very long path names, space in the ASCMD variable may
become a problem.  For such cases a key file may be the alternative,
in which the options can be written in the same way as in the command
line or the ASCMD-variable.  But this file may contain several lines
each with a maximum length of 255 characters.  In a key file it is
important, that for options which require an argument, switches and
argument have to be written in the SAME line.  AS gets informed of
the name of the key file by a "@" aheaded in the ASCMD variable,
e.g.

set ASCMD=@c:\as\as.key

In order to neutralize options in the ASCMD variable (or in the 
key file), prefix the option with a plus sign.  For example, if you
do not want to generate an assembly listing in an individual case,
the option can be retracted in this way:

as +L <file>

Naturally it is not consequently logical to deny an option by a 
plus sign....  UNIX soit qui mal y pense.

In case that you like to start AS from another program or a shell and
this shell hands over only lower-case or capital letters in the
command line, the following workaround exists: if a tilde "~" is put
in front of an option letter, the following letter is always
interpreted as a lower-case letter.  Similarly a "#" demands the
interpretation as a capital letter.  For example, the following
transformations result for:

 /~I ---> /i
 -#u ---> -U

In dependence of the assembly's outcome, the assembler ends with
the following return codes:

 0 : error free run, at maximum warnings occurred 
 1 : The assembler displayed only its command-line parameters and 
     terminated immediately afterwards. 
 2 : Errors occurred during assembly, no code file has been produced. 
 3 : A fatal error occurred what led to immediate termination of the run. 
 4 : An error occurred already while starting the assembler. 
     This may be a parameter error or a faulty overlay file. 
255: An internal error occurred during initialization that should not
     occur in any case...reboot, try again, and contact me if the
     problem is reproducible!

+------+
| OS/2 |
+------+
Similar to UNIX, OS/2 extends an application's data segment on demand
when the application really needs the memory.  Therefore, an output
like

  511 KByte available memory

does not indicate a shortly to come system crash due to memory lack,
it simply shows the distance to the limit when OS/2 will push up the
data segment's size again...

+------+
| UNIX |
+------+
As there is no compatible way in C under different operating systens
to find out the amount of available memory resp. stack, both lines
are missing completely from the statistics the C version prints.


       2.5. Format of the Input Files
       ------------------------------

Like most assemblers, AS expects exactly one instruction per line
(blank lines are naturally allowed as well).  The lines must not be
longer than 255 characters, additional characters are discarded.

A single line has following format:

[label[:]] <mnemonic>[.attribute] [parameter[,parameter..]] [;comment]

The colon for the label is optional, in case the label starts in the
first column (the consequence is that a mnemonic must not start in
column 1).  It is necessary to set the colon in case the label does
not start in the first column so that AS is able to distinguish it
from a mnemonic.  In the latter case, there must be at least one space
between colon and mnemonic if the processor belongs to a family that
supports an attribute that denotes an instruction format and is
separated from the mnemonic by a colon.  This restriction is
necessary to avoid ambiguities: a distinction between a mnemonic with
format and a label with mnemonic would otherwise be impossible.

In the case of 680x0, SH7000, TLCS-9000, M16(C), XA, MSP430 and H8,
an attribute attached to a mnemonic with a dot serves as a description
of the operand length. The following attribute letters are defined:

   attribute     arithmetical-logic instruction        jump instruction

       B          byte (8 bit)                             -------

       W/H        word (16 bit)                            -------

       L/D/W      longword (32 bit)                    16-bit-displacement

       Q          quad word (64 bit)                       -------

       S          single precision (32 bit)            8-bit-displacement

       D          double precision (64 bit)                -------

       X          extended precision (80/96 bit)       32-bit-displacement

       P          decimal floating point (80/96 bit)       -------

CAUTION: not all instructions allow any operand length, and some
instructions have no attribute at all. For more exact studies consult
a reasonable programmer's manual, e.g. [Williams] or equivalent.

In the case of TLCS-9000, H8/500, and M16(C), the attribute serves
both as an operand size specifier (if it is not obvious from the
operands) and as a description of the instruction format to be used. 
A colon has to be used to separate the format from the operand size,
e.g. like this:

    add.w:g   rw10,rw8

This example does not show that there may be a format specification
without an operand size.  In contrast, if an operand size is used
without a format specification, AS will automatically use the
shortest possible format.  The allowed formats and operand sizes
again depend on the machine instruction and may be looked up e.g. in
[Tosh900], [HitH8_5], [MitM16], resp. [MitM16C].

The number of instruction parameters depends on the mnemonic and is 
principally located between 0 and 20.  The separation of the parameters 
from each other is to be performed only by commas (exception: DSP56000, 
its parallel data transfers are separated with blanks).  Commas that 
are included in brackets or quotes, of course, are not taken into 
consideration.  

Instead of a comment at the end, the whole line can consist of 
comment if it starts in the first column with a semicolon.

To separate the individual components you may also use tabulators
instead of spaces.


        2.6. Format of the Listing
        --------------------------

The listing produced by AS using the command line options i or I is 
roughly divisible into the following parts :

1. issue of the source code assembled;
2. symbol list;
3. arbitration list;
4. cross reference list.

The two last ones are only generated if they have been demanded by 
additional command line options.

In the first part, AS lists the complete contents of all source files 
including the produced code.  A line of this listing has the following 
form:

[<n>] <line>/<address> <code> <source>

In the field "n", AS displays the include nesting level.  The main file 
(the file where assembly was started) has the depth 0, an included 
file from there has depth 1 etc..  Depth 0 is not displayed.

In the field "line", the source line number of the referenced file is 
issued. The first line of a file has the number 1.  The address at 
which the code generated from this line is written follows after the 
slash in the field "address".

The code produced is written behind "address" in the field "code", 
in hexadecimal notation. Depending on the processor type and actual 
segment the values are formatted either as bytes or 16/32-bit-words.
If more code is generated than the field can take, additional lines
will be  generated, in which case only this field is used.

Finally, in the field "source", the line of the source file is issued in 
its original form.

The symbol table was designed in a way that it can be displayed on an
80-column display whenever possible. For symbols of "normal length",
a double column output is used.  If symbols exceed (with their name
and value) the limit of 40 columns (characters), they will be issued
in a separate line. The output is done in alphabetical order. 
Symbols that have been defined but were never used are marked with a
star (*) as prefix.

The parts mentioned so far as well as the list of all macros/functions 
defined can be selectively masked out from the listing. 
This can be done by the already mentioned command line switch -t. 
There is an internal byte inside AS whose bits represent which parts 
are to be written.  The bits are assigned to the following parts:

bit   part

 0    source file(s) + produced code
 1    symbol table
 2    macro list
 3    function list
 4    line numbering

All bits are set to 1 by default, when using the switch

-t <mask>

Bits set in <mask> are cleared, so that the respective listing 
parts are suppressed.  Accordingly it is possible to switch on single 
parts again with a plus sign, in case you had switched off too much 
with the ASCMD variable... If someone wants to have, for example, 
only the symbol table, it is enough to write:

-t 2  

The usage list issues the occupied areas hexadecimally for every 
single segment.  If the area has only one address, only this is written, 
otherwise the first and last address.

The cross reference list issues any defined symbol in alphabetical 
order and has the following form:

 symbol <symbol name> (=<value>,<file>/<line>): 
  file <file 1>:
  <n1>[(m1)]  ..... <nk>[(mk)]
  .
  .
  file <file l>:
  <n1>[(m1)]  ..... <nk>[(mk)]

The cross reference list lists for every symbol in which files and
lines it has been used.  If a symbol was used several times in the
same line, this would be indicated by a number in brackets behind the
line number.  If a symbol was never used, it would not appear in the
list; The same is true for a file that does not contain any
references for the symbol in question.

Attention!  AS can only print the listing correctly if it was
previously informed about the output media's page length and width! 
This has to be done with the PAGE instruction (see there).  The
preset default is a length of 60 lines and an unlimited line width.


        2.7. Symbol Conventions
        -----------------------

Symbols are allowed to be up to 255 characters long (as hinted already 
in the introduction) and are being distinguished on the whole 
length, but the symbol names have to meet some conventions:
 
Symbol names are allowed to consist of a random combination of 
letters, digits, underlines and dots, whereby the first character must 
not be a digit. The dot is only allowed to meet the MCS-51 notation of 
register bits and should - as far as possible - not be used in own symbol 
names.  To separate symbol names in any case the underline "_" and not 
the dot "." should be used .

AS is by default not case-sensitive, i.e. it does not matter whether
one uses upper or lower case characters.  The command line switch U
however allows to switch AS into a mode where upper and lower case
makes a difference.  The predefined symbol CASESENSITIVE signifies
whether AS has been switched to this mode: TRUE means case-
sensitiveness, and FALSE its absence.

These are the most important symbols predefined by AS:

name           meaning

TRUE           logically "true"
FALSE          logically "false"

CONSTPI        Pi (3.1415.....)

VERSION        version of AS in BCD-coding, 
               e.g. 1331 hex for version 1.33p1

DATE           date and 
TIME           time of the assembly (start)

MOMCPU         current target CPU 
               (see the CPU instruction)

MOMFILE        current source file
MOMLINE        line number in source file
MOMPASS        number of the currently running pass
MOMSECTION     name of the current section 
               or an empty string

*, $ resp. PC  current value of program counter 

CAUTION!  While it does not matter in case-sensitive mode which
combination of upper and lower case to use to reference predefined
symbols, one has to use exactly the version given above (only upper
case) when AS is in case-sensitive mode!

Additionally some pseudo instructions define symbols that reflect the
value that has been set  with these instructions.  Their descriptions
are explained at the individual commands belonging to them.

A hidden feature (that has to be used with care) is that symbol names
may be assembled from the contents of string symbols.  This can be
achieved by framing the string symbol's name with braces and
inserting it into the new symbol's name.  This allows for example to
define a symbol's name based on the value of another symbol:

cnt             set     cnt+1
temp            equ     "\{CNT}"
                jnz     skip{temp}
                .
                .
skip{temp}:     nop

CAUTION:  The programmer has to assure that only valid symbol names
are generated!

A complete list of all symbols predefined by AS can be found in
appendix E.


        2.8. Formula Expressions
        ------------------------

In most places where the assembler expects numeric inputs, it is
possible to specify not only simple symbols or constants, but also
complete formula expressions.  The components of these formula
expressions can be either single symbols and constants.  The notation
of integer constants can be done in different numbering systems:

                 Intel mode         Motorola mode        C mode
                 (Intel, Zilog,    (Rockwell, Motorola,  (PowerPC,
                  Thomson Texas,    Microchip, Thomson,   AMD 29K,
                  Toshiba, NEC,     Hitachi, Atmel)       National)
                  Siemens, Philips)

decimal          direct               direct             direct

hexadecimal      followed by H        aheaded $       aheaded 0x

binary           followed by B        aheaded %       aheaded 0b

octal            followed by O        aheaded @       aheaded 0

To prevent a misinterpretation of hexadecimal constants (as symbol 
names) in the Intel mode, they must be started always by a digit; 
instead of e.g. F0H there must be written 0F0H.  The Motorola mode 
doesn't know such problems (grin..). 

With the help of the RELAXED instruction (see there), the strict
assignment of a syntax to a certain target processor can be removed. 
The result is that an arbitrary syntax may be used (loosing
compatibility to standard assemblers).  This option is however turned
off by default.

Integer constants may also be written as ASCII values, like in
the following examples:

'A'    == $41
'AB'   == $4142
'ABCD' == $41424344

It is important, to write the characters in singel quotes, to 
distinguish them from string constants (discussed somewhat later).

Floating point constants are to be written in the usual scientific 
notation, which is known in the most general form:

 [-]<integer digits>[.post decimal positions][E[-]exponent]

CAUTION! The assembler first tries to interprete a constant as an
integer constant and makes a floating-point format try only in case
the first one failed.  If someone wants to enforce the evaluation as
a floating point number, this can be done by dummy post decimal
positions, e.g.  2.0 instead of 2 .

String constants have to be included in quotation marks. In order to 
make it possible to write quotation marks and special characters without 
trouble in string constants, an "escape mechanism" has been worked in, 
which probably is familiar to C-programmers: 

The assembler understands a backslash (\) with a following decimal
number of three digits maximum in the string as a character with the
according decimal ASCII value.  So it is possible to define by

\3

+------+
| UNIX |
+------+
an ETX-character.  But be careful with the definition of NUL
characters!  The C version currently uses C strings to store strings
internally.  As C strings use a NUL character for termination, the
usage of NUL characters in strings is currently not portable!

Some frequently used control characters can also be reached with the
following abbreviations:

\b : Backspace           \a : Bell         \e : Escape
\t : Tabulator           \n : Linefeed     \r : Carriage Return
\\ : Backslash           \' or \H : Apostrophe 
\" or \I : Quotation marks

Both upper and lower case characters may be used for the
identification letters.

By means of this escape character, you can even work formula
expressions into a string, if they are enclosed by braces: e.g.

     message "root of 81 : \{sqrt(81)}"

results in

              root of 81 : 9

AS chooses with the help of the formula result type the correct
output format, further string constants, however, are to be avoided
in the expression.  Otherwise the assembler will get mixed up at the
transformation of capitals into lower case letters.

Except for the insertion of formula expressions, you can use this 
"escape-mechanism" as well in ASCII defined integer constants, 
like this:

     move.b   #'\n',d0

However, everything has its limits, because the parser with higher 
priority, which disassembles a line into op-code and parameters, does 
not know what it is actually working with, e.g. here:

     move.l   #'\'abc',d0

After the third apostrophe, it will not find the comma any more, 
because it presumes that it is the start of a further character 
constant. An error message about a wrong parameter number is the result.  
A workaround would be to write e.g., \i instead of \'.

The calculation of intermediary results within formula expressions is
always done with the highest available resolution, i.e. 32 bits for
integer numbers, 80 bit for floating point numbers and 255 characters
for strings.  An possible test of value range overflows is done only
on the final result.

+------+
| UNIX |
+------+
The portable C version only supports floating point values up to 64
bits (resulting in a maximum value of roughly 10^308), but in turn
features integer lengths of 64 bits on some platforms.

The assembler provides the following operands for combination:

operand function              #operands integer float     string rank

  <>    inequality                2      yes     yes       yes    14
  >=    greater than or equal     2      yes     yes       yes    14
  <=    less or equal             2      yes     yes       yes    14
  <     truly smaller             2      yes     yes       yes    14
  >     truly greater             2      yes     yes       yes    14
  =     equality                  2      yes     yes       yes    14

  !!    log. XOR                  2      yes     no        no     13
  ||    log. OR                   2      yes     no        no     12
  &&    log. AND                  2      yes     no        no     11
  ~~    log. NOT                  1      yes     no        no      2

  -     difference                2      yes     yes       no     10
  +     sum                       2      yes     yes       yes    10
  #     modulo division           2      yes     no        no      9
  /     quotient                  2      yes *)  yes       no      9
  *     product                   2      yes     yes       no      9
  ^     power                     2      yes     yes       no      8

  !     binary XOR                2      yes     no        no      7
  |     binary OR                 2      yes     no        no      6
  &     binary AND                2      yes     no        no      5
  ><    mirror of bits            2      yes     no        no      4
  >>    log. shift right          2      yes     no        no      3
  <<    log. shift left           2      yes     no        no      3
  ~     binary NOT                2      yes     no        no      1

*) remainder will be discarded


"Rank" is the priority of an operator at the separation of expressions 
into subexpressions.  The operator with the highest rank will be 
evaluated at the very end.  The order of evaluation can be defined by 
new bracketing.

The compare operators deliver TRUE in case the condition fits, 
and FALSE in case it doesn't.  For the logical operators an expression 
is TRUE in case it is not 0, otherwise it is FALSE.

The mirroring of bits probably needs a little bit of explanation: the 
operator mirrors the lowest bits in the first operand and leaves the 
higher priority bits unchanged.  The number of bits which is to be 
mirrored is given by the right operand and may be between 1 and 32 .

In addition to the operators, the assembler defines another line of 
primarily transcendental functions with floating point arguments:

name      meaning              argument             result

SQRT      square root          arg >= 0             floating point

SIN       sine                 arg real             floating point
COS       cosine               arg real             floating point
TAN       tangent              arg <> (2*n+1)*Pi/2  floating point
COT       cotangent            arg <> n*Pi          floating point

ASIN      inverse sine         |arg| <= 1           floating point
ACOS      inverse cosine       |arg| <= 1           floating point
ATAN      inverse tangent      arg real             floating point
ACOT      inverse cotangent    arg real             floating point

EXP       exponential function arg real             floating point
ALOG      10 power of argument arg real             floating point
ALD       2 power of argument  arg real             floating point
SINH      hyp. sine            arg real             floating point
COSH      hyp. cosine          arg real             floating point
TANH      hyp. tangent         arg real             floating point
COTH      hyp. cotangent       arg <> 0             floating point

LN        nat. logarithm       arg > 0              floating point
LOG       dec. logarithm       arg > 0              floating point
LD        bin. logarithm       arg > 0              floating point
ASINH     inv. hyp. Sine       arg real             floating point
ACOSH     inv. hyp. Cosine     arg >= 1             floating point
ATANH     inv. hyp. Tangent    arg < 1              floating point
ACOTH     inv. hyp. Cotangent  arg > 1              floating point

INT       integer part         arg real             floating point

BITCNT    number of one's      integer              integer
FIRSTBIT  lowest 1-bit         integer              integer
LASTBIT   highest 1-bit        integer              integer
BITPOS    unique 1-bit         integer              integer

SGN       sign (0/1/-1)        floating point       integer
                               or integer
ABS       absolute value       integer or           integer or
                               floating point       floating point
TOUPPER   matching capital     integer              integer
TOLOWER   matching lower case  integer              integer

UPSTRING  changes all          string               string  
          characters
          into capitals 

LOWSTRING changes all          string               string  
          characters
          into to lower case 

VAL       evaluates contents   string               depends on
          as expression                             argument


The functions FIRSTBIT, LASTBIT, and BITPOS return -1 as result if
no resp. not exactly one bit is set.  BITPOS additionally issues an
error message in such a case.

If a function expects floating point arguments, this does not mean it
is impossible to write e.g.

    sqr2 equ sqrt(2)

In such cases an automatic type conversion is engaged. In the reverse
case the INT-function has to be applied to convert a floating point
number to an integer.  When using this function, you have to pay
attention that the result produced always is a signed integer and
therefore has a value range of approximately +/-2.0E9.

When AS is switched to case-sensitive mode, predefined functions may be
accessed with an arbitrary combination of upper and lower case (in
contrast to predefined symbols).  However, in the case of
user-defined functions, a distinction between upper and lower case is
made.  This has e.g. the result that if one defines a function 'Sin',
one can afterwards access this function via 'Sin', but all other
combinations of upper and lower case will lead to the predefined
function.

+----------+
| DOS/DPMI |
+----------+
For a correct conversion of lower case letters into capital letters a DOS
version >= 3.30 is required.


        2.9. Forward References and Other Disasters
        -------------------------------------------

This section is the result of a significant amount of hate on the
(legal) way some people program.  This way can lead to trouble in
conjunction with AS in some cases.  The section will deal with
so-called 'forward references'.  What makes a forward reference
different from a usual reference?  To understand the difference, take
a look at the following programming example (please excuse my bias
for the 68000 family that is also present in the rest of this
manual):

        move.l  d0,#10
loop:   move.l  d1,(a1)
        beq     skip   
        neg.l   d1     
skip:   move.l  (a1+),d1
        dbra    d0,loop 

If one overlooks the loop body with its branch statement, a program
remains that is extremely simple to assemble: the only reference is
the branch back to the body's beginning, and as an assembler
processes a program from the beginning to the end, the symbol's value
is already known before it is needed the first time.  If one has a
program that only contains such backward references, one has the nice
situation that only one pass through the source code is needed to
generate a correct and optimal machine code.  Some high level
languages like Pascal with their strict rule that everything has to
be defined before it is used exploit exactly this property to speed
up the compilation.

Unfortunately, things are not that simple in the case of assembler,
because one sometimes has to jump forward in the code or there are
reasons why one has to move variable definitions behind the code. 
For our example, this is the case for the conditional branch that is
used to skip over another instruction.  When the assembler hits the
branch instruction in the first pass, it is confronted with the
situation of either leaving blank all instruction fields related to
the target address or offering a value that 'hurts noone' via the
formula parser (which has to evaluate the address argument).  In case
of a 'simple' assembler that supports only one target architecture
with a relatively small number of instructions to treat, one will
surely prefer the first solution, but the effort for AS with its
dozens of target architectures would have become extremely high. 
Only the second way was possible: If an unknown symbol is detected in
the first pass, the formula parser delivers the program counter's
current value as result!  This is the only value suitable to offer an
address to a branch instruction with unknown distance length that
will not lead to errors.  This answers also a frequently asked
question why a first-pass listing (it will not be erased e.g. when AS
does not start a second pass due to additional errors) partially
shows wrong addresses in the generated binary code - they are the
result of unresolved forward references.

The example listed above however uncovers an additional difficulty of
forward references: Depending on the distance of branch instruction
and target in the source code, the branch may be either long or
short.  The decision however about the code length - and therefore
about the addresses of following labels - cannot be made in the first
pass due to missing knowledge about the target address.  In case the
programmer did not explicitly mark whether a long or short branch
shall be used, genuine 2-pass assemblers liker oder versions of MASM
from Microsoft 'solve' the problem by reserving space for the longest
version in the first pass (all label addresses have to be fixed after
the first pass) and filling the remaining space with NOPs in the
second pass.  AS versions up to 1.37 did the same before I switched
to the multipass principle that removes the strict separation into
two passes and allows an arbitrary number of passes.  Said in detail,
the optimal code for the assumed values is generated in the first
pass.  If AS detects that values of symbols changed in the second
pass due to changes in code lengths, simply a third pass is done, and
as the second pass'es new symbol values might again shorten or
lengthen the code, a further pass is not impossible.  I have seen
8086 programs that needed 12 passes to get everything correct and
optimal.  Unfortunately, this mechanism does not allow to specify a
maximum number passes; I can only advise that the number of passes
goes down when one makes more use of explicit length specifications.

Especially for large programs, another situation might arise: the
position of a forward directed branch has moved so much in the second
pass relative to the first pass that the old label value still valid
is out of the allowed branch distance.  AS knows of such situations
and suppresses all error messages about too long branches when it is
clear that another pass is needed.  This works for 99% of all cases,
but there are also constructs where the first critical instruction
appears so early that AS had no chance up to now to recognize that
another pass is needed.  The following example constructs such a
situation with the help of a forward reference (and was the reason
for this section's heading...):

        cpu   6811

        org     $8000
        beq     skip
        rept    60
         ldd    Var
        endm
skip:   nop

Var     equ     $10

Due to the address position, AS assumes long addresses in the first
pass for the LDD instructions, what results in a code length of 180
bytes and an out of branch error message in the second pass (at the
point of the BEQ instruction, the old value of 'skip' is still valid,
i.e. AS does not know at this point that the code is only 120 bytes
long in reality) is the result.  The error can be avoided in three
different ways:

 1. Explicitly tell AS to use short addressing for the LDD
    instructions (ldd <Var)

 2. Remove this damned, rotten forward reference and place the EQU
    statement at the beginning where it has to be (all right, I'm
    already calming down...)

 3. For real die-hards: use the '-Y' command line option.  This
    option tells AS to forget the error message when the address 
    change has been detected.  Not pretty, but...

Another tip regarding the EQU instruction: AS cannot know in which
context a symbol defined with EQU will be used, so an EQU containing
forward references will not be done at all in the first pass.  Thus,
if the symbol defined with EQU gets forward-referenced in the second
pass:

        move.l  #sym2,d0
sym2    equ     sym1+5
sym1    equ     0

one gets an error message due to an undefined symbol in the second
pass...but why on earth do people do such things?

Admittedly, this was quite a lengthy excursion, but I thought it was
necessary.  Which is the essence you should learn from this section?

 1. AS always tries to generate the shortest code possible.  A
    finite number of passes is needed for this.  If you do not tweak
    AS extremely, AS will know no mercy...

 2. Whenever sensible and possible, explicitly specify branch and 
    address lengths.  There is a chance of significantly reducing the
    number of passes by this.

 3. Limit forward references to what is absolutely needed.  You make
    your and AS's live much easier this way!


        2.10. Sharefile
        ---------------

This function is a by-product from the old pure-68000 predecessors of
AS, I have kept them in case someone really needs it.  The basic
problem is to access certain symbols produced during assembly,
because possibly someone would like to access the memory of the
target system via this address information.  The assembler allows to
export symbol values by means of SHARED pseudo commands (see there). 
For this purpose, the assembler produces a text file with the required
symbols and its values in the second pass.  This file may be included
into a higher-level language or another assembler program.  The
format of the text file (C, Pascal or Assembler) can be set by the
command line switches p, c or, a .

CAUTION! If none of the switches is given, no file will be 
generated and it makes no difference if SHARED-commands are in the 
source text or not!

When creating a Sharefile, AS does not check if a file with the 
same name already exists, such a file  will be simply overwritten.  
In my opinion a request does not make sense, because AS would 
ask at each run if it should overwrite the old version of the 
Sharefile, and that would be really annoying ...


        2.11. Processor Aliases
        -----------------------

Common microcontroller families are like rabbits: They become more at
a higher speed than you can provide support for them.  Especially the
development of processor cores as building blocks for ASICs and of
microcontroller families with user-definable peripherals has led to a
steeply rising number of controllers that only deviate from a
well-known type by a slightly modified peripheral set.  But the
distinction among them is still important, e.g. for the design of
include files that only define the appropriate subset of peripherals. 
I have struggled up to now to integrate the most important
reperesentatives of a processor family into AS (and I will continue
to do this), but sometimes I just cannot keep pace with the
development...there was an urgent need for a mechanism to extend the
list of processors by the user.

The result are processor aliases: the alias command line option
allows to define a new processor type, whose instruction set is equal
to another processor built into AS.  After switching to this
processor via the CPU instruction, AS behaves exactly as if the
original processor had been used, with a single difference: the
variables MOMCPU resp. MOMCPUNAME are set to the alias name, which
allows to use the new name for differentiation, e.g. in include files.

There were two reasons to realize the definition of aliases by the
command line and not by pseudo instructions: first, it would anyway
be difficult to put the alias definitions together with register
definitions into a single include file, because a program that wants
to use such a file would have to include it before and after the CPU
instruction - an imagination that lies somewhere between inelegant
and impossible.  Second, the definition in the command line allows to
put the definitions in a key file that is executed automatically at
startup via the ASCMD variable, without a need for the program to
take any further care about this.


        3. Pseudo Instructions
        ======================

Not all pseudo instructions are defined for all processors.  A note
that shows the range of validity is therefore prepended to every
individual description. 


        3.1. Definitions
        ----------------

        3.1.1.  SET and EQU
        - - - - - - - - - -

--> valid for: all processors

SET and EQU allow the definition of typeless constants, i.e.  they
will not be assigned to a segment and their usage will not generate
warnings because of segment mixing.  EQU defines constants which can
not be modified (by EQU) again, but SET permits the definition of
variables, which can be modified during the assembly.  This is useful
e.g. for the allocation of resources like interrupt vectors, as shown
in the following example:

VecCnt  set     0       ; somewhere at the beginning

        .
        .
        .

DefVec  macro   Name    ; allocate a new vector 
Name    equ     VecCnt
VecCnt  set     VecCnt+4
        endm

        .
        .
        .

        DefVec  Vec1    ; results in Vec1=0
        DefVec  Vec2    ; results in Vec2=4

constants and variables are internally stored in the same way, the
only difference is that they can be modified by SET and not by EQU. 
It is therefore possible to define a symbol with EQU and to change it
with SET (even if this is not its real business).  There is also
another reason to avoid this explicitly:  In contrast to SET, EQU
checks whether the newly assigned value is different to from a value
that previously might have existed.  As the value should not change
for constants defined with EQU, AS assumes a phase error and starts
another pass...for example, if one would use EQU instead of SET to
initialize the counter in the previous example, AS would not quarrel
as a single reassignment per pass is valid (this line is executed
only n times in n passes), but endless repassing would be the result
as the counter's initial value is always different to the final value
in the previous pass.

EQU/SET allow to define constants of all possible types, e.g.

IntTwo     equ   2
FloatTwo   equ   2.0

Some processors unfortunately have already a SET instruction. For
these targets, EVAL must be used instead of SET.

A simple equation sign may be used instead of EQU.  Similarly, one
may simply write := instead of SET resp. EVAL.

Symbols defined with SET or EQU are typeless by default, but
optionally a segment name (CODE, DATA, IDATA, XDATA, YDATA, BITDATA,
IO, or REG) or MOMSEGMENT for the currently active segment may be
given as a second parameter, allowing to assign the symbol to a
specific address space.


        3.1.2. SFR and SFRB
        - - - - - - - - - -

--> valid for: various, SFRB only MCS-51

These instructions act like EQU, but symbols defined with them are
assigned to the directly addressable data segment, i.e. they serve
preferential for the definition of RAM-cells and (as the name lets
guess) hardware registers mapped into the data area.  The allowed
range of values is equal to the range allowed for ORG in the data
segment (see section 3.2.1.).  The difference between SFR and SFRB is
that SFRB marks the register as bit addressable, which is why AS
generates 8 additional symbols which will be assigned to the bit
segment and carry the names xx.0 to xx.7, e.g.

PSW    sfr    0d0h      ; results in PSW = D0H (data segment)

PSW    sfrb   0d0h      ; results in extra PSW.0 = D0H (bit)
                        ;               to PSW.7 = D7H (bit)

The SFRB instruction is not any more defined for the 80C251 as it
allows direct bit access to all SFRs without special bit symbols;
bits like PSW.0 to PSW.7 are automatically present.

Whenever a bit-addressable register is defined via SFRB, AS checks if
the memory address is bit addressable (range 20h..3fh resp. 80h, 88h,
90h, 98h...0f8h).  If it is not bit-addressable, a warning is issued
and the generated bit symbols are undefined.


        3.1.3.  XSFR and YSFR
        - - - - - - - - - - -

--> valid for: DSP56000 

Also the DSP56000 has a few peripheral registers memory-mapped to the
RAM, but the affair becomes complicated because there are two data
areas, the X- and Y-area.  This architecture allows on the one hand a
higher parallelism, but forces on the other hand to divide the normal
SFR instruction into the two above mentioned variations.  They works
identically to SFR, just that XSFR defines a symbol in the X-
addressing space and YSFR a corresponding one in the Y-addressing
space. The allowed value range is 0..$ffff.


        3.1.4.  LABEL
        - - - - - - - 

--> valid for: all processors

The function of the LABEL instruction is identical to EQU, but the
symbol does not become typeless, it gets the attribute "code".  LABEL
is needed exactly for one purpose: Labels are normally local in
macros, that means they are not accessible outside of a macro.  With
an EQU instruction you could get out of it nicely, but the phrasing

<name> label   $

generates a symbol with correct attributes.


        3.1.5.  BIT
        - - - - - -

--> valid for: MCS/(2)51, XA, 80C166, 75K0, ST9

BIT serves to equate a single bit of a memory cell with a symbolic
name.  This instruction varies from target platform to target
platform due to the different ways in which processors handle bit
manipulation and addressing:

The MCS/51 family has an own address space for bit operands.  The
function of BIT is therefore quite similar to SFR, i.e. a simple
integer symbol with the specified value is generated and assigned to
the BDATA segment.  For all other processors, bit addressing is done
in a two-dimensional fashion with address and bit position.  In
these cases, AS packs both parts into an integer symbol in a way that
depends on the currently active target processor and separates both
parts again when the symbol is used.  The latter is is also valid for
the 80C251:  While an instruction like

My_Carry        bit     PSW.7

would assign the value 0d7h to My_Carry on an 8051, a value of
070000d0h would be generated on an 80C251, i.e. the address is
located in bits 0..7 and the bit position in bits 24..26.  This
procedure is equal to the way the DBIT instruction handles things on
a TMS370 and is also used on the 80C166, with the only difference
that bit positions may range from 0..15:

MSB     BIT     r5.15

On a Philips XA, the bit's address is located in bits 0..9 just with
the same coding as used in machine instructions, and the 64K bank of
bits in RAM memory is placed in bits 16..23.

The BIT instruction of the 75K0 family even goes further: As bit
expressions may not only use absolute base addresses, even
expressions like

bit1    BIT     @h+5.2

are allowed.

The ST9 in turn allows to invert bits, what is also allowed in the
BIT instruction:

invbit  BIT     r6.!3

More about the ST9's BIT instruction can be found in the processor
specific hints.


        3.1.6. DBIT
        - - - - - -

--> valid for: TMS 370xxx

Though the TMS370 series does not have an explicit bit segment,
single bit symbols may be simulated with this instruction.  DBIT
requires two operands, the address of the memory cell that contains
the bit and the exact position of the bit in the byte.  For example, 

INT3            EQU     P019
INT3_ENABLE     DBIT    0,INT3

defines the bit that enables interrupts via the INT3 pin.  Bits
defined this way may be used in the instructions SBIT0, SBIT1,
CMPBIT, JBIT0, and JBIT.


        3.1.7. PORT
        - - - - - -

--> valid for: 8080/8085/8086, XA, Z80, 320xx, TLCS-47, AVR

PORT works similar to EQU, just the symbol becomes assigned to the
I/O-address range.  Allowed values are 0..7 at the 3201x, 0..15 at
the 320C2x, 0..65535 at the 8086, 0..63 at the AVR, and 0..255 at the
rest.

Example : an 8255 PIO is located at address 20H:

PIO_port_A     port    20h
PIO_port_B     port    PIO_port_A+1
PIO_port_C     port    PIO_port_A+2
PIO_ctrl       port    PIO_port_A+3


        3.1.8.  REG
        - - - - - -

--> valid for: ST9

REG works similar to SFR, but the symbol is assigned to the register
address space.  Allowed values range from 0 to 255.


        3.1.9.  LIV and RIV
        - - - - - - - - - -

LIV and RIV allow to define so-called 'IV bus objects'.  These are
groups of bits located in a peripheral memory cell with a length of 1
up to 8 bits, which can afterwards be referenced symbolically.  The
result is that one does not anymore have to specify address,
position, and length separately for instructions that can refer to
peripheral bit groups.  As the 8X30x processors feature two
peripheral address spaces (a 'left' and a 'right' one), there are two
separate pseudo instructions.  The parameters of these instructions
are however equal: three parameters have to be given that specify
address, start position and length.  Further hints for the usage of
bus objects can be found in section 4.14 .


        3.1.9.  CHARSET
        - - - - - - - -

--> valid for: all processors

Single board systems, especially when driving LCDs, frequently use
character sets different to ASCII.  So it is probably purely
coincidental that the umlaut coding corresponds with the one used by
the PC.  To avoid error-prone manual encoding, the assembler contains
a translation table for characters which assigns a target character
to each source-code.  To modify this table (which initial translates
1:1), one has to use the CHARSET instruction.  This command expects a
range specification as first resp. first/second parameter for the
characters to become translated.  The last parameter is the range
into that the characters shall become translated.  To make things
clear, two examples:

       CHARSET  'ä',128

means that the target system codes the 'ä'  into the number 128
(80H).  In case that the target system did not support lower-case
letters, a simple


       CHARSET  'a','z','A'

translates all lower-case characters  automatically into the 
matching capital letters.

CAUTION! CHARSET not only affects string constants stored in memory,
but also integer constants written as "ASCII". This means that an
already modified translation table can lead into other results in the
above mentioned examples!


        3.1.10.  ENUM
        - - - - - - -

--> valid for: all processors

Similar to the same-named instruction known from C, ENUM is used to
define enumeration types, i.e. a sequence of integer constants that
are assigned sequential values starting at 0.  The parameters are the
names of the symbols, like in the following example:

        ENUM    SymA,SymB,SymC

This instruction will assign the values 0, 1, and 2 to the symbols
SymA, SymB, and SymC.

ENUM instructions are always single-line instructions, i.e. the
enumeration will again start at zero when a new ENUM instruction is
found.  Multi-line enumerations may however be achieved with a small
trick that exploits the fact that the internal counter can be set to
a new value with an explicit assignment, like in the following case:

        ENUM    January=1,February,March,April,May,June

The numeric values 1..6 are assigned to month names.  One can
continue the enumeration in the following way:

        ENUM    July=June+1,August,September,October
        ENUM    November=October+1,December

A definition of a symbol with ENUM is equal to a definition with EQU,
i.e. it is not possible to assign a new value to a symbol that
already exists.


        3.1.11.  PUSHV and POPV
        - - - - - - - - - - - -

--> valid for: all processors

PUSHV and POPV allow to temporarily save the value of a symbol (that
is not macro-local) and to restore it at a later point of time.  The
storage is done on stacks, i.e. Last-In-First-Out memory structures. 
A stack has a name that has to fulfill the general rules for symbol
names and it exists as long as it contains at least one element: a
stack that did not exist before is automatically created upon PUSHV,
and a stack becoming empty upon a POPV is deleted automatically.  The
name of the stack that shall be used to save or restore symbols is
the first parameter of PUSH resp. POPV, followed by a list of symbols
as further parameters.  All symbols referenced in the list already
have to exist, it is therefore NOT possible to implicitly define
symbols with a POPV instruction.

Stacks are a global resource, i.e. their names are not local to
sections.

It is important to note that symbol lists are ALWAYS processed from
left to right.  Someone who wants to pop several variables from a
stack with a POPV therefore has to use the exact reverse order used in
the corresponding PUSHV!

The name of the stack may be left blank, like this:

        pushv   ,var1,var2,var3
        .
        .
        popv    ,var3,var2,var1

AS will then use a predefined internal default stack.

AS checks at the end of a pass if there are stacks that are not empty
and issues their names together with their "filling level".  This
allows to find out if there are any unpaired PUSHVs or POPVs. 
However, it is in no case possible to save values in a stack beyond
the end of a pass: all stacks are cleared at the beginning of a pass!


        3.2. Code Modification
        ----------------------


        3.2.1.  ORG
        - - - - - -

--> valid for: all processors

ORG allows to load the internal address counter (of the assembler)
with a new value. The value range depends on the currently selected
segment and on the processor type.  The lower bound is always zero,
and the upper bound is the given value minus 1:

processor  CODE     DATA    IDATA   XDATA   YDATA   BITDATA IO      REG

68xx0      4G       ------  ------  ------  ------  ------  ------  ------
           Init 0

DSP56000   64K      ------  ------  64K     64K     ------  ------  ------
           Init 0                   Init 0  Init 0

PowerPC    4G       ------  ------  ------  ------  ------  ------  ------
           Init 0

6800,6301, 64K      ------  ------  ------  ------  ------  ------  ------
6811       Init 0

6805/HC08  8K       ------  ------  ------  ------  ------  ------  ------
           Init 0

6809,      64K      ------  ------  ------  ------  ------  ------  ------
6309       Init 0

68HC12     64K      ------  ------  ------  ------  ------  ------  ------
           Init 0

68HC16     1M       ------  ------  ------  ------  ------  ------  ------
           Init 0

H8/300     64K      ------  ------  ------  ------  ------  ------  ------
H8/300H    16M
           Init 0

H8/500     64K      ------  ------  ------  ------  ------  ------  ------
(Min)      Init 0

H8/500     16M      ------  ------  ------  ------  ------  ------  ------
(Max)      Init 0

SH7000/    4G       ------  ------  ------  ------  ------  ------  ------
7600       Init 0

6502,      64K      ------  ------  ------  ------  ------  ------  ------
MELPS740   Init 0

65816,     16M      ------  ------  ------  ------  ------  ------  ------
MELPS7700  Init 0

MELPS4500  8K       416     ------  ------  ------  ------  ------  ------
           Init 0   Init 0

M16        4G       ------  ------  ------  ------  ------  ------  ------
           Init 0

M16C       1M       ------  ------  ------  ------  ------  ------  ------
           Init 0

MCS-48,    4K       ------  256     256     ------  ------  ------  ------
MCS-41     Init 0           Init 0  Init 0

MCS-51     64K      256     256*)   64K     ------  0--255  ------  ------
           Init 0   Init 0  Init 80H Init 0         Init 0

MCS-251    16M      ------  ------  ------  ------  ------  512     ------
           Init 0                                           Init 0

MCS-96/196 64K      ------  ------  ------  ------  ------  ------  ------
196Nx/296  16M
           Init 0

8080,      64K      ------  ------  ------  ------  ------  256     ------
8085       Init 0                                           Init 0

80x86,     64K      64K     ------  64K     ------  ------  64K     ------
V30/35     Init 0   Init 0          Init 0                  Init 0

8X30x      8K       ------  ------  ------  ------  ------  ------  ------
           Init 0   

XA         16M      16M     ------  ------  ------  ------  2K      ------
           Init 0   Init 0                                  Init 1K

AVR        8K       64K     ------  ------  ------  ------  64      ------
           Init 0   Init 0                                  Init 0

29xxx      4G       ------  ------  ------  ------  ------  ------  ------
           Init 0

80C166,    256K     ------  ------  ------  ------  ------  ------  ------
80C167     16M
           Init 0

Z80,       64K      ------  ------  ------  ------  ------  256     ------
Z180,      512K **)                                         256
Z380       4G                                               4G
           Init 0                                           Init 0

Z8         64K      256     ------  64K     ------  ------  ------  ------
           Init 0   Init 0          Init 0

TLCS-900,  16M      ------  ------  ------  ------  ------  ------  ------
900L       Init 0

TLCS-90    64K      ------  ------  ------  ------  ------  ------  ------
           Init 0

TLCS-870   64K      ------  ------  ------  ------  ------  ------  ------
           Init 0

TLCS-47    64K      1K      ------  ------  ------  ------  16      ------
           Init 0   Init 0                                  Init 0

TLCS-9000  16M      ------  ------  ------  ------  ------  ------  ------
           Init 0

PIC16C5x   2K       32      ------  ------  ------  ------  ------  ------
           Init 0   Init 0

PIC16C64,  8K       512     ------  ------  ------  ------  ------  ------
PIC16C86   Init 0   Init 0

PIC17C42   64K      256     ------  ------  ------  ------  ------  ------
           Init 0   Init 0

ST62xx     4K       256     ------  ------  ------  ------  ------  ------
           Init 0   Init 0

ST7        64K      ------  ------  ------  ------  ------  ------  ------
           Init 0                                                   

ST9        64K      64K     ------  ------  ------  ------  ------  256
           Init 0   Init 0                                          Init 0

6804       4K       256     ------  ------  ------  ------  ------  ------
           Init 0   Init 0

32010      4K       144     ------  ------  ------  ------  8       ------
32015      4K       256                                     8
           Init 0   Init 0                                  Init 0

320C2x     64K      64K     ------  ------  ------  ------  16      ------
           Init 0   Init 0                                  Init 0

320C3x     16M      ------  ------  ------  ------  ------  ------  ------
           Init 0

320C5x     64K      64K     ------  ------  ------  ------  64K     ------
           Init 0   Init 0                                  Init 0

TMS9900    64K      ------  ------  ------  ------  ------  ------  ------
           Init 0

TMS70Cxx   64K      ------  ------  ------  ------  ------  ------  ------
           Init 0

370xxx     64K      ------  ------  ------  ------  ------  ------  ------
           Init 0

MSP430     64K      ------  ------  ------  ------  ------  ------  ------
           Init 0

SC/MP      64K      ------  ------  ------  ------  ------  ------  ------
           Init 0   

COP8       8K       256     ------  ------  ------  ------  ------  ------
           Init 0   Init 0

µPD78(C)10 64K      ------  ------  ------  ------  ------  ------  ------
           Init 0

75K0       16K      4K      ------  ------  ------  ------  ------  ------
           Init 0   Init 0

78K0       64K      ------  ------  ------  ------  ------  ------  ------
           Init 0   

*) As the 8051 does not have any RAM beyond 80h, this value has to be
   adapted with ORG for the 8051 as target processor!!
**) As the Z180 still can address only 64K logically, the whole
    address space can only be reached via PHASE instructions!

In case that different variations in a processor family have address
spaces of different size, the maximum range is listed for each.

ORG is mostly needed to give the code a new starting address or to
put different, non-continuous code parts into one source file.


        3.2.2.  CPU
        - - - - - -

--> valid for: all processors

This command rules for which processor the further code shall be
generated.  Instructions of other processor families are not
accessible afterwards and will produce error messages!

The processors can be distinguished roughly in families, inside the
families different types additionally serve for a detailed
distinction:

a) 68008 --> 68000 --> 68010 --> 68012 --> 68020 --> 68030

The differences in this family lie in additional instructions
and addressing modes (starting from the 68020).  A small exception is
the 68030 that misses two instructions: CALLM and RTM.  The three
representors of the 683xx family have the same processor core (a
slightly reduced 68020 CPU), however completely different
peripherals.

b) 56000

c) PPC403 --> MPC505 --> MPC601 --> RS6000

The PPC403 is a reduced version of the PowerPC line without a
floating point unit, which is why all floating point instructions are
disabled for him; in turn, some microcontroller-specific instructions
have been added which are unique in this family.  The MPC505 (a
microcontroller variant without a FPU) only differ in its peripheral
registers from the 601 as long as I do not know it better - [Mot505]
is a bit reluctant in this respect...  The RS6000 line knows a few
instructions more (that are emulated on many 601-based systems), IBM
additionally uses different mnemonics for their pure workstation
processors, as a reminiscence of 370 mainframes...

d) 6800 --> 6301 --> 6811

While the 6301 only offers a few additional instructions, the 6811
delivers a second index register and much more instructions.

e) 6809/6309 and 6805/68HC08

These processors are partially source-code compatible to the other
68xx processors, but they have a different binary code format and a
significantly reduced (6805) resp. enhanced (6809) instruction set. 
The 6309 is a CMOS version of the 6809 which is officially only
compatible to the 6809, but inofficially offers more registers and a
lot of new instructions (see [Kaku]).

f) 68HC12

g) 68HC16

h) HD6413308 --> HD6413309

These both names represent the 300 and 300H variants of the H8
family; the H version owns a larger address space (16Mbytes instead
of 64Kbytes), double-width registers (32 bits), and knows a few more
instructions and addressing modes.  It is still binary upward
compatible.

i) HD6475328 --> HD6475348 --> HD6475368 --> HD6475388

These processors all share the same CPU core; the different types are
only needed to include the correct subset of registers in the file
REG53X.INC.

j) SH7000 --> SH7600

The processor core of the 7600 offers a few more instructions that
close gaps in the 7000's instruction set (delayed conditional and
relative and indirect jumps, multiplications with 32-bit operands and
multiply/add instructions).

k) 6502 --> 65(S)C02 / MELPS740

The CMOS version defines some additional instructions, as well as a
number of some instruction/addressing mode combinations were added
which were not possible on the 6502.  The Mitsubishi micro
controllers in opposite expand the 6502 instruction set primarily to
bit operations and multiplication / division instructions.  Except
for the unconditional jump and instructions to increment/decrement
the accumulator, the instruction extensions are orthogonal.  The
65SC02 lacks the bit manipulation instructions of the 65C02.

l) MELPS7700, 65816

Apart from a '16-bit-version' of the 6502's instruction set, these
processors both offer some instruction set extensions.  These are
however orthogonal as they are oriented along their 8-bit
predecessors (65C02 resp. MELPS-740).  Partially, different
mnemonics are used for the same operations.

m) MELPS4500

n) M16

o) M16C

p) 8021, 8022, 8039, 80C39, 8048, 80C48, 8041, 8042

For the ROM-less versions 8039 and 80C39, the commands which are
using the BUS (port 0) are forbidden.  The 8021 and 8022 are special
versions with a strongly shrinked instruction set, for which the 8022
has two A/D- converters and the necessary control-commands.  It is
possible to transfer the CMOS-versions with the IDL-command into a
stop mode with lower current consumption.  The 8041 and 8042 have
some additional instructions for controlling the bus interface, but
in turn a few other commands were omitted.  Moreover, the code
address space of these processors is not externally extendable,
and so AS limits the code segment of these processors to 1 resp. 2
Kbytes.

q) 87C750 --> 8051, 8052, 80C320, 80C501, 80C502, 80C504, 80515, and
   80517--> 80C251

The 87C750 can only access a maximum of 2 Kbytes program memory which
is why it lacks the LCALL and LJMP instructions.  AS does not make
any distinction among the processors in the middle, instead it only
stores the different names in the MOMCPU variable (see below), which
allows to query the setting with IF instructions.  An exception is
the 80C504 that has a mask flaw in its current versions.  This flaw
shows up when an AJMP or ACALL instruction starts at the second last
address of a 2K page.  AS will automatically use long instructions or
issues an error message in such situations.  The 80C251 in contrast
represents a drastic progress in the the direction 16/32 bits, larger
address spaces, and a more orthogonal instruction set.

r) 8096 --> 80196 --> 80196N --> 80296

Apart from a different set of SFRs (which however strongly vary from
version to version), the 80196 knows several new instructions and
supports a 'windowing' mechanism to access the larger internal RAM. 
The 80196N family extends the address space to 16 Mbytes and
introduces a set of instructions to access addresses beyond 64Kbytes. 
The 80296 extends the CPU core by instructions for signal processing
and a second windowing register, however removes the Peripheral
Transaction Server (PTS) and therefore looses again two machine
instructions.

s) 8080 and 8085

The 8085 knows the additional commands RIM and SIM for controlling the 
interrupt mask and the two I/O-pins.

t) 8086 --> 80186 --> V30 --> V35

Only new instructions are added in this family.  The corresponding
8-bit versions are not mentioned due to their instruction
compatibility, so one e.g. has to choose 8086 for an 8088-based
system.

u) 8X300 --> 8X305

The 8X305 features a couple of additional registers that miss on the
8X300.  Additionally, it can do new operations with these registers
(like direct writing of 8 bit values to peripheral addresses).

v) XAG1, XAG2, XAG3

These processors only differ in the size of their internal ROM which
is defined in STDDEFXA.INC.

w) AT90S1200 --> AT90S2313 --> AT90S4414--> AT90S8515

The first member of the AVR series represents a minimum configuration
without RAM memory and therefore lacks load/store instructions.  The
other two processors only differ in their memory equipment and
on-chip peripherals, what is differentiated in REGAVR.INC.

x) AM29245 --> AM29243 --> AM29240 --> AM29000

The further one moves to the right in this list, the fewer the
instructions become that have to be emulated in software.  While e.g.
the 29245 not even owns a hardware multiplier, the two representors in
the middle only lack the floating point instructions.  The 29000
serves as a 'generic' type that understands all instructions in
hardware.

y) 80C166 --> 80C167,80C165,80C163

80C167 and 80C165/163 have an address space of 16 Mbytes instead of
256 Kbytes, and furthermore they know some additional instructions
for extended addressing modes and atomic instruction sequences.  They
are 'second generation' processors and differ from each other only in
the amount of on-chip peripherals.

z) Z80 --> Z80UNDOC --> Z180 --> Z380

While there are only a few additional instructions for the Z180, the
Z380 owns 32-bit registers, a linear address space of 4 Gbytes, a
couple of instruction set extensions that make the overall
instruction set considerably more orthogonal, and new addressing
modes (referring to index register halves, stack relative).  These
extensions partially already exist on the Z80 as undocumented
extensions and may be switched on via the Z80UNDOC variant.  A list
with the additional instructions can be found in the chapter
with processor specific hints.

aa) Z8601, Z8604, Z8608, Z8630, Z8631

These processors again only differ in internal memory size and
on-chip peripherals, i.e. the choice does not have an effect on the
supported instruction set.

ab) 96C141, 93C141

These two processors represent the two variations of the processor 
family: TLCS-900 and TLCS-900L.  The differences of these two variations 
will be discussed in detail in section 4.6 .

ac) 90C141

ad) 87C00, 87C20, 87C40, 87C70

The processors of the TLCS-870 series have an identical CPU core, but
different peripherals depending on the type.  In part registers with
the same name are located at different addresses.  The file
STDDEF87.INC uses, similar to the MCS-51-family, the distinction possible
by different types to provide the correct symbol set automatically.

ae) 47C00 --> 470C00 --> 470AC00

These three variations of the TLCS-47-family have on-chip RAM and ROM
of different size, which leads to several bank switching instructions 
being added or suppressed.

af) 97C241

ag) 16C54 --> 16C55 --> 16C56 --> 16C57

These processors differ by the available code area, i.e. by 
the address limit after which AS reports overruns.

ah) 16C84, 16C64

Analog to the MCS-51 family, no distinction is made in the code
generator, the different numbers only serve to include the correct
SFRs in STDDEF18.INC.

ai) 17C42

aj) ST6210/ST6215-->ST6220/ST6225

The only distinction AS makes between the two pairs is the smaller
addressing space (2K instead 4K) of the first ones.  The detailed
distinction serves to provide an automatic distinction in the source
file which hardware is available (analog to the 8051/52/515).

ak) ST7

al) ST9020, ST9030, ST9040, ST9050

These 4 names represent the four "sub-families" of the ST9 family,
which only differ in their on-chip peripherals.  Their processor
cores are identical, which is why this distinction is again only used
in the include file containing the peripheral addresses.

am) 6804

an) 32010-->32015

The TMS32010 owns just 144 bytes of internal RAM, and so AS limits
addresses in the data segment just up to this amount.  This restriction
does not apply for the 32015, the full range from 0..255 can be used.

ao) 320C25 --> 320C26 --> 320C28

These processors only differ slightly in their on-chip peripherals
and in their configuration instructions.

ap) 320C30, 320C31

The 320C31 is a reduced version with the same instruction set,
however fewer peripherals.  The distinction is exploited in
STDDEF3X.INC.

aq) 320C50, 320C51, 320C53

The distinction between these processors is currently not used by AS.

ar) TMS9900

as) TMS70C00, TMS70C20, TMS70C40,
    TMS70CT20, TMS70CT40,
    TMS70C02, TMS70C42, TMS70C82,
    TMS70C08, TMS70C48

All members of this family share the same CPU core, they therefore do
not differ in their instruction set.  The differences manifest only
in the file REG7000.INC where address ranges and peripheral addresses
are defined.  Types listed in the same row have the same amount of
internal RAM and the same on-chip peripherals, they differ only in
the amount of integrated ROM.

at) 370C010, 370C020, 370C030, 370C040 and 370C050

Similar to the MCS-51 family, the different types are only used to
differentiate the peripheral equipment in STDDEF37.INC; the
instruction set is always the same.

au) MSP430

av) SC/MP

aw) COP87L84

This is the only member of National Semiconductor's COP8 family that
is currently supported.  I know that the family is substantially
larger and that there are representors with differently large
instruction sets which will be added when a need occurs.  It is a
beginning, and National's documentation is quite extensive... 

ax) 7810-->78C10

The NMOS version has no stop-mode; the respective command and the ZCM
register are omitted.  CAUTION!  NMOS and CMOS version partially
differ in the reset values of some registers!

ay) 75402,
    75004, 75006, 75008,
    75268,
    75304, 75306, 75308, 75312, 75316,
    75328,
    75104, 75106, 75108, 75112, 75116,
    75206, 75208, 75212, 75216,
    75512, 75516

This 'cornucopia' of processors differs only by the RAM size in one
group; the groups themselves again differ by their on-chip
peripherals on the one hand and by their instruction set's power on
the other hand.

az) 78070

This is currently the only member of NEC's 78K0 family I am familiar
with.  Similar remarks like for the COP8 family apply!

The CPU instruction needs the processor type as a simple constant, a
calculation like:

       CPU     68010+10

is not allowed.  Valid calls are e.g.

       CPU  8051

or

       CPU 6800

Regardless of the processor type currently set, the integer variable
MOMCPU contains the current status as a hexadecimal number.  For
example, MOMCPU=$68010 for the 68010 or MOMCPU=80C48H for the 80C48. 
As one cannot express all letters as hexadecimal digits (only A..F
are possible), all other letters must must be omitted in the hex
notation; for example, MOMCPU=80H for the Z80.

You can take advantage of this feature to generate different code
depending on the processor type.  For example, the 68000 does not
have a machine instruction for a subroutine return with stack
correction.  With the variable MOMCPU you can define a macro that
uses the machine instruction or emulates it depending on the
processor type:

myrtd  macro   disp
       if      MOMCPU<$68010   ; emulate for 68008 & 68000 
        move.l (sp),disp(sp)   
        lea    disp(sp),sp     
        rts                    
       elseif                  
        rtd    #disp           ; direct use on >=68010 
       endif
       endm


       cpu     68010
       myrtd   12              ; results in RTD #12

       cpu     68000
       myrtd   12              ; results in MOVE.. / LEA.. / RTS

As not all processor names are built only out of numbers and letters
from A..F, the full name is additionally stored in the string
variable named MOMCPUNAME.

The assembler implicitly switches back to the CODE segment when a CPU
instruction is executed.  This is done because CODE is the only
segment all processors support.

The default processor type is 68008.


        3.2.3. SUPMODE, FPU, PMMU
        - - - - - - - - - - - - -

--> valid for: 680x0, FPU also for 8086..V35, SUPMODE also for TLCS-900,
               SH7000, 29K, XA and PowerPC

These three switches allow to define which parts of the instruction
set shall be disabled because the necessary preconditions are not
valid for the following piece of code.  The parameter for these
commands may be either ON or OFF, the current status can be read out
of a variable which is either TRUE or FALSE.

The commands have the following meanings in detail:

SUPMODE: allows or prohibits commands, for whose execution the 
         processor has to be within the supervisor mode.  The status 
         variable is called INSUPMODE.

FPU    : allows or prohibits the commands of the numerical
         coprocessors 8087 resp. 68881 or 68882.  The status variable
         is called FPUAVAIL.

PMMU   : allows or prohibits the commands of the memory management unit 
         68851 resp. of  the built-in MMU of the 68030.  CAUTION! The 
         68030-MMU supports only a relatively small subset of the 68851
         instructions.  The assembler cannot test this!  The status
         variable is called PMMUAVAIL.

The usage of of instructions prohibited in this manner will generate a
warning at SUPMODE, at PMMU and FPU a real error message.


        3.2.4. FULLPMMU
        - - - - - - - -

--> valid for: 680x0

Motorola integrated the MMU into the processor starting with the
68030, but the built-in FPU is equipped only with a relatively small
subset of the 68851 instruction set.  AS will therefore disable all
extended MMU instructions when the target processor is 68030 or
higher.  It is however possible that the internal MMU has been
disabled in a 68030-based system and the processor operates with an
external 68851.  One can the use a FULLPMMU ON to tell AS that the
complete MMU instruction set is allowed.  Vice versa, one may use a
FULLPMMU OFF to disable all additional instruction in spite of a
68020 target platform to assure that portable code is written.  The
switch between full and reduced instruction set may be done as often
as needed, and the current setting may be read from a symbol with the
same name.  CAUTION!  The CPU instruction implicitly sets or resets
this switch when its argument is a 68xxx processor!  FULLPMMU
therefore has to be written after the CPU instruction!


        3.2.5.  PADDING
        - - - - - - - -

--> valid for: 680x0, XA, H8, SH7000, MSP430, TMS9900, ST7

Processors of the 680x0 family are quite critical regarding odd
addresses: instructions must not start on an odd address, and data
accesses to odd addresses are only allowed bytewise up to the 68010. 
The H8/300 family simply resets the lowest address bit to zero when
accessing odd addresses, the 500 in contrast 'thanks' with an
exception...  AS therefore tries to round up data structures built
with DC or DS to an even number of bytes.  This however means for
DC.B and DS.B that a padding byte may have to be added.  This
behaviour can be turned on and off via the PADDING instruction. 
Similar to the previous instructions, the argument may be either ON
or OFF, and the current setting may be read from a symbol with the
same name.


        3.2.6.  MAXMODE
        - - - - - - - -

--> valid for: TLCS-900, H8

The processors of the TLCS-900-family are able to work in 2 modes,
the minimum and maximum mode.  Depending on the actual mode, the
execution environment and the assembler are a little bit different.
Along with this instruction and the parameter ON or OFF, AS is informed
that the following code will run in maximum resp. minimum mode.  The
actual setting can be read from the variable INMAXMODE.  Presetting
is OFF, i.e. minimum mode.

Similarly, one uses this instruction to tell AS in H8 mode whether
the address space is 64K or 16 Mbytes.  This setting is always OFF for
the 'small' 300 version and cannot be changed.

        3.2.7.  EXTMODE and LWORDMODE
        - - - - - - - - - - - - - - -

--> valid for: Z380

The Z380 may operate in altogether 4 modes, which are the result of
setting two flags: The XM flag rules whether the processor shall
operate wit an address space of 64 Kbytes or 4 Gbytes and it may only
be set to 1 (after a reset, it is set to 0 for compatibility with the
Z80).  The LW flag in turn rules whether word operations shall work
with a word size of 16 or 32 bits.  The setting of these two flags
influences range checks of constants and addresses, which is why one
has to tell AS the setting of these two flags via these instructions. 
The default assumption is that both flags are 0, the current setting
(ON or OFF) may be read from the predefined symbols INEXTMODE resp.
INLWORDMODE.


        3.2.8.  SRCMODE 
        - - - - - - - - 

--> valid for: MCS-251

Intel substantially extended the 8051 instruction set with the
80C251, but unfortunately there was only a single free opcode for all
these new instructions.  To avoid a processor that will be eternally
crippled by a prefix, Intel provided two operating modes: the binary
and the source mode.  The new processor is fully binary compatible to
the 8051 in binary mode, all new instructions require the free opcode
as prefix.  In source mode, the new instructions exchange their
places in the code tables with the corresponding 8051 instructions,
which in turn then need a prefix.  One has to inform AS whether the
processor operates in source mode (ON) or binary mode (OFF) to enable
AS to add prefixes when required.  The current setting may be read
from the variable INSRCMODE.  The default is OFF.


        3.2.9.  BIGENDIAN
        - - - - - - - - -

--> valid for: MCS-51/251, PowerPC

Intel broke with its own principles when the 8051 series was
designed: in contrast to all traditions, the processor uses
big-endian ordering for all multi-byte values!  While this was not a
big deal for MCS-51 processors (the processor could access memory
only in 8-bit portions, so everyone was free to use whichever
endianess one wanted), it may be a problem for the 251 as it can
fetch whole (long-)words from memory and expects the MSB to be first. 
As this is not the way of constant disposal earlier versions of AS
used, one can use this instruction to toggle between big and
little endian mode for the instructions DB, DW, DD, DQ, and DT. 
BIGENDIAN OFF (the default) puts the LSB first into memory as it used
to be on earlier versions of AS, BIGENDIAN ON engages the big-endian
mode compatible to the MCS-251.  One may of course change this
setting as often as one wants; the current setting can be read from
the symbol with the same name. 


        3.2.10. SEGMENT
        - - - - - - - -

--> valid for: all processors

Some microcontrollers and signal processors know various address
ranges, which do not overlap with each other and require also
different instructions and addressing modes for access.  To manage
these ones also, the assembler provides various program counters, you
can switch among them to and from by the use of the SEGMENT
instruction.  For subroutines included with INCLUDE, this e.g. allows
to define data used by the main program or subroutines near to the
place they are used.  In detail, the following segments with the
following names are supported:

CODE    : program code;
DATA    : directly addressable data (including SFRs); 
XDATA   : data in externally connected RAM or 
          X-addressing space of the DSP56000;
YDATA   : Y-addressing space of the DSP56000;
IDATA   : indirectly addressable (internal) data; 
BITDATA : the part of the 8051-internal RAM that is bitwise 
          addressable;
IO      : I/O-address range;
REG     : register bank of the ST9.

See also section 3.2.1. (ORG) for detailed information about address 
ranges and initial values of the segments. Depending on the processor 
family, not all segment types will be permitted.

The bit segment is managed as if it would be a byte segment, i.e. the
addresses will be incremented by 1 per bit.

Labels get the same type as attribute as the segment that was active
when the label was defined.  So the assembler has a limited ability
to check whether you access symbols of a certain segment with wrong
instructions.  In such cases the assembler issues a warning.

Example:

       CPU     8051            ; MCS-51-code

       segment code            ; test code

       setb flag               ; no warning
       setb var                ; warning : wrong segment

segment data

var    db ?

       segment bitdata

flag   db ?



        3.2.11. PHASE and DEPHASE
        - - - - - - - - - - - - -

--> valid for: all processors

For some applications (especially on Z80 systems), the code must be
moved to another address range before execution.  If the assembler
didn't know about this, it would align all labels to the load
address (not the start address).  The programmer is then forced to
write jumps within this area either independent of location or has to
add the offset at each symbol manually.  The first one is not
possible for some processors, the last one is extremely error-prone. 
With the commands PHASE and DEPHASE, it is possible to inform the
assembler at which address the code will really be executed on the
target system:

       phase   <address>

informs the assembler that the following code shall be executed at the 
specified address.  The assembler calculates thereupon the difference to 
the real program counter and adds this difference for the following 
operations:

 - address values in the listing
 - filing of label values
 - program counter references in relative jumps and address expressions
 - readout of the program counter via the symbols * or $

this "shifting" is switched off by the instruction

        dephase

The assembler manages phase values for all defined segments, although 
this instruction pair only makes real sense in the code segment.  


        3.2.12.  SAVE and RESTORE
        - - - - - - - - - - - - -

--> valid for: all processors

The command SAVE forces the assembler to push the contents of following 
variables onto an internal stack:

 - currently selected processor type (set by CPU); 
 - currently active memory area (set by SEGMENT);
 - the flag whether listing is switched on or off (set by LISTING);
 - the flag whether expansions of following macros shall be issued in
   the assembly listing (set by MACEXP).

The counterpart RESTORE pops the values saved last from this stack. 
These two commands were primarily designed for include files, to
change the above mentioned variables in any way inside of these
files, without loosing their original content.  This may be helpful
e.g. in include files with own, fully debugged subroutines, to switch
the listing generation off:

       SAVE            ; save old status 

       LISTING  OFF    ; save paper 

       .               ; the actual code
       .

       RESTORE         ; restore

In opposite to a simple LISTING OFF .. ON-pair, the correct status
will be restored, in case the listing generation was switched off
already before.

The assembler checks if the number of SAVE-and RESTORE-commands 
corresponds and issues error messages in the following cases:

 - RESTORE, but the internal stack is empty;
 - the stack not empty at the end of a pass.


        3.2.13.  ASSUME
        - - - - - - - -

--> valid for: various

This instruction allows to tell AS the current setting of certain
registers whose contents cannot be described with a simple ON or OFF. 
These are typically registers that influence addressing modes and
whose contents are important to know for AS in order to generate
correct addressing.  It is important to note that ASSUME only informs
AS about these, NO machine code is generated that actually loads
these values into the appropriate registers!

        6809
        ....

In contrast to its 'predecessors' like the 6800 and 6502, the position
of the direct page, i.e. the page of memory that can be reached with
single-byte addresses, can be set freely.  This is done via the
'direct page register' that sets the page number.  One has to assign
a corresponding value to this register via ASSUME is the contents are
different from the default of 0, otherwise wrong addresses will be
generated! 

        68HC16
        ......

The 68HC16 employs a set of bank registers to address a space of 1
Mbyte with its registers that are only 16 bits wide.  These registers
supply the upper 4 bits.  Of these, the EK register is responsible
for absolute data accesses (not jumps!).  AS checks for each absolute
address whether the upper 4 bits of the address are equal to the
value of EK specified via ASSUME.  AS issues a warning if they
differ.  The default for EK is 0.

        H8/500
        ......

In maximum mode, the extended address space of these processors is
addressed via a couple of bank registers.  They carry the names DP
(registers from 0..3, absolute addresses), EP (register 4 and 5), and
TP (stack).  AS needs the current value of DP to check if absolute
addresses are within the currently addressable bank; the other two
registers are only used for indirect addressing and can therefore not
be monitored; it is a question of personal taste whether one
specifies their values or not.  The BR register is in contrast
important because it rules which 256-byte page may be accessed with
short addresses.  It is common for all registers that AS does not
assume ANY default value for them as they are undefined after a CPU
reset.  Everyone who wants to use absolute addresses must therefore
assign values to at least DR and DP!

        MELPS740
        ........

Microcontrollers of this series know a "special page" addressing mode
for the JSR instruction that allows a shorter coding for jumps into
the last page of on-chip ROM.  The size of this ROM depends of course
on the exact processor type, and there are more derivatives than it
would be meaningful to offer via the CPU instruction...we therefore
have to rely on ASSUME to define the address of this page, e.g.

        ASSUME SP:$1f

in case the internal ROM is 8K.

        MELPS7700/65816
        ...............

These processors contain a lot of registers whose contents AS has to know
in order to generate correct machine code.  These are the registers
in question:

name   function             value range   default

DT     data bank            0-$ff           0
PG     code Bank            0-$ff           0
DPR    directly addr. page  0-$ffff         0
X      index register width 0 or 1          0
M      accumulator width    0 or 1          0

To avoid endless repetitions, see section 4.8. for instructions how
to use these registers.  The handling is otherwise similar to the
8086, i.e. multiple values may be set with one instruction and no
code is generated that actually loads the registers with the given
values.  This is again up to the programmer!

        MCS-196/296
        ...........

Starting with the 80196, all processors of the MCS-96 family have a
register 'WSR' that allows to map memory areas from the extended
internal RAM or the SFR range into areas of the register file which
may then be accessed with short addresses.  If one informs AS about
the value of the WSR register, it can automatically find out whether
an absolute address can be addressed with a single-byte address via
windowing; consequently, long addresses will be automatically
generated for registers covered by windowing.  The 80296 contains an
additional register WSR1 to allow simultaneous mapping of two memory
areas into the register file.  In case it is possible to address a
memory cell via both areas, AS will always choose the way via WSR!

        8086
        ....

The 8086 is able to address data from all segments in all
instructions, but it however needs so-called "segment prefixes" if
another segment register than DS shall be used.  In addition it is
possible that the DS register is adjusted to another segment, e.g. to
address data in the code segment for longer parts of the program.  As
AS cannot analyze the code's meaning, it has to informed via this
instruction to what segments the segment registers point at the
moment, e.g.:

       ASSUME  CS:CODE, DS:DATA    .

It is possible to assign assumptions to all four segment registers in
this way .  This instruction produces NO code, so the program itself
has to do the actual load of the registers with the values. 

The usage of this instruction has on the one hand the result that AS is able to
automatically put ahead prefixes at sporadic accesses into the code segment, or on 
the other hand, one can inform AS that the DS-register was modified and 
you can save explicit CS:-instructions.

Valid arguments behind the colon are CODE, DATA and NOTHING.  The
latter value informs AS that a segment register contains no usable
value (for AS).  The following values are preinitialized:

CS:CODE, DS:DATA, ES:NOTHING, SS:NOTHING

        XA
        ..

The XA family has a data address space of 16 Mbytes, a process however
can always address within a 64K segment only that is given by the DS
register.  One has to inform AS about the current value of this
register in order to enable it to check accesses to absolute
addresses.

        29K
        ...

The processors of the 29K family feature a register RBP that allows
to protect banks of 16 registers against access from user mode.  The
corresponding bit has to be set to achieve the protection.  ASSUME
allows to tell AS which value RBP currently contains.  AS can warn
this way in case a try to access protected registers from user mode
is made.

        80C166/167
        ..........

Though none of the 80C166/167's registers is longer than 16 bits,
this processor has 18/24 address lines and can therefore address up
to 256Kbytes/16Mbytes.  To resolve this contradiction, it neither
uses the well-known (and ill-famed) Intel method of segmentation nor
does it have inflexible bank registers...no, it uses paging!  To
accomplish this, the logical address space of 64 Kbytes is split into
4 pages of 16 Kbytes, and for each page there is a page register
(named DPP0..DPP3) that rules which of the 16/1024 physical pages
shall be mapped to this logical page.  AS always tries to present the
address space with a size of 256Kbytes/16MBytes in the sight of the
programmer, i.e. the physical page is taken for absolute accesses and
the setting of bits 14/15 of the logical address is deduced.  If no
page register fits, a warning is issued.  AS assumes by default that
the four registers linearly map the first 64 Kbytes of memory, in the
following style:

        ASSUME  DPP0:0,DPP1:1,DPP2:2,DPP3:3

The 80C167 knows some additional instructions that can override the
page registers' function.  The chapter with processor-specific hints
describes how these instructions influence the address generation.

        TLCS-47
        .......

The direct data address space of these processors (it makes no
difference whether you address directly or via the HL register) has a
size of only 256 nibbles.  Because the "better" family members have
up to 1024 nibbles of RAM on chip, Toshiba was forced to introduce a
banking mechanism via the DMB register.  AS manages the data segment
as a continuous addressing space and checks at any direct addressing
if the address is in the currently active bank.  The bank AS
currently expects can be set by means of

   ASSUME  DMB:<0..3>

The default value is 0.

        ST62xx
        ......

The microcontrollers of the ST62 family are able to map a part (64
bytes) of the code area into the data area, e.g. to load constants
from the ROM.  This means also that at one moment only one part of
the ROM can be addressed.  A special register rules which part it is. 
AS cannot check the contents of this register directly, but it can be
informed by this instruction that a new value has been assigned to
the register.  AS then can test and warn if necessary, in case
addresses of the code segment are accessed, which are not located in
the "announced" window.  If, for example, the variable VARI has the
value 456h, so

ASSUME ROMBASE:VARI>>6

sets the AS-internal variable to 11h, and an access to VARI generates
an access to address 56h in the data segment.

It is possible to assign a simple NOTHING instead of a value, e.g. if
the bank register is used temporarily as a memory cell.  This value
is also the default.

        ST9
        ...

The ST9 family uses exactly the same instructions to address code and
data area.  It depends on the setting of the flag register's DP flag
which address space is referenced.  To enable AS to check if one
works with symbols from the correct address space (this of course
ONLY works with absolute accesses!), one has to inform AS whether the
DP flag is currently 0 (code) or 1 (data).  The initial value of this
assumption is 0.

        320C3x
        ......

As all instructions word of this processor family are only 32 bits
long (of which only 16 bits were reserved for absolute addresses),
the missing upper 8 bits have to be added from the DP register.  It
is however still possible to specify a full 24-bit address when
addressing, AS will check then whether the upper 8 bits are equal to
the DP register's assumed values.  ASSUME is different to the LDP
instruction in the sense that one cannot specify an arbitrary address
out of the bank in question, one has to extract the upper bits by
hand:

        ldp     @addr
        assume  dp:addr>>16
        .
        .
        ldi     @addr,r2

        µPD78(C)10
        ..........

These processors have a register (V) that allows to move the "zero
page", i.e. page of memory that is addressable by just one byte,
freely in the address space, within page limits.  By reasons of
comforts you don't want to work with expressions such as

inrw    Lo(counter)

so AS takes over this job, but only under the premise that it is
informed via the ASSUME-command about the contents of the V register. 
If an instruction with short addressing is used, it will be checked
if the upper half of the address expression corresponds to the
expected content.  A warning will be issued if both do not match.

        75K0
        ....

As the whole address space of 12 bits could not be addressed even by
the help of register pairs (8 bits), NEC had to introduce banking
(like many others too...): the upper 4 address bits are fetched from
the MBS register (which can be assigned values from 0 to 15 by the
ASSUME instruction), which however will only be regarded if the MBE
flag has been set to 1.  If it is 0 (default), the lowest and highest
128 nibbles of the address space can be reached without banking.  The
ASSUME instruction is undefined for the 75402 as it contains neither
a MBE flag nor an MBS register; the initial values cannot be changed
therefore.


        3.2.14.  EMULATED
        - - - - - - - - -

--> valid for: 29K

AMD defined the 29000's series exception handling for undefined
instructions in a way that there is a separate exception vector for
each instruction.  This allows to extend the instruction set of a
smaller member of this family by a software emulation.  To avoid that
AS quarrels about these instructions as being undefined, the EMULATED
instruction allows to tell AS that certain instructions are allowed
in this case.  The check if the currently set processors knows the
instruction is then skipped.  For example, if one has written a
module that supports 32-bit IEEE numbers and the processor does not
have a FPU, one writes

        EMULATED FADD,FSUB,FMUL,FDIV
        EMULATED FEQ,FGE,FGT,SQRT,CLASS


        3.3. Data Definitions
        ---------------------

The instructions described in this section partially overlap in their
functionality, but each processor family defines other names for the
same function.  To stay compatible with the standard assemblers, this
way of implementation was chosen.


        3.3.1.  DC[.Size]
        - - - - - - - - -

--> valid for: 680x0, H8, SH7x00, DSP56000, XA, ST7
  
This instruction places one or several constants of the type
specified by the attribute into memory.  The attributes are the same
ones as defined in section 2.2, and there is additionally the
possibility for byte constants to place string constants in memory,
like

String  dc.B "Hello world!\0"

The parameter count may be between 1 and 20.  A repeat count enclosed
in brackets may additionally be prefixed to each parameter; for
example, one can for example fill the area up to the next page
boundary with zeroes with a statement like

                dc.b    [(*+255)&$ffffff00-*]0

CAUTION!  This function easily allows to reach the limit of 1 Kbyte
of generated code per line!

The assembler automatically adds another byte of data in case the
byte sum should become odd, to keep the word alignment.  This
behaviour may be turned on and off via the PADDING instruction.

Decimal floating point numbers stored with this instruction (DC.P...)
can cover the whole range of extended precision, one however has to
pay attention to the detail that the coprocessors currently available
from Motorola (68881/68882) ignore the thousands digit of the
exponent at the read of such constants!

The default attribute is W, that means 16-bit-integer numbers.

For the DSP56000, the data type is fixed to integer numbers (an attribute is 
therefore neither necessary nor allowed), which may be in the range
of -8M..16M-1.  String constants are also allowed, whereby three characters 
are packed into each word.


        3.3.2.  DS[.Size]
        - - - - - - - - -

--> valid for: 680x0, H8, SH7x00, DSP56000, XA,, ST7

On the one hand, this instruction enables to reserve memory space for
the specified count of numbers of the type given by the attribute. 
Therefore, 

        DS.B    20

for example reserves 20 bytes of memory, but

        DS.X    20

reserves 240 bytes!

The other purpose is the alignment of the program counter which is
achieved by a count specification of 0.  In this way, with a

        DS.W    0  ,

the program counter will be rounded up to the next even address, with
a

DS.D 0

in contrast to the next double word boundary.  Memory cells possibly
staying unused thereby are neither zeroed nor filled with NOPs, they
simply stay undefined. 

The default for the operand length is - as usual - W, i.e. 16 bits.

For the 56000, the operand length is fixed to words (of 24 bit),
attributes therefore do not exist just as in the case of DC.


        3.3.3. DB,DW,DD,DQ and DT
        - - - - - - - - - - - - -

--> valid for: Intel, Zilog, Toshiba, NEC, TMS370, Siemens, AMD,
               MELPS7700/65816, M16(C), National, ST9, TMS70Cxx

These commands are - one could say - the Intel counterpart to DS and
DC, and as expected, their logic is a little bit different: First, the 
specification of the operand length is moved into the mnemonic:

 DB: byte or ASCII string similar to DC.B
 DW: 16-bit integer
 DD: 32-bit integer or single precision
 DQ: double precision   (64 bits)
 DT: extended precision (80 bits)

Second, the distinction between constant definition and memory
reservation is done by the operand.  A reservation of memory is
marked by a '?' :

        db      ?       ; reserves a byte
        dw      ?,?     ; reserves memory for 2 words (=4 byte)
        dd      -1      ; places the constant -1 (FFFFFFFFH) !

Reserved memory and constant definition MUST NOT be mixed within one
instruction:

        db      "hello",?       ; --> error message

Additionally, the DUP Operator permits the repeated placing of
constant sequences or the reservation of whole memory blocks:

        db      3 dup (1,2)     ; --> 1 2 1 2 1 2
        dw      20 dup (?)      ; reserves 40 bytes of memory

As you can see, the DUP-argument must be enclosed in parentheses,
which is also why it may consist of several components, that may
themselves be DUPs...the stuff therefore works recursively.  DUP is
however also a place where one can get in touch with another limit of
the assembler: a maximum of 1024 bytes of code or data may be
generated in one line.  This is not valid for the reservation of
memory, only for the definition of constant arrays! 

In order to be compatible to the M80, DEFB/DEFW may be used instead of
DB/DW in Z80-mode.

Similarly, BYTE/ADDR resp. WORD/ADDRW in COP8 mode are an alias for DB
resp. DW, with the pairs differing in byte order: instructions
defined by National for address storage use big endian, BYTE resp.
WORD in contrast use little endian.


        3.3.4. DS
        - - - - -

--> valid for: Intel, Zilog, Toshiba, NEC, TMS370, Siemens, AMD,
               M16(C), National, ST9, TMS7000

With this instruction, you can reserve a memory area:

	DS	<count>

It is an abbreviation of

	DB	<count> DUP (?)

Although this could easily be made by a macro, some people grown up
with Motorola CPUs (Hi Michael!) suggest DS to be a built-in
instruction...I hope they are satisfied now ;-)


        3.3.5. BYT or FCB
        - - - - - - - - -

--> valid for: 6502, 68xx

By this instruction, byte constants or ASCII strings are placed in
65xx/68xx-mode, it therefore corresponds to DC.B on the 68000 or DB
on Intel.


        3.3.6. BYTE
        - - - - - -

--> valid for: ST62xx, 320C2x, 320C5x, MSP, TMS9900

Ditto.  Note that when in 320C2x/5x mode, the assembler assumes that
a label on the left side of this instruction has no type, i.e. it
belongs to no address space. This behaviour is explained in the
processor-specific hints.

The PADDING instruction allows to set whether odd counts of bytes
shall be padded with a zero byte in MSP/TMS9900 mode.


        3.3.7. ADR or FDB
        - - - - - - - - -

--> valid for: 6502, 68xx

ADR resp. FDB stores word constants when in 65xx/68xx mode.  It is
therefore the equivalent to DC.W on the 68000 or DW on Intel
platforms.


        3.3.8. WORD
        - - - - - -

--> valid for: ST62xx, 320C2x, 320C3x, 320C5x, MSP

If assembling for the 320C3x, this command stores 32-bit words,
16-bit words for the other families.  Note that when in 320C2x/5x
mode, the assembler assumes that a label on the left side of this
instruction has no type, i.e. it belongs to no address space.  This
behaviour is explained at the discussion on processor-specific hints.


        3.3.9. LONG
        - - - - - -

--> valid for: 320C2x, 320C5x

LONG stores a 32-bit integer to memory with the order LoWord-HiWord. 
Note that when in 320C2x/5x mode, the assembler assumes that a label
on the left side of this instruction has no type, i.e. it belongs to
no address space. This behaviour is explained in the
processor-specific hints.


        3.3.10. SINGLE and EXTENDED
        - - - - - - - - - - - - - -

--> valid for: 320C3x

Both commands store floating-point constants to memory.  They are NOT
in IEEE-format.  Instead the processor-specific formats with 32 and
40 bit are used.  In case of EXTENDED the resulting constant occupies
two memory words.  The most significant 8 bits (the exponent) are
written to the first word while the other ones (the mantissa) are copied
into the second word.


        3.3.11.  FLOAT and DOUBLE
        - - - - - - - - - - - - -

--> valid for: 320C2x, 320C5x

These two commands store floating-point constants in memory using the
standard IEEE 32-bit and 64-bit IEEE formats.  The least significant
byte is copied to the first allocated memory location.  Note that
when in 320C2x/5x mode the assembler assumes that all labels on the
left side of an instruction have no type, i.e. they belong to no
address space.  This behaviour is explained in the processor-specific
hints.


        3.3.12. EFLOAT, BFLOAT and TFLOAT
        - - - - - - - - - - - - - - - - -

--> valid for: 320C2x, 320C5x

Another three floating point commands.  All of them support non-IEEE
formats, which should be easily applicable on signal processors:

		| mantissa	| exponent
	-------------------------------------------
	EFLOAT	| 16		| 16
	BFLOAT	| 32		| 16
	DFLOAT	| 64		| 32

The three commands share a common storage strategy.  In all cases the
mantissa precedes the exponent in memory, both are stored as 2's
complement with the least significant byte first.  Note that when in
320C2x/5x mode the assembler assumes that all labels on the left side
of an instruction have no type, i.e.  they belong to no address
space. This behaviour is explained in the processor-specific hints.


        3.3.13.  Qxx and LQxx
        - - - - - - - - - - -

--> valid for: 320C2x, 320C5x

Qxx and LQxx can be used to generate constants in a fixed point
format. xx denotes a 2-digit number.  The operand is first multiplied
by 2^xx before converting it to binary notation.  Thus xx can be
viewed as the number of bits which should be reserved for the
fractional part of the constant in fixed point format.  Qxx stores
only one word (16 bit) while LQxx stores two words (low word first):

	q05	2.5		; --> 0050h
	lq20	ConstPI		; --> 43F7h 0032h

Please do not flame me in case I calculated something wrong on my
HP28...


        3.3.14.  DATA
        - - - - - - -

--> valid for: PIC, 320xx, AVR, MELPS-4500

This command stores data in the current segment.  Both integer values
as well as character strings are supported.  On 16C5x/16C8x, 17C4x in
data segment and on the 4500, characters occupy one word.  On AVR,
17C4x in code segment, and on 3201x/3202x, in general two characters
fit into one word (LSB first).  When in 320C3x mode, the assembler
puts four characters into one word (MSB first).  In contrast to this
characters occupy two memory locations in the data segment of the
4500. The range of integer values corresponds to the word width of
each processor in a specific segment. This means that DATA has the
same result than WORD on a 320C3x (and that of SINGLE if AS
recognizes the operand as a floating-point constant).


        3.3.15.  ZERO
        - - - - - - -

--> valid for: PIC

Generates a continuous string of zero words in memory.  The length is
given by the argument and must not exceed 512.


        3.3.16. FB and FW
        - - - - - - - - -

--> valid for: COP8

These instruction allow to fill memory blocks with a byte or word
constant. The first operand specifies the size of the memory block
while the second one sets the filling constant itself. The maximum
supported block size is 1024 elements for FB and 512 elements for FW.


        3.3.17. ASCII and ASCIZ
        - - - - - - - - - - - -

--> valid for: ST62xx

Both commands store string constants to memory.  While ASCII writes
the character information only, ASCIZ additionally appends a zero to
the end of the string.


        3.3.18.  STRING and RSTRING
        - - - - - - - - - - - - - -

--> valid for: 320C2x, 320C5x

These commands are functionally equivalent to DATA, but integer
values are limited to the range of byte values. This enables two
characters or numbers to be packed together into one word. Both
commands only differ in the order they use to write bytes: STRING
stores the upper one first then the lower one, RSTRING does this vice
versa. Note that when in 320C2x/5x mode the assembler assumes that a
label on the left side of this instruction has no type, i.e. it
belongs to no address space. This behaviour is explained in the
processor-specific hints.


        3.3.19. FCC
        - - - - - -

--> valid for: 6502, 68xx

When in 65xx/68xx mode, string constants are generated using this
instruction. In contrast to the original assembler AS11 from Motorola
(this is the main reason why AS understands this command, the
functionality is contained within the BYT instruction) you must
enclose the string argument by double quotation marks instead of
single quotation marks or slashes.


        3.3.20.  DFS or RMB
        - - - - - - - - - -

--> valid for: 6502, 68xx

Reserves a memory block when in 6502/68xx mode.  It is therefore the
equivalent to DS.B on the 68000 or DB ? on Intel platforms.


        3.3.21. BLOCK
        - - - - - - -

--> valid for: ST62xx

Ditto.


        3.3.22. RES
        - - - - - -

--> valid for: PIC, MELPS-4500, 3201x, 320C2x, 320C5x, AVR

This command allocates memory.  When used in code segments the
argument counts words (10/12/14/16 bit).  In data segments it counts
bytes for PICs, nibbles for 4500's and words for the TI devices.


        3.3.23. BSS
        - - - - - -

--> valid for: 320C2x, 320C3x, 320C5x, MSP

BSS works like RES, but when in 320C2x/5x, mode the assembler assumes
that a label on the left side of this instruction has no type, i.e it
belongs to no address space. This behaviour is explained in the
processor-specific hints.


        3.3.24. DSB and DSW
        - - - - - - - - - -

--> valid for: COP8

Both instructions allocate memory and ensure compatibility to ASMCOP
from National.  While DSB takes the argument as byte count, DSW uses
it as word count (thus it allocates twice as much memory than DSB).


        3.3.25. ALIGN
        - - - - - - -

--> valid for: all processors

Takes the argument to align the program counter to a certain address
boundary.  AS increments the program counter to the next multiple
of the argument.  So, ALIGN corresponds to DS.x on 68000, but is much
more flexible at the same time.

Example:

	align	2

aligns to an even address (PC mod 2 = 0).  The contents of the
skipped addresses is left undefined.


        3.3.26. LTORG
        - - - - - - -

--> valid for: SH7x00

Although the SH7000 processor can do an immediate register load with
8 bit only, AS shows up with no such restriction.  This behaviour is
instead simulated through constants in memory.  Storing them in
the code segment (not far away from the register load instruction)
would require an additional jump.  AS Therefore gathers the constants
an stores them at an address specified by LTORG.  Details are
explained in the processor-specific section somewhat later.


        3.4. Macro Instructions
        -----------------------

--> valid for: all processors

Now we finally reach the things that make a macro assembler different
from an ordinary assembler: the ability to define macros (guessed
it !?).

When speaking about 'macros', I generally mean a sequence of (machine
or pseudo) instructions which are united to a block by special
statements and can then be treated in certain ways.  The assembler
knows the following statements to work with such blocks:


        3.4.1.  MACRO
        - - - - - - -

is probably the most important instruction for macro programming. 
The instruction sequence

<name>  MACRO   [parameter list]
        <instructions>
        ENDM

defines the macro <name> to be the enclosed instruction sequence. 
This definition by itself does not generate any code!  In turn, from
now on the instruction sequence can simply be called by the name, the
whole construct therefore shortens and simplifies programs.  A
parameter list may be added to the macro definition to make things
even more useful.  The parameters' names have to be separated by
commas (as usual) and have to conform to the conventions for symbol
names (see section 2.6.) - like the macro name itself.

A switch to case-sensitive mode influences both macro names and
parameters.

Similar to symbols, macros are local, i.e. they are only known in a
section and its subsections when the definition is done from within
a section.  This behaviour however can be controlled in wide limits
via the options PUBLIC and GLOBAL described below.

Apart from the macro parameters themselves, the parameter list may
contain control parameters which influence the processing of the
macro.  These parameters are distinguished from normal parameters by
being enclosed in braces.  The following control parameters are
defined:

- EXPAND / NOEXPAND : rule whether the enclosed code shall be written
  to the listing when the macro is expanded.  The default is the
  value set by the pseudo instruction MACEXP.

- PUBLIC[:section name] : assigns the macro to a parent section
  instead of the current section.  A section can make macros
  accessible for the outer code this way.  If the section
  specification is missing, the macro becomes completely global, i.e.
  it may be referenced from everywhere.

- GLOBAL[:section name] : rules that in addition to the macro itself,
  another macro shall be generated that has the same contents but is
  assigned to the specified section.  Its name is constructed by
  concatenating the current section's name to the macro name.  The
  section specified must be a parent section of the current section;
  if the specification is missing, the additional macro becomes
  globally visible.  For example, if a macro A is defined in a
  section B that is a child section of section C, an additional
  global macro named C_B_A would be generated.  In contrast, if C
  had been specified as target section, the macro would be named B_A
  and be assigned to section C.  This option is turned off by default
  and it only has an effect when it is used from within a section. 
  The macro defined locally is not influenced by this option.

- EXPORT / NOEXPORT : rules whether the definition of this macro
  shall be written to a separate file in case the -M command line
  option was given.  This way, definitions of 'private' macros may
  be mapped out selectively.  The default is FALSE, i.e. the
  definition will not be written to the file.  The macro will be
  written with the concatenated name if the GLOBAL option was
  additionally present.

The control parameters described above are removed from the parameter
list by AS, i.e. they do not have a further influence on processing
and usage.

When a macro is called, the parameters given for the call are
textually inserted into the instruction block and the resulting
assembler code is assembled as usual.  Zero length parameters are
inserted in case too few parameters are specified.  It is important
to note that string constants are not protected from macro
expansions.  The old IBM rule:

 It's not a bug, it's a feature!

applies for this detail.  The gap was left to allow checking of
parameters via string comparisons.  For example, one can analyze a
macro parameter in the following way:

mul     MACRO   para,parb
        IF      UpString("PARA")<>"A"
         MOV    a,para
        ENDIF
        IF      UpString("PARB")<>"B"
         MOV    b,parb
        ENDIF
        mul     ab
        ENDM

It is important for the example above that the assembler converts all
parameter names to upper case when operating in case-insensitive
mode, but this conversion never takes place inside of string
constants.  Macro parameter names therefore have to be written in
upper case when they appear in string constants.

The same naming rules as for usual symbols also apply for macro
parameters, with the exception that only letters and numbers are
allowed, i.e. dots and underscores are forbidden.  This constraint
has its reason in a hidden feature: the underscore allows to
concatenate macro parameter names to a symbol, like in the following
example:

concat  macro   part1,part2
        call    part1_part2
        endm

The call

        concat  module,function

will therefore result in

        call    module_function

A small example to remove all clarities ;-)

A programmer braindamaged by years of programming Intel processors
wants to have the instructions PUSH/POP also for the 68000.  He
solves the 'problem' in the following way:

push    macro   op
        move    op,-(sp)
        endm

pop     macro   op
        move    (sp)+,op
        endm

If one writes

        push    d0
        pop     a2       ,

this results in

        move.w  d0,-(sp)
        move.w  (sp)+,a2

A macro definition must not cross include file boundaries.

Labels defined in macros always are regarded as being local, an
explicit LOCAL instruction is therefore not necessary (it even does
not exist).  In case there is a reason to make a label global, one
may define it with LABEL which always creates global symbols (similar
to BIT, SFR...):

<Name>  label   $

When parsing a line, the assembler first checks the macro list
afterwards looks for processor instructions, which is why macros
allow to redefine processor instructions.  However, the definition
should appear previously to the first invocation of the instruction
to avoid phase errors like in the following example:

        bsr     target

bsr     macro   targ
        jsr     targ
        endm

        bsr     target

In the first pass, the macro is not known when the first BSR
instruction is assembled; an instruction with 4 bytes of length is
generated.  In the second pass however, the macro definition is
immediately available (from the first pass), a JSR of 6 bytes length
is therefore generated.  As a result, all labels following are too low
by 2 and phase errors occur for them.  An additional pass is
necessary to resolve this.

Because a machine or pseudo instruction becomes hidden when a macro
of same name is defined, there is a backdoor to reach the original
meaning: the search for macros is suppressed if the name is prefixed
with an exclamation mark (!).  This may come in handy if one wants to
extend existing instructions in their functionality, e.g. the
TLCS-90's shift instructions:

srl     macro   op,n            ; shift by n places
        rept    n               ; n simple instructions   
         !srl   op
        endm
        endm

From now on, the SRL instruction has an additional parameter...


        3.4.2.  IRP
        - - - - - -

is a simplified macro definition for the case that an instruction
sequence shall be applied to a couple of operands and the the code is
not needed any more afterwards.  IRP needs a symbol for the operand
as its first parameter, and an (almost) arbitrary number of
parameters that are sequentially inserted into the block of code. 
For example, one can write

        irp     op, acc,b,dpl,dph
        push    op
        endm

to push a couple of registers to the stack, what results in

        push    acc
        push    b  
        push    dpl
        push    dph

Again, labels used are automatically local for every pass.


        3.4.3. REPT
        - - - - - -

is the simplest way to employ macro constructs.  The code between
REPT and ENDM is assembled as often as the integer argument of REPT
specifies.  This statement is commonly used in small loops to replace
a programmed loop to save the loop overhead.

An example for the sake of completeness:

        rept    3
        rr      a
        endm

rotates the accumulator to the right by three digits.


        3.4.4.  WHILE
        - - - - - - -

WHILE operates similarly to REPT, but the fixed number of repetitions
given as an argument is replaced by a boolean expression.  The code
framed by WHILE and ENDM is assembled until the expression becomes
logically false.  This may mean in the extreme case that the enclosed
code is not assembled at all in case the expression was already false
when the construct was found.  On the other hand, it may happen that
the expression stays true forever and AS will run infinitely...one
should apply therefore a bit of accuracy when one uses this
construct, i.e. the code must contain a statement that influences the
condition, e.g. like this:

cnt     set     1
sq      set     cnt*cnt
        while   sq<=1000
         dc.l    sq
cnt      set     cnt+1
sq       set     cnt*cnt
        endm

This example stores all square numbers up to 1000 to memory.

Currently there exists a little ugly detail for WHILE: an additional
empty line that was not present in the code itself is added after the
last expansion.  This is a 'side effect' based on a weakness of the
macro processor and it is unfortunately not that easy to fix.  I hope
noone minds...


        3.4.5.  EXITM
        - - - - - - -

EXITM offers a way to terminate a macro expansion or one of the
instructions REPT, IRP, or WHILE prematurely.  Such an option
helps for example to replace encapsulations with IF-ENDIF-ladders
in macros by something more readable.  Of course, an EXITM itself
always has to be conditional, what leads us to an important detail:
When an EXITM is executed, the stack of open IF and SWITCH constructs
is reset to the state it had just before the macro expansion started. 
This is imperative for conditional EXITM's as the ENDIF resp. ENDCASE
that frames the EXITM statement will not be reached any more; AS
would print an error message without this trick.  Please keep also in
mind that EXITM always only terminates the innermost construct if
macro constructs are nested!  If one want to completely break out of
a nested construct, one has to use additional EXITM's on the higher
levels! 


        3.4.6. FUNCTION
        - - - - - - - -

Though FUNCTION is not a macro statement in the inner sense, I will
describe this instruction at this place because it uses similar
principles like macro replacements.

This instruction is used to define new functions that may then be
used in formula expressions like predefined functions.  The
definition must have the following form:

<name>  FUNCTION <arg>,..,<arg>,<expression>

The arguments are the values that are 'fed into' the function.  The
definition uses symbolic names for the arguments.  The assembler
knows by this that where to insert the actual values when the
function is called.  This can be seen from the following example:

isdigit FUNCTION ch,(ch>='0')&&(ch<='9')

This function checks whether the argument (interpreted as a
character) is a number in the currently valid character set (the
character set can be modified via CHARSET, therefore the careful
wording).

The arguments' names (CH in this case) must conform to the stricter
rules for macro parameter names, i.e. the special characters . and _
are not allowed.

User-defined functions can be used in the same way as builtin
functions, i.e. with a list of parameters, separated by commas,
enclosed in parentheses:

        IF isdigit(char)
         message "\{char} is a number"
        ELSEIF
         message "\{char} is not a number"
        ENDIF

When the function is called, all parameters are calculated once and
are then inserted into the function's formula.  This is done to
reduce calculation overhead and to avoid side effects.  The
individual arguments have to be separated by commas when a function
has more than one parameter.

CAUTION!  Similar to macros, one can use user-defined functions to
override builtin functions.  This is a possible source for phase
errors.  Such definitions therefore should be done before the first
call!

The result's type may depend on the type of the input arguments as
the arguments are textually inserted into the function's formula. 
For example, the function

double function x,x+x

may have an integer, a float, or even a string as result, depending
on the argument's type!

When AS operates in case-sensitive mode, the case matters when
defining or referencing user-defined functions, in contrast to
builtin functions!


        3.5. Conditional Assembly
        -------------------------

--> valid for: all processors

The assembler supports conditional assembly with the help of statements
like IF... resp. SWITCH... .  These statements work at assembly time
allowing or disallowing the assembly of program parts based on
conditions.  They are therefore not to be compared with IF statements
of high-level languages (though it would be tempting to extend
assembly language with structurization statements of higher level
languages...).

The following constructs may be nested arbitrarily (until a memory
overflow occurs).


        3.5.1.  IF / ELSEIF / ENDIF
        - - - - - - - - - - - - - -

IF is the most common and most versatile construct.  The general
style of an IF statement is as follows:

	IF      <expression 1>
	.
        .
        <block 1>
        .
        .
	ELSEIF  <expression 2>
        .
        .
	<block 2>
        .
        .
        (possibly more ELSEIFs)

        .
        .
        ELSEIF
	.
	.
        <block n>
        .
	.
        ENDIF

IF serves as an entry, evaluates the first expression, and assembles
block 1 if the expression is true (i.e. not 0).  All further
ELSEIF-blocks will then be skipped.  However, if the expression is
false, block 1 will be skipped and expression 2 is evaluated.  If
this expression turns out to be true, block 2 is assembled.  The
number of ELSEIF parts is variable and results in an IF-THEN-ELSE
ladder of an arbitrary length.  The block assigned to the last ELSEIF
(without argument) only gets assembled if all previous expressions
evaluated to false; it therefore forms a 'default' branch.  It is
important to note that only ONE of the blocks will be assembled: the
first one whose IF/ELSEIF had a true expression as argument.

The ELSEIF parts are optional, i.e. IF may directly be followed by an
ENDIF.  An ELSEIF without parameters must be the last branch.

ELSEIF always refers to the innermost, unfinished IF construct in
case IF's are nested.

In addition to IF, the following further conditional statements are
defined:

IFDEF <symbol>   : true if the given symbol has been defined.  The
                   definition has to appear before IFDEF.
IFNDEF <symbol>  : counterpart to IFDEF.
IFUSED <symbol>  : true if if the given symbol has been referenced
                   at least once up to now.
IFNUSED <symbol> : counterpart to IFUSED.
IFEXIST <name>   : true if the given file exists.  The same rules for
                   search paths and syntax apply as for the INCLUDE
                   instruction (see section 3.8.2.).
IFNEXIST <name>  : counterpart to IFEXIST.
IFB <arg-list>   : true if all arguments of the parameter list are 
                   empty strings.
IFNB <arg-list>  : counterpart to IFB.


        3.5.2  SWITCH / CASE / ELSECASE / ENDCASE
        - - - - - - - - - - - - - - - - - - - - -

CASE is a special case of IF and is designed for situations when an
expression has to be compared with a couple of values.  This could of
course also be done with a series of ELSEIFs, but the following form

            SWITCH  <expression>
            .
	    .
            CASE    <value 1>
	    .
            <block 1>
            .
            CASE    <value 2>
	    .
            <block 2>
            .
            (further CASE blocks)
	    .
            CASE    <value n-1>
            .
            <block n-1>
            .
            ELSECASE
            .
            <block n>
	    .
            ENDCASE

has the advantage that the expression is only written once and also
only gets evaluated once.  It is therefore less error-prone and
slightly faster than an IF chain, but obviously not as flexible.

It is possible to specify multiple values separated by commas to a
CASE statement in order to assemble the following block in multiple
cases.  The ELSECASE branch again serves as a 'trap' for the case
that none of the CASE conditions was met.  AS will issue a warning in
case it is missing and all comparisons fail.

Even when value lists of CASE branches overlap, only ONE branch is
executed, which is the first one in case of ambiguities.

SWITCH only serves to open the whole construct; an arbitrary number
of statements may be between SWITCH and the first CASE (but don't
leave other IFs open!), for the sake of better readability this
should however not be done. 

        3.6. Listing Control
        --------------------

--> valid for: all processors


        3.6.1. PAGE
        - - - - - -

PAGE is used to tell AS the dimensions of the paper that is used to
print the assembly listing.  The first parameter is thereby the
number of lines after which AS shall automatically output a form
feed.  One should however take into account that this value does NOT
include heading lines including an eventual line specified with
TITLE.  The minimum number of lines is 5, and the maximum value is
255.  A specification of 0 has the result that AS will not do any
form feeds except those triggered by a NEWPAGE instruction or those
implicitly engaged at the end of the assembly listing (e.g. prior to
the symbol table).

The specification of the listing's length in characters is an
optional second parameter and serves two purposes: on the one hand,
the internal line counter of AS will continue to run correctly when a
source line has to be split into several listing lines, and on
the other hand there are printers (like some laser printers) that do
not automatically wrap into a new line at line end but instead simply
discard the rest.  For this reason, AS does line breaks by itself,
i.e. lines that are too long are split into chunks whose lengths are
equal to or smaller than the specified width.  This may lead to
double line feeds on printers that can do line wraps on their own if
one specifies the exact line width as listing width.  The solution
for such a case is to reduce the assembly listing's width by 1.  The
specified line width may lie between 5 and 255 characters; a line
width of 0 means similarly to the page length that AS shall not do
any splitting of listing lines; lines that are too long of course
cannot be taken into account of the form feed then any more.

The default setting for the page length is 60 lines, the default for
the line width is 0; the latter value is also assumed when PAGE is
called with only one parameter.

CAUTION!  There is no way for AS to check whether the specified
listing length and width correspond to the reality!


        3.6.2.  NEWPAGE
        - - - - - - - -

NEWPAGE can be used to force a line feed though the current line is
not full up to now.  This might be useful to separate program parts
in the listing that are logically different.  The internal line
counter is reset and the page counter is incremented by one.  The
optional parameter is in conjunction with a hierarchical page
numbering AS supports up to a chapter depth of 4.  0 always refers to
the lowest depth, and the maximum value may vary during the assembly
run.  This may look a bit puzzling, as the following example shows:
	
page 1,   instruction NEWPAGE 0  ---> page 2
page 2,   instruction NEWPAGE 1  ---> page 2.1
page 2.1, instruction NEWPAGE 1  ---> page 3.1
page 3.1, instruction NEWPAGE 0  ---> page 3.2
page 3.2, instruction NEWPAGE 2  ---> page 4.1.1

NEWPAGE <number> may therefore result in changes in different digits,
depending on the current chapter depth.  An automatic form feed due
to a line counter overflow or a NEWPAGE without parameter is equal to
NEWPAGE 0.  Previous to the output of the symbol table, an implicit
NEWPAGE <maximum up to now> is done to start a new 'main chapter'.


        3.6.3. MACEXP
        - - - - - - -

One can achieve by the statement

     macexp off

that only the macro call and not the expanded text is listed for
macro expansions.  This is sensible for macro intensive codes to
avoid that the listing grows beyond all bounds.  The full listing can
be turned on again with a

     macexp on  .

This is also the default.

There is a subtle difference between the meaning of MACEXP for macros
and for all other macro-like constructs (e.g. REPT): while a macro
contain an internal flag that rules whether expansions of this macro
shall be listed or not, MACEXP directly influences all other
constructs that are resolved 'in place'.  The reason for this
differentiation is that there may be macros that are tested and their
expansion is therefore unnecessary, but all other macros still shall
be expanded.  MACEXP serves as a default for the macro's internal
flag when it is defined, and it may be overridden by the NOEXPAND/
EXPAND directives.

The current setting may be read from the symbol MACEXP.


        3.6.4.  LISTING
        - - - - - - - -

works like MACEXP and accepts the same parameters, but is much more
radical: After a

     listing off   ,

nothing at all will be written to the listing.  This directive makes
sense for tested code parts or include files to avoid a paper
consumption going beyond all bounds.  CAUTION!  If one forgets to
issue the counterpart somewhere later, even the symbol table will not
be written any more!  In addition to ON and OFF, LISTING also accepts
NOSKIPPED and PURECODE as arguments.  Program parts that were not
assembled due to conditional assembly will not be written to the
listing when NOSKIPPED is set, while PURECODE - as the name indicates
- even suppresses the IF directives themselves in the listing.  These
options are useful if one uses macros that act differently depending
on parameters and one only wants to see the used parts in the
listing.

The current setting may be read from the symbol LISTING (0=OFF, 1=ON,
2=NOSKIPPED, 3=PURECODE).


        3.6.5.  PRTINIT and PRTEXIT
        - - - - - - - - - - - - - -

Quite often it makes sense to switch to another printing mode (like
compressed printing) when the listing is sent to a printer and to
deactivate this mode again at the end of the listing.  The output of
the needed control sequences can be automated with these instructions
if one specifies the sequence that shall be sent to the output device
prior to the listing with PRTINIT <string> and similarly the
deinitialization string with PRTEXIT <string>.  <string> has to be a
string expression in both cases.  The syntax rules for string
constants allow to insert control characters into the string without
too much tweaking.

When writing the listing, the assembler does NOT differentiate where
the listing actually goes, i.e. printer control characters are sent
to the screen without mercy!

Example:

For Epson printers, it makes sense to switch them to compressed
printing because listings are so wide.  The lines

        prtinit "\15"
        prtexit "\18"

assure that the compressed mode is turned on at the beginning of the
listing and turned off afterwards.


        3.6.6.  TITLE
        - - - - - - -

The assembler normally adds a header line to each page of the listing
that contains the source file's name, date, and time.  This
statement allows to extend the page header by an arbitrary additional
line.  The string that has to be specified is an arbitrary string
expression.

Example:

For the Epson printer already mentioned above, a title line shall be
written in wide mode, which makes it necessary to turn off the
compressed mode before:

        title   "\18\14Wide Title\15"

(Epson printers automatically turn off the wide mode at the end of a
line.)


        3.7. Local Symbols
        ------------------

--> valid for: all processors

local symbols and the section concept introduced with them are a
completely new function that was introduced with version 1.39.  One
could say that this part is version "1.0" and therefore probably not
the optimum.  Ideas and (constructive) criticism are therefore
especially wanted.  I admittedly described the usage of sections how
I imagined it.  It is therefore possible that the reality is not
entirely equal to the model in my head.  I promise that in case of
discrepancies, changes will occur that the reality gets adapted to
the documentation and not vice versa (I was told that the latter
sometimes takes place in larger companies...).

AS does not generate linkable code (and this will probably not change
in the near future :-().  This fact forces one to always assemble a
program in a whole.  In contrast to this technique, a separation into
linkable modules would have several advantages:

- shorter assembly times as only the modified modules have to be
  reassembled;
- the option to set up defined interfaces among modules by definition
  of private and public symbols;
- the smaller length of the individual modules reduces the number of
  symbols per module and therefore allows to use shorter symbol names
  that are still unique.

Especially the last item was something that always nagged me: once
there was a label's name defined at the beginning of a 2000-lines
program, there was no way to reuse it somehow - even not at the
file's other end where routines with a completely different context
were placed.  I was forced to use concatenated names in the style of 

   <subprogram name>_<symbol name>

that had lengths ranging from 15 to 25 characters and made the
program difficult to overlook.  The concept of section described in
detail in the following text was designed to cure at least the second
and third item of the list above.  It is completely optional: if you
do not want to use sections, simply forget them and continue to work
like you did with previous versions of AS.


        3.7.1. Basic Definition (SECTION/ENDSECTION)
        - - - - - - - - - - - - - - - - - - - - - -

A section represents a part of the assembler program enclosed by
special statements and has a unique name chosen by the programmer:

        .
        .
        <other code>
        .
        .
        SECTION <section's name>
        .
        .
        <code inside of the section>
        .
        .
        ENDSECTION [section's name]
        .
        .
        <other code>
        .
        .

The name of a section must conform to the conventions for s symbol
name; AS stores section and symbol names in separate tables which is
the reason why a name may be used for a symbol and a section at the
same time.  Section names must be unique in a sense that there must
not be more than one section on the same level with the same name (I
will explain in the next part what "levels" mean).  The argument of
ENDSECTION is optional, it may also be omitted; if it is omitted, AS
will show the section's name that has been closed with this
ENDSECTION.  Code inside a section will be processed by AS exactly as
if it were outside, except for three decisive differences:

 - Symbols defined within a section additionally get an internally
   generated number that corresponds to the section.  These symbols
   are not accessible by code outside the section (this can be
   changed by pseudo instructions, later more about this).
 - The additional attribute allows to define symbols of the same
   name inside and outside the section; the attribute makes it
   possible to use a symbol name multiple times without getting error
   messages from AS.
 - If a symbol of a certain name has been defined inside and outside
   of a section, the "local" one will be preferred inside the
   section, i.e. AS first searches the symbol table for a symbol of
   the referenced name that also was assigned to the section.  A
   search for a global symbol of this name only takes place if the
   first search fails.

This mechanism e.g. allows to split the code into modules as one
might have done it with linkable code.  A more fine-grained approach
would be to pack every routine into a separate section.  Depending on
the individual routines' lengths, the symbols for internal use may
obtain very short names.

AS will by default not differentiate between upper and lower case in
section names; if one however switches to case-sensitive mode, the
case will be regarded just like for symbols.

The organization described up to now roughly corresponds to what is
possible in the C language that places all functions on the same
level.  However, as my "high-level" ideal was Pascal and not C, I
went one step further:

        3.7.2.  Nesting and Scope Rules
        - - - - - - - - - - - - - - - -

It is valid to define further sections within a section.  This is
analog to the option given in Pascal to define procedures inside a
procedure or function.  The following example shows this:

sym     EQU        0

        SECTION    ModuleA

         SECTION    ProcA1

sym       EQU        5

	 ENDSECTION ProcA1

         SECTION    ProcA2

sym       EQU        10

	 ENDSECTION ProcA2

	ENDSECTION ModuleA


	SECTION    ModuleB

sym      EQU        15

	 SECTION    ProcB

	 ENDSECTION ProcB

	ENDSECTION ModuleB

When looking up a symbol, AS first searches for a symbol assigned to
the current section, and afterwards traverses the list of parent
sections until the global symbols are reached.  In our example, the
individual sections see the following values for the symbol 'sym':

    section      value    from section...

    Global         0         Global
    ModuleA        0         Global
    ProcA1         5         ProcA1
    ProcA2        10         ProcA2
    ModuleB       15         ModuleB
    ProcB         15         ModuleB

This rule can be overridden by explicitly appending a section's name
to the symbol's name.  The section's name has to be enclosed in
brackets:

        move.l  #sym[ModulB],d0

Only sections that are in the parent section path of the current
section may be used.  The special values PARENT0..PARENT9 are allowed
to reference the n-th "parent" of the current section; PARENT0 is
therefore equivalent to the current section itself, PARENT1 the
direct parent and so on.  PARENT1 may be abbreviated as PARENT.  If
no name is given between the brackets, like in this example:

        move.l  #sym[],d0 ,

one reaches the global symbol.  CAUTION!  If one explicitly
references a symbol from a certain section, AS will only seek for
symbols from this section, i.e. the traversal of the parent sections
path is omitted!

Similar to Pascal, it is allowed that different sections have
subsections of the same name; the principle of locality avoids
irritations.  One should IMHO still use this feature as seldom as
possible: Symbols listed in the symbol resp. cross reference list are
only marked with the section they are assigned to, not with the
"section hierarchy" lying above them (this really would have busted
the available space); a differentiation is made very difficult this
way.

As a SECTION instruction does not define a label by itself, the
section concept has an important difference to Pascal's concept of
nested procedures: a pascal procedure can automatically "see" its
subprocedures(functions), AS requires an explicit definition of an
entry point.  This can be done e.g. with the following macro pair:

proc    MACRO   name
        SECTION name
name    LABEL   $
        ENDM

endp    MACRO   name
        ENDSECTION name
        ENDM

This example also shows that the locality of labels inside macros
is not influenced by sections.  It makes the trick with the LABEL
instruction necessary.

This does of course not solve the problem completely.  The label is
still local and not referencable from the outside.  Those who think
that it would suffice to place the label in front of the SECTION
statement should be quiet because they would spoil the bridge to the
next theme:


        3.7.3.  PUBLIC and GLOBAL
        - - - - - - - - - - - - -

The PUBLIC statement allows to change the assignment of a symbol to a
certain section.  It is possible to treat multiple symbols with one
statement, but I will use an example with only one symbol in the
following (not hurting the generality of this discussion).  In the
simplest case, one declares a symbol to be global, i.e. it can be
referenced from anywhere in the program:

        PUBLIC  <name>

As a symbol cannot be moved in the symbol table once it has been
sorted in, this statement has to appear BEFORE the symbol itself is
defined.  AS stores all PUBLICs in a list and removes an entry from
this list when the corresponding symbol is defined.  AS prints errors
at the end of a section in case that not all PUBLICs have been
resolved.

Regarding the hierarchical section concept, the method of defining a
symbol as purely global looks extremely brute.  There is fortunately
a way to do this in a bit more differentiated way: by appending a
section name:

        PUBLIC  <name>:<section>

The symbol will be assigned to the referenced section and therefore
also becomes accessible for all its subsections (except they define a
symbol of the same name that hides the "more global" symbol).  AS
will naturally protest if several subsections try to export a symbol
of same name to the same level.  The special PARENTn values mentioned
in the previous section are also valid for <section> to export a
symbol exactly n levels up in the section hierarchy.  Otherwise only
sections that are parent sections of the current section are valid
for <section>.  Sections that are in another part of the section tree
are not allowed.  If several sections in the parent section path
should have the same name (this is possible), the lowest level will
be taken.

This tool lets the abovementioned macro become useful:

proc    MACRO   name
        SECTION name
        PUBLIC  name:PARENT
name    LABEL   $
        ENDM

This setting is equal to the Pascal model that also only allows the
"father" to see its children, but not the "grandpa".

AS will quarrel about double-defined symbols if more than one section
attempts to export a symbol of a certain name to the same upper
section.  This is by itself a correct reaction, and one needs to
"qualify" symbols somehow to make them distinguishable if these
exports were deliberate.  A GLOBAL statement does just this.  The
syntax of GLOBAL is identical to PUBLIC, but the symbol stays local
instead of being assigned to a higher section.  Instead, an
additional symbol of the same value but with the subsection's name
appended to the symbol's name is created, and only this symbol is
made public according to the section specification.  If for example
two sections A and B both define a symbol named SYM and export it
with a GLOBAL statement to their parent section, the symbols are
sorted in under the names A_SYM resp. B_SYM .

In case that source and target section are separated by more than one
level, the complete name path is prepended to the symbol name.


        3.7.4.  FORWARD
        - - - - - - - -

The model described so far may look beautiful, but there is an
additional detail not present in Pascal that may spoil the happiness:
Assembler allows forward references.  Forward references may lead to
situations where AS accesses a symbol from a higher section in the
first pass.  This is not a disaster by itself as long as the correct
symbol is used in the second pass, but accidents of the following
type may happen:

loop:   .
        <code>
	.
	.
	SECTION sub
	.               ; ***
	.
	bra.s   loop
	.
	.
loop:   .
	.
	ENDSECTION
	.
	.
	jmp     loop    ; main loop

AS will take the global label 'loop' in the first pass and will
quarrel about an out-of-branch situation if the program part at
<code> is long enough.  The second pass will not be started at all. 
One way to avoid the ambiguity would be to explicitly specify the
symbol's section:

        bra.s   loop[sub]

If a local symbol is referenced several times, the brackets can be
saved by using a FORWARD statement.  The symbol is thereby explicitly
announced to be local, and AS will only look in the local symbol
table part when this symbol is referenced.  For our example, the
statement

        FORWARD loop

should be placed at the position marked with ***.

FORWARD must not only be stated prior to a symbol's definition, but
also prior to its first usage in a section to make sense.  It does
not make sense to define a symbol private and public; this will be
regarded as an error by AS.


        3.7.5.  Performance Aspects
        - - - - - - - - - - - - - -

The multi-stage lookup in the symbol table and the decision to which
section a symbol shall be assigned of course cost a bit of time to
compute.  An 8086 program of 1800 lines length for example took 34.5
instead of 33 seconds after a modification to use sections (80386 SX,
16MHz, 3 passes).  The overhead is therefore limited.  As it has
already been stated at the beginning, is is up to the programmer if
(s)he wants to accept it.  One can still use AS without sections.


        3.8. Miscellaneous
        ------------------


        3.8.1. SHARED
        - - - - - - -

--> valid for: all processors

This statement instructs AS to write the symbols given in the
parameter list (regardless if they are integer, float or string
symbols) together with their values into the share file.  It depends
upon the command line parameters described in section 2.1 whether
such a file is generated at all and in which format it is written. 
If AS detects this instruction and no share file is generated, a
warning is the result.

CAUTION!  A comment possibly appended to the statement itself will be
copied to the first line outputted to the share file (if SHARED's
argument list is empty, only the comment will be written).  In case a
share file is written in C or Pascal format, one has to assure that
the comment itself does not contain character sequences that close
the comment ("*/" resp. "*)").  AS does not check for this!

       
        3.8.2.  INCLUDE
        - - - - - - - -

--> valid for: all processors

This instruction inserts the file given as a parameter into the just as
if it would have been inserted with an editor (the file name may
optionally be enclosed with " characters).  This instruction is
useful to split source files that would otherwise not fit into the
editor or to create "tool boxes".

In case that the file name does not have an extension, it will
automatically be extended with "INC".

Via the '-i <path list>' option, one can specify a list of
directories that will automatically be searched for the file.  If the
file is not found, a FATAL error occurs, i.e. assembly terminates
immediately.

For compatibility reasons, it is valid to enclose the file name in "
characters, i.e. 

        include stddef51
and
        include "stddef51.inc"

are equivalent.  CAUTION! This freedom of choice is the reason why
only a string constant but no string expression is allowed!

The search list is ignored if the file name itself contains a path
specification.


        3.8.3.   BINCLUDE
        - - - - - - - - -

--> valid for: all processors

BINCLUDE can be used to embed binary data generated by other programs
into the code generated by AS (this might theoretically even be code
created by AS itself...).  BINCLUDE has three forms:

   BINCLUDE <file>

This way, the file is completely included.

   BINCLUDE <file>,<offset>

This way, the file's contents are included starting at <offset> up to
the file's end.

   BINCLUDE <file>,<offset>,<length>

This way, <length> bytes are included starting at <offset>.

The same rules regarding search paths apply as for INCLUDE.


        3.8.4.  MESSAGE, WARNING, ERROR and FATAL
        - - - - - - - - - - - - - - - - - - - - -
           
--> valid for: all processors  

Though the assembler checks source files as strict as possible and
delivers differentiated error messages, it might be necessary from
time to time to issue additional error messages that allow an
automatic check for logical error.  The assembler distinguishes
among three different types of error messages that are accessible to
the programmer via the following three instructions:

- WARNING : Errors that hint at possibly wrong or inefficient code.
            Assembly continues and a code file is generated.

- ERROR   : True errors in a program.  Assembly continues to allow
            detection of possible further errors in the same pass.
            A code file is not generated.

- FATAL   : Serious errors that force an immediate termination of 
            assembly.  A code file may be generated but will be
            incomplete.

All three instructions have the same format for the message that shall
be issued: an arbitrary (possibly computed?!) string expression which
may therefore be either a constant or variable.

These instructions generally only make sense in conjunction wit
conditional assembly.  For example, if there is only a limited
address space for a program, one can test for overflow in the
following way:

ROMSize         equ     8000h           ; 27256 EPROM

ProgStart: 
                .
                .
                <the program itself>
                .
                .
ProgEnd:   

                if      ProgEnd-ProgStart>ROMSize
                 error  "\athe program is too long!"
                endif

Apart from the instructions generating errors, there is also an
instruction MESSAGE that simply prints a message to the console resp.
to the assembly listing.  Its usage is equal to the other three
instructions.


        3.8.5. READ
        - - - - - -
           
--> valid for: all processors

One could say that READ is the counterpart to the previous
instruction group: it allows to read values from the keyboard during
assembly.  You might ask what this is good for.  I will break with
the previous principles and put an example before the exact
description to outline the usefulness of this instruction:

A program needs for data transfers a buffer of a size that should be
set at assembly time.  One could store this size in a symbol defined
with EQU, but it can also be done interactively with READ:

      IF     MomPass=1
       READ  "buffer size",BufferSize
      ENDIF

Programs can this way configure themselves dynamically during assembly
and one could hand over the source to someone who can assemble it
without having to dive into the source code.  The IF conditional
shown in the example should always be used to avoid bothering the
user multiple times with questions.

READ is quite similar to SET with the difference that the value is
read from the keyboard instead of the instruction's arguments.  This
for example also implies that AS will automatically set the symbol's
type (integer, float or string) or that it is valid to enter formula
expressions instead of a simple constant.

READ may either have one or two parameters because the prompting
message is optional.  AS will print a message constructed from the
symbol's name if it is omitted.


        3.8.6.  RELAXED
        - - - - - - - -

--> valid for: all processors

By default, AS assigns a distinct syntax for integer constants to a
processor family (which is in general equal to the manufacturer's
specifications, as long as the syntax is not too bizarre...). 
Everyone however has his own preferences for another syntax and may
well live with the fact that his programs cannot be translated any
more with the standard assembler.  If one places the instruction
           
      RELAXED ON
           
right at the program's beginning, one may furtherly use any syntax
for integer constants, even mixed in a program.  AS tries to guess
automatically for every expression the syntax that was used.  This
automatism does not always deliver the result one might have in mind,
and this is also the reason why this option has to be enable
explicitly: if there are no prefixes or postfixes that unambiguously 
identify either Intel or Motorola syntax, the C mode will be used. 
Leading zeroes that are superfluous in other modes have a meaning in
this mode:

      move.b  #08,d0

This constant will be understood as an octal constant and will result
in an error message as octal numbers may only contain digits from 0
to 7.  One might call this a lucky case; a number like 077 would
result in trouble without getting a message about this.  Without the
relaxed mode, both expressions unambiguously would have been
identified as decimal constants.

The current setting may be read from a symbol with the same name.


        3.8.7.  END
        - - - - - -
           
--> valid for: all processors

END marks the end of an assembler program.  Lines that eventually
follow in the source file will be ignored.  IMPORTANT: END may be
called from within a macro, but the IF-stack for conditional assembly
is not cleared automatically.  The following construct therefore
results in an error:

        IF DontWantAnymore
         END
        ELSEIF

END may optionally have an integer expression as argument that marks
the program's entry point.  AS stores this in the code file with a
special record and it may be post-processed e.g. with P2HEX.

END has always been a valid instruction for AS, but the only reason
for this in earlier releases of AS was compatibility; END had no
effect.


        4. Processor-specific Hints
        ===========================

When writing the individual code generators, I strived for a maximum
amount of compatibility to the original assemblers.  However, I only did this
as long as it did not mean an unacceptable additional amount of work. 
I listed important differences, details and pitfalls in the following
chapter.


        4.1. 6811
        --------- 

"Where can I buy such a beast, a HC11 in NMOS?", some of you might
ask.  Well, of course it does not exist, but an H cannot be
represented in a hexadecimal number (older versions of AS would not
have accepted such a name because of this), and so I decided to omit
all the letters...

"Someone stating that something is impossible should be at least as
 cooperative as not to hinder the one who currently does it."

From time to time, one is forced to revise one's opinions.  Some
versions earlier, I stated at his place that I couldn't use AS's
parser in a way that it is also possible to to separate the arguments
of BSET/BCLR resp. BRSET/BRCLR with spaces.  However, it seems that
it can do more than I wanted to believe...after the n+1th request, I
sat down once again to work on it and things seem to work now.  You
may use either spaces or commas , but not in all variants, to avoid
ambiguities: for every variant of an instruction, it is possible to
use only commas or a mixture of spaces and commas as Motorola seems
to have defined it (their data books do not always have the quality
of the corresponding hardware...):

   Bxxx  abs8 #mask         is equal to   Bxxx  abs8,#mask
   Bxxx  disp8,X #mask      is equal to   Bxxx  disp8,X,#mask
   BRxxx abs8 #mask addr    is equal to   BRxxx abs8,#mask,addr
   BRxxx disp8,X #mask addr is equal to   BRxxx disp8,X,#mask,addr

In this list, xxx is a synonym either for SET or CLR; #mask is the
bit mask to be applied (the # sign is optional).  Of course, the same
statements are also valid for Y-indexed expression (not listed here).


	4.2. PowerPC
        ------------

Of course, it is a bit crazy idea to add support in AS for a
processor that was mostly designed for usage in work stations. 
Remember that AS mainly is targeted at programmers of single board
computers.  But things that today represent the absolute high end in
computing will be average tomorrow and maybe obsolete the next day,
and in the meantime, the Z80 as the 8088 have been retired as CPUs
for personal computers and been moved to the embedded market;
modified versions are marketed as microcontrollers.  With the
appearance of the MPC505 and PPC403, my suspicion has proven to be
true that IBM and Motorola try to promote this architecture in as
many fields as possible.

However, the current support is a bit incomplete: Temporarily, the
Intel-style mnemonics are used to allow storage of data and the more
uncommon RS/6000 machine instructions mentioned in [Mot601] are
missing (hopefully noone misses them!).  I will finish this as soon
as information about them is available!


        4.3. DSP56000
        -------------

Motorola, which devil rode you!  Which person in your company had the
"brilliant" idea to separate the parallel data transfers with spaces!
In result, everyone who wants to make his code a bit more readable,
e.g. like this:

    move    x:var9 ,r0
    move    y:var10,r3   ,

is p****ed because the space gets recognized as a separator for
parallel data transfers!

Well...Motorola defined it that way, and I cannot change it.  Using
tabs instead of spaces to separate the parallel operations is also
allowed, and the individual operations' parts are again separated
with commas, as one would expect it. 

[Mot56] states that instead of using MOVEC, MOVEM, ANDI or ORI, it is
also valid to use the more general Mnemonics MODE, AND or OR.  AS
(currently) does not support this.


        4.4. H8/300
        -----------

Regarding the assembler syntax of these processors, Hitachi
generously copied from Motorola (that wasn't by far the worst
choice...), unfortunately the company wanted to introduce its own
format for hexadecimal numbers.  To make it even worse, it is a
format that uses unbalanced single quotes, just like Microchip does.  This is
something I could not (I even did not want to) reproduce with AS, as
AS uses single quotes to surround ASCII character sequences. 
Instead, one has to write hexadecimal numbers in the well-known
Motorola syntax: with a leading dollar sign.


        4.5. SH7000/7600
        ----------------

Unfortunately, Hitachi once again used their own format for
hexadecimal numbers, and once again I was not able to reproduce this
with AS...please use Motorola syntax! 

When using literals and the LTORG instruction, a few things have to
be kept in mind if you do not want to suddenly get confronted with
strange error messages:

Literals exist due to the fact that the processor is unable to load
constants out of a range of -128 to 127 with immediate addressing. 
AS (and the Hitachi assembler) hide this inability by the automatic
placement of constants in memory which are then referenced via
PC-relative addressing.  The question that now arises is where to
locate these constants in memory.  AS does not automatically place a
constant in memory when it is needed; instead, they are collected
until an LTORG instruction occurs.  The collected constants are then
dumped en bloc, and their addresses are stored in ordinary labels
which are also visible in the symbol table.  Such a label's name is
of the form

  LITERAL_s_xxxx_n  .

In this name, s represents the literal's type.  Possible values are W
for 16-bit constants, L for 32-bit constants and F for forward
references where AS cannot decide in anticipation which size is
needed.  In case of s=W or L, xxxx denotes the constant's value in a
hexadecimal notation, whereas xxxx is a simple running number for
forward references (in a forward reference, one does not know the
value of a constant when it is referenced, so one obviously cannot
incorporate its value into the name).  n is a counter that signifies
how often a literal of this value previously occurred in the current
section.  Literals follow the standard rules for localization by
sections.  It is therefore absolutely necessary to place literals
that were generated in a certain section before the section is
terminated!

The numbering with n is necessary because a literal may occur
multiple times in a section.  One reason for this situation is that
PC-relative addressing only allows positive offsets; Literals that
have once been placed with an LTORG can therefore not be referenced
in the code that follows.  The other reason is that the displacement
is generally limited in length (512 resp. 1024 bytes).

An automatic LTORG at the end of a program or previously to switching
to a different target CPU does not occur; if AS detects unplaced
literals in such a situation, an error message is printed.

As the PC-relative addressing mode uses the address of the current
instruction plus 4, it is not possible to access a literal that is
stored directly after the instruction, like in the following example:

        mov     #$1234,r6
        ltorg

This is a minor item since the CPU anyway would try to execute the
following data as code.  Such a situation should not occur in a real
program...another pitfall is far more real: if PC-relative addressing
occurs just behind a delayed branch, the program counter is already
set to the destination address, and the displacement is computed
relative to the branch target plus 2.  Following is an example where
this detail leads to a literal that cannot be addressed:

        bra     Target
        mov     #$12345678,r4        ; is executed
        .
        .
        ltorg                        ; here is the literal
        .
        .
Target: mov     r4,r7                ; execution continues here

As Target+2 is on an address behind the literal, a negative
displacement would result.  Things become especially hairy when one
of the branch instructions JMP, JSR, BRAF, or BSRF is used: as AS
cannot calculate the target address (it is generated at runtime from
a register's contents), a PC value is assumed that should never fit,
effectively disabling any PC-relative addressing at this point.

It is not possible to deduce the memory usage from the count and size
of literals.  AS might need to insert a padding word to align a long
word to an address that is evenly divisible by 4; on the other hand,
AS might reuse parts of a 32-bit literal for other 16-bit literals. 
Of course multiple use of a literal with a certain value will create
only one entry.  However, such optimizations are completely
suppressed for forward references as AS does not know anything about
their value.

As literals use the PC-relative addressing which is only allowed for
the MOV instruction, the usage of literals is also limited to MOV
instructions.  The way AS uses the operand size is a bit tricky: A
specification of a byte or word move means to generate the shortest
possible instruction that results in the desired value placed in the
register's lowest 8 resp. 16 bits.  The upper 24 resp. 16 bits are
treated as "don't care".  However, if one specifies a longword move
or omits the size specification completely, this means that the
complete 32-bit register should contain the desired value.  For
example, in the following sequence

        mov.b   #$c0,r0
        mov.w   #$c0,r0
        mov.l   #$c0,r0   ,

the first instruction will result in true immediate addressing, the
second and third instruction will use a word literal:  As bit 7 in
the number is set, the byte instruction will effectively create the
value $FFFFFFC0 in the register.  According to the convention, this
wouldn't be the desired value in the second and third example. 
However, a word literal is also sufficient for the third case because
the processor will copy a cleared bit 15 of the operand to bits
16..31. 

As one can see, the whole literal stuff is rather complex; I'm sorry but
there was no chance of making things simpler.  It is unfortunately a
part of its nature that one sometimes gets error messages about
literals that were not found, which logically should not occur because
AS does the literal processing completely on his own.  However, if
other errors occur in the second pass, all following labels will move
because AS does not generate any code any more for statements that
have been identified as erroneous.  As literal names are partially built
from other symbols' values, other errors might follow because literal
names searched in the second pass differ from the names stored in the
first pass and AS quarrels about undefined symbols...if such errors
should occur, please correct all other errors first before you start
cursing on me and literals...

People who come out of the Motorola scene and want to use PC-relative
addressing explicitly (e.g. to address variables in a position-
independent way) should know that if this addressing mode is written
like in the programmer's manual:

	mov.l   @(Var,PC),r8

NO implicit conversion of the address to a displacement will occur,
i.e. the operand is inserted as-is into the machine code (this will
probably generate a value range error...).  If you want to use
PC-relative addressing on the SH7x00, simply use "absolute"
addressing (which does not exist on machine level):

        mov.l   Var,r8

In this example, the displacement will be calculated correctly (of
course, the same limitations apply for the displacement as it was the
case for literals).


        4.6. MELPS-4500
        ---------------

The program memory of these microcontrollers is organized in pages of
128 words.  Honestly said, this organization only exists because there
are on the one hand branch instructions with a target that must lie
within the same page, and on the other hand "long" branches that can
reach the whole address space.  The standard syntax defined by
Mitsubishi demands that page number and offset have to be written as
two distinct arguments for the latter instructions.  As this is
quite inconvenient (except for indirect jumps, a programmer has no
other reason to deal with pages), AS also allows to write the target
address in a "linear" style, for example

      bl     $1234

instead of

      bl     $24,$34 .


        4.7. MELPS-740
        --------------

Microcontrollers of this family have a quite nice, however well-hidden
feature: If one sets bit 5 of the status register with the SET
instruction, the accumulator will be replaced with the memory cell
addressed by the X register for all load/store and arithmetic
instructions.  An attempt to integrate this feature cleanly into the
assembly syntax has not been made so far, so the only way to use it
is currently the "hard" way (SET...instructions with accumulator
addressing...CLT).

Not all MELPS-740 processors implement all instructions.  This is a
place where the programmer has to watch out for himself that no
instructions are used that are unavailable for the targeted
processor; AS does not differentiate among the individual processors
of this family.  For a description of the details regarding special
page addressing, see the discussion of the ASSUME instruction.


        4.8. MELPS-7700/65816
        ---------------------

As it seems, these two processor families took disjunct development
paths, starting from the 6502 via their 8 bit predecessors.  Shortly
listed, the following differences are present:

- The 65816 does not have a B accumulator.
- The 65816 does not have instructions to multiply or divide.
- The 65816 misses the instructions SEB, CLB, BBC, BBS, CLM, SEM,
  PSH, PUL and LDM.  Instead, the instructions TSB, TRB, BIT, CLD,
  SED, XBA, XCE and STZ take their places in the opcode table.

The following instructions have identical function, yet different
names:

   65816     MELPS-7700       65816    MELPS-7700

    REP        CLP             PHK        PHG
    TCS        TAS             TSC        TSA
    TCD        TAD             TDC        TDA
    PHB        PHT             PLB        PLT
    WAI        WIT

Especially tricky are the instructions PHB, PLB and TSB: these
instructions have a totally different encoding and meaning on both
processors!

Unfortunately, these processors address their memory in a way that is
IMHO even one level higher on the open-ended chart of perversity than
the Intel-like segmentation: They do banking!  Well, this seems to
be the price for the 6502 upward-compatibility; before one can use AS
to write code for these processors, one has to inform AS about the
contents of several registers (using the ASSUME instruction):

The M flag rules whether the accumulators A and B should be used with
8 bits (1) or 16 bits (0) width.  Analogously, the X flag decides the
width of the X and Y index registers.  AS needs this information for
the decision about the argument's width when immediate addressing
(#<constant>) occurs.

The memory is organized in 256 banks of 64 KBytes.  As all registers
in the CPU core have a maximum width of 16 bits, the upper 8 bits
have to be fetched from 2 special bank registers: DT delivers the
upper 8 bits for data accesses, and PG extends the 16-bit program
counter to 24 bits.  A 16 bits wide register DPR allows to move the
zero page known from the 6502 to an arbitrary location in the first
bank.  If AS encounters an address (it is irrelevant if this address
is part of an absolute, indexed, or indirect expression), the
following addressing modes will be tested:

  1. Is the address in the range of DPR..DPR+$ff?  If yes, use direct
     addressing with an 8-bit address.
  2. Is the address contained in the page addressable via DT (resp.
     PG for branch instructions)? If yes, use absolute addressing
     with a 16-bit address.
  3. If nothing else helps, use long addressing with a 24-bit
     address.

As one can see from this enumeration, the knowledge about the current
values of DT, PG and DPR is essential for a correct operation of AS;
if the specifications are incorrect, the program will probably do
wrong addressing at runtime.  This enumeration also implied that all
three address lengths are available; if this is not the case, the
decision chain will become shorter.

The automatic determination of the address length described above may
be overridden by the usage of prefixes.  If one prefixes the address
by a <, >, or >> without a separating space, an address with 1, 2, or
3 bytes of length will be used, regardless if this is the optimal
length.  If one uses an address length that is either not allowed for
the current instruction or too short for the address, an error
message is the result.

To simplify porting of 6502 programs, AS uses the Motorola syntax for
hexadecimal constants instead of the Intel/IEEE syntax that is
the format preferred by Mitsubishi for their 740xxx series.  I still
think that this is the better format, and it looks as if the
designers of the 65816 were of the same opinion (as the RELAXED
instruction allows the alternative use of Intel notation, this
decision should not hurt anything).  Another important detail for the
porting of programs is that it is valid to omit the accumulator A as
target for operations.  For example, it is possible to simply write
LDA #0 instead of LDA A,#0.

A real goodie in the instruction set are the instructions MVN resp.
MVP to do block transfers.  However, their address specification
rules are a bit strange: bits 0--15 are stored in index registers,
bits 16--23 are part of the instruction.  When one uses AS, one
simply specifies the full destination and source addresses.  AS will
then automatically grab the correct bits.  This is a fine yet
important difference  Mitsubishi's assembler where you have to
extract the upper 8 bits on your own.  Things become really
convenient when a macro like the following is used:

mvpos   macro   src,dest,len
	if      MomCPU=$7700
	 lda    #len
	elseif
	 lda    #(len-1)
	endif
	ldx     #(src&$ffff)
	ldy     #(dest&$ffff)
	mvp     dest,src
	endm

Caution, possible pitfall: if the accumulator contains the value n,
the Mitsubishi chip will transfer n bytes, but the 65816 will
transfer n+1 bytes!

The PSH and PUL instructions are also very handy because they allow
to save a user-defined set to be saved to the stack resp. to be
restored from the stack.  According to the Mitsubishi data
book[Mit16], the bit mask has to be specified as an immediate
operand, so the programmer either has to keep all bit<-->register
assignments in mind or he has to define some appropriate symbols.  To
make things simpler, I decided to extend the syntax at this point: It
is valid to use a list as argument which may contain an arbitrary
sequence of register names or immediate expressions.  Therefore, the
following instructions

        psh     #$0f
        psh     a,b,#$0c
        psh     a,b,x,y 

are equivalent.  As immediate expressions are still valid, AS stays
upward compatible to the Mitsubishi assemblers.

One thing I did not fully understand while studying the Mitsubishi
assembler is the treatment of the PER instruction: this instruction
allows to push a 16-bit variable onto the stack whose address is
specified relative to the program counter.  Therefore, it is an
absolute addressing mode from the programmer's point of view. 
Nevertheless, the Mitsubishi assembler requests immediate addressing,
and the instructions argument is placed into the code just as-is. 
One has to calculate the address in his own, which is something
symbolic assemblers were designed for to avoid...as I wanted to stay
compatible, AS contains a compromise:  If one chooses immediate
addressing (with a leading # sign), AS will behave like the original
from Mitsubishi.  But if the # sign is omitted, as will calculate the
difference between the argument's value and the current program
counter and insert this difference instead.

A similar situation exists for the PEI instruction that pushes the
contents of a 16-bit variable located in the zero page: Though the
operand represents an address, once again immediate addressing is
required.  In this case, AS will simply allow both variants (i.e.
with or without a # sign).   


        4.9. M16
        --------

The M16 family is a family of highly complex CISC processors with an
equally complicated instruction set.  One of the instruction set's
properties is the detail that in an instruction with two operands,
both operands may be of different sizes.  The method of appending the
operand size as an attribute of the instruction (known from Motorola
and adopted from Mitsubishi) therefore had to be extended: it is
valid to append attributes to the operands themselves.  For example,
the following instruction

        mov     r0.b,r6.w

reads the lowest 8 bits of register 0, sign-extends them to 32 bits
and stores the result into register 6.  However, as one does not need
this feature in 9 out of 10 cases, it is still valid to append the
operand size to the instruction itself, e.g.

        mov.w   r0,r6

Both variants may be mixed; in such a case, an operand size appended
to an operand overrules the "default".  An exception are instructions
with two operands.  For these instructions, the default for the
source operand is the destination operand's size.  For example, in
the following example

        mov.h   r0,r6.w

register 0 is accessed with 32 bits, the size specification appended
to the instruction is not used at all.  If an instruction does not
contain any size specifications, word size (w) will be used. 
Remember: in contrast to the 68000 family, this means 32 bits instead
of 16 bits!

The chained addressing modes are also rather complex; the ability of
AS to automatically assign address components to parts of the chain
keeps things at least halfway manageable.  The only way of influencing
AS allows (the original assembler from Mitsubishi/Green Hills allows
a bit more in this respect) is the explicit setting of displacement
lengths by appending :4, :16 and :32.


        4.10. MCS-48
        ------------

The maximum address space of these processors is 4 Kbytes large. 
This address space is not organized in a linear way (how could this
be on an Intel CPU...).  Instead, it is split into 2 banks of 2
Kbytes.  The only way to change the program counter from one bank to
the other are the instructions CALL and JMP, by setting the most
significant bit of the address with the instructions 

  SEL MB0  resp.  SEL MB1    .

To simplify jumps between these two banks, the instructions JMP and
CALL contain an automatism that inserts one of these two instructions
if the current program counter and the target address are in
different banks.  Explicit usage of these SEL MBx instructions should
therefore not be necessary (though it is possible), and it can puzzle
the automatism, like in the following example:

 000: SEL MB1
      JMP 200h

AS assumes that the MB flag is 0 and therefore does not insert a
SEL MBO instruction, with the result that the CPU jumps to address
A00h.

Furthermore, one should keep in mind that a jump instruction might
become longer (3 instead of 2 bytes).


	4.11. MCS-51
        ------------

The assembler is accompanied by the files STDDEF51.INC resp.
80C50X.INC that define all bits and SFRs of the processors 8051,
8052, and 80515 resp. 80C501, 502, and 504.  Depending on the target
processor setting (made with the CPU statement), the correct subset
will be included.  Therefore, the correct order for the instructions
at the beginning of a program is

        CPU     <processor type>
        INCLUDE stddef51.inc   .

Otherwise, the MCS-51 pseudo instructions will lead to error
messages.

As the 8051 does not have instructions to to push the registers 0..7
onto the stack, one has to work with absolute addresses.  However,
these addresses depend on which register bank is currently active. 
To make this situation a little bit better, the include files define
the macro USING that accepts the symbols Bank0...Bank3 as arguments.
In response, the macro will assign the registers' correct absolute
addresses to the symbols AR0..AR7.  This macro should be used after
every change of the register banks.  The macro itself does NOT
generate any code to switch to the bank!

The macro also makes bookkeeping about which banks have been used. 
The result is stored in the integer variable 'RegUsage': bit 0
corresponds to bank 0, bit 1 corresponds to bank 1. and so on.  To
output its contents after the source has been assembled, use
something like the following piece of code:

        irp             BANK,Bank0,Bank1,Bank2,Bank3
         if             (RegUsage&(2^BANK))<>0
          message       "bank \{BANK} has been used"
         endif
        endm

The multipass feature introduced with version 1.38 allowed to
introduce the additional instructions JMP and CALL.  If branches are
coded using these instructions, AS will automatically use the variant
that is optimal for the given target address.  The options are SJMP,
AJMP, or LJMP for JMP resp. ACALL or LCALL for CALL.  Of course it
is still possible to use these variants directly, in case one wants
to force a certain coding.


	4.12. MCS-251
        -------------

When designing the 80C251, Intel really tried to make the move to
the new family as smooth as possible for programmers.  This
culminated in the fact that old applications can run on the new
processor without having to recompile them.  However, as soon as one
wants to use the new features, some details have to be regarded which
may turn into hidden pitfalls.

The most important thing is the absence of a distinct address space
for bits on the 80C251.  All SFRs can now be addressed bitwise,
regardless of their address.  Furthermore, the first 128 bytes of the
internal RAM are also bit addressable.  This has become possible
because bits are not any more handled by a separate address space
that overlaps other address spaces.  Instead, similar to other
processors, bits are addressed with a two-dimensional address that
consists of the memory location containing the bit and the bit's
location in the byte.  One result is that in an expression like
PSW.7, AS will do the separation of address and bit position itself. 
Unlike to the 8051, it is not any more necessary to explicitly
generate 8 bit symbols.  This has the other result that the SFRB
instruction does not exist any more.  If it is used in a program that
shall be ported, it may be replaced with a simple SFR instruction.

Furthermore, Intel cleaned up the cornucopia of different address
spaces on the 8051: the internal RAM (DATA resp. IDATA), the XDATA
space and the former CODE space were unified to a single CODE space
that is now 16 Mbytes large.  The internal RAM starts at address 0,
the internal ROM starts at address ff0000h, which is the address code
has to be relocated to.  In contrast, the SFRs were moved to a
separate address space (which AS refers to as the IO segment). 
However, they have the same addresses in this new address space as
they used to have on the 8051.  The SFR instructions knows of this
difference and automatically assigns symbols to either the DATA or IO
segment, depending on the target processor.  As there is no BIT
segment any more, the BIT instruction operates completely different:
Instead of a linear address ranging from 0..255, a bit symbol now
contains the byte's address in bit 0..7, and the bit position in bits
24..26.  Unfortunately, creating arrays of flags with a symbolic
address is not that simple any more:  On an 8051, one simply wrote:

        segment bitdata                  

bit1    db      ?                        
bit2    db      ?                        

or

defbit  macro   name
name    bit     cnt
cnt     set     cnt+1
        endm   

On a 251, only the second way still works, like this:
  
adr     set     20h     ; start address of flags in the internal RAM
bpos    set     0

defbit  macro   name
name    bit     adr.bpos
bpos    set     bpos+1
        if      bpos=8
bpos     set     0
adr      set     adr+1
        endif  
        endm

Another small detail: Intel now prefers CY instead of C as a symbolic
name for the carry, so you might have to rename an already existing
variable of the same name in your program.  However, AS will
continue to understand also the old variant when using the
instructions CLR, CPL, SETB, MOV, ANL, or ORL.  The same is
conceptually true for the additional registers R8..R15, WR0..WR30,
DR0..DR28, DR56, DR60, DPX, and SPX.

Intel would like everyone to write absolute addresses in a syntax of
XX:YYYY, where XX is a 64K bank in the address space resp. signifies
addresses in the I/O space with an 'S'.  As one might guess, I am not
amused about this, which is why it is legal to alternitavely use
linear addresses in all places.  Only the 'S' for I/O addresses is
incircumventable, like in this case:

Carry   bit   s:0d0h.7

Without the prefix, AS would assume an address in the CODE segment,
and only the first 128 bits in this space are bit-addressable...

Like for the 8051, the generic branch instructions CALL and JMP
exist that automatically choose the shortest machine code depending on
the address layout.  However, while JMP also may use the variant with
a 24-bit address, CALL will not do this for a good reason: In
contrast to ACALL and LCALL, ECALL places an additional byte onto the
stack.  A CALL instruction would result where you would not know
what it will do.  This problem does not exist for the JMP
instructions.

There is one thing I did not understand: The 80251 is also able to
push immediate operands onto the stack, and it may push either single
bytes or complete words.  However, the same mnemonic (PUSH) is
assigned to both variants - how on earth should an assembler know if
an instruction like

        push #10

shall push a byte or a word containing the value 10?  So the current
rule is that PUSH always pushes a byte; if one wants to push a word,
simply use PUSHW instead of PUSH.

Another well-meant advise: If you use the extended instruction set,
be sure to operate the processor in source mode; otherwise, all
instructions will become one byte longer!  The old 8051 instructions
that will in turn become one byte longer are not a big matter:  AS
will either replace them automatically with new, more general
instructions or they deal with obsolete addressing modes (indirect
addressing via 8 bit registers).

        4.13. 8086..V35
        ---------------

Actually, I had sworn myself to keep the segment disease of Intel's
8086 out of the assembler.  However, as there was a request and as
students are more flexible than the developers of this processor
obviously were, there is now a rudimentary support of these
processors in AS.  When saying, 'rudimentary', it does not mean that
the instruction set is not fully covered.  It means that the whole
pseudo instruction stuff that is available when using MASM, TASM, or
something equivalent does not exist.  To put it in clear words, AS
was not primarily designed to write assembler programs for PC's
(heaven forbid, this really would have meant reinventing the wheel!);
instead, the development of programs for single-board computers was
the main goal (which may also be equipped with an 8086 CPU).

For die-hards who still want to write DOS programs with AS, here is a
small list of things to keep in mind:

 - Only COM files may be created.
 - Only use the CODE segment, and place also all variables in
   this segment.
 - DOS initializes all segment registers to the code segment.
   An ASSUME DS:DATA, SS:DATA right at the program's beginning
   is therefore necessary.
 - DOS loads the code to a start address of 100h.  An ORG to this
   address is absolutely necessary.
 - The conversion to a binary file is done with P2BIN (see later in
   this document), with an address filter of '$-$'.

For these processors, AS only supports a small programming model, 
i.e. there is ONE code segment with a maximum of 64 Kbytes and a
data segment of equal size for data (which cannot be set to initial
values for COM files).  The SEGMENT instruction allows to switch
between these two segments.  From this facts results that branches
are always intrasegment branches if they refer to targets in this
single code segment.  In case that far jumps should be necessary,
they are possible via CALLF or JMPF with a memory address or a
Segment:Offset value as argument.

Another big problem of these processors is their assembler syntax,
which is sometimes ambiguous and whose exact meaning can then only be
deduced by looking at the current context.  In the following example,
either absolute or immediate addressing may be meant, depending on
the symbol's type:

        mov     ax,value

When using AS, an expression without brackets always is interpreted
as immediate addressing.  For example, when either a variable's
address or its contents shall be loaded, the following differences 
between MASM and AS are present:

assembler    address              contents

MASM         mov ax,offset vari   mov ax,vari
             lea ax,vari          mov ax,[vari]
             lea ax,[vari]

AS           mov ax,vari          mov ax,[vari]
             lea ax,[vari]

When addressing via a symbol, the assembler checks whether they are
assigned to the data segment and tries to automatically insert an
appropriate segment prefix.  This happens for example when symbols
from the code segment are accessed without specifying a CS segment
prefix.  However, this mechanism can only work if the ASSUME
instruction (see there) has previously been applied correctly.

The Intel syntax also requires to store whether bytes or words were
stored at a symbol's address.  AS will do this only when the DB resp.
DW instruction is in the same source line as the label.  For any
other case, the operand size has to be specified explicitly with the
BYTE PTR, WORD PTR,... operators.  As long as a register is the other
operator, this may be omitted, as the operand size is then clearly
given by the register's name.

In an 8086-based system, the coprocessor is usually synchronized via
via the processor's TEST input line which is connected to toe
coprocessor's BUSY output line.  AS supports this type of handshaking
by automatically inserting a WAIT instruction prior to every 8087
instruction.  If this is undesired for any reason, an 'N' has to be
inserted after the 'F' in the mnemonic; for example,

   FINIT            
   FSTSW  [vari]    

becomes

   FNINIT           
   FNSTSW [vari]    

This variant is valid for ALL coprocessor instructions.


        4.14. 8X30x
        -----------

The processors of this family have been optimized for an easy
manipulation of bit groups at peripheral addresses.  The instructions
LIV and RIV were introduced to deal with such objects in a symbolic
fashion.  They work similar to EQU, however they need three
parameters:

 1. the address of the peripheral memory cell that contains the bit
    group (0..255);
 2. the number of the group's first bit (0..7);
 3. the length of the group, expressed in bits (1..8).

CAUTION! The 8X30x does not support bit groups that span over more
than one memory address.  Therefore, the valid value range for the
length can be stricter limited, depending on the start position.  AS
does NOT perform any checks at this point, you simply get strange
results at runtime!

Regarding the machine code, length and position are expressed vis a 3
bit field in the instruction word and a proper register number (LIVx
resp. RIVx).  If one uses a symbolic object, AS will automatically
assign correct values to this field, but it is also allowed to
specify the length explicitly as a third operand if one does not work
with symbolic objects.  If AS finds such a length specification in
spite of a symbolic operand, it will compare both lengths and issue
an error if they do not match (the same will happen for the MOVE
instruction if two symbolic operands with different lengths are used
- the instruction simply only has a single length field...).

Apart from the real machine instructions, AS defines similarly to its
'idol' MCCAP some pseudo instructions that are implemented as builtin
macros:

 - NOP is a shortform for MOVE AUX,AUX
 - HALT is a shortform for JMP *
 - XML ii is a shortform for XMIT ii,R12 (only 8X305)
 - XMR ii is a shortform for XMIT ii,R13 (only 8X305)
 - SEL <busobj> is a shortform for XMIT <adr>,IVL/IVR,
   i.e. it performs the necessary preselection to access <busobj>.

The CALL and RTN instructions MCCAP also implements are currently
missing due to sufficient documentation.  The same is true for a set
of pseudo instructions to store constants to memory.  Time may change
this...


        4.15. XA
        --------

Similar to its predecessor MCS/51, but in contrast to its
'competitor' MCS/251, the Philips XA has a separate address space for
bits, i.e. all bits that are accessible via bit instructions have a
certain, one-dimensional address which is stored as-is in the machine
code.  However, I could not take the obvious opportunity to offer
this third address space (code and data are the other two) as a
separate segment.  The reason is that - in contrast to the MCS/51 -
some bit addresses are ambiguous: bits with an address from 256 to 511
refer to the bits of memory cells 20h..3fh in the current data
segment.  This means that these addresses may correspond to different
physical bits, depending on the current state.  Defining bits with
the help of DC instructions - something that would be possible with a
separate segment - would not make too much sense.  However, the BIT
instruction still exists to define individual bits (regardless if
they are located in a register, the RAM or SFR space) that can then
be referenced symbolically.  If the bit is located in RAM, the
address of the 64K-bank is also stored.  This way, AS can check
whether the DS register has previously be assigned a correct value
with an ASSUME instruction.

The XA uses the same instructions for storage of constants like the
68000 family.  This however means that by default, the number of
bytes stored will be rounded up to an even value.  Even addresses are
not a must on the XA, so a 'PADDING OFF' instruction right at the
beginning of a program is almost obligatory...

In contrast, nothing can stop AS's efforts to align potential branch
targets to even addresses.  Like other XA assemblers, AS does this by
inserting NOPs right before the instruction in question.


        4.16. Z80UNDOC
        --------------

As one might guess, Zilog did not make any syntax definitions for the
undocumented instructions; furthermore, not everyone might know the
full set.  It might therefore make sense to list all instructions at
this place:

Similar to a Z380, it is possible to access the byte halves of IX and
IY separately.  In detail, these are the instructions that allow
this:

 INC Rx              LD R,Rx             LD  Rx,n
 DEC Rx              LD Rx,R             LD  Rx,Ry
 ADD/ADC/SUB/SBC/AND/XOR/OR/CP A,Rx 

Rx and Ry are synonyms for IXL, IXU, IYL or IYU.  Keep however in
mind that in the case of 'LD  Rx,Ry', both registers must be part
of the same index register.

The coding of shift instructions leaves an undefined bit combination
which is now accessible as the SLIA instruction.  SLIA works like
SLA with the difference of entering a 1 into bit position 0.  Like
all other shift instructions, SLIA also allows another undocumented
variant:

 SLIA R,(XY+d)                      

In this case, R is an arbitrary 8-bit register (excluding index
register halves...), and (XY+d) is a normal indexed address.  This
operation has the additional effect of copying the result into the
register.  This also works for the RES and SET instructions:

 SET/RES R,n,(XY+d)                 

Furthermore, two hidden I/O instructions exist:

 IN (C) resp. TSTI
 OUT (C),0

Their operation should be clear.  CAUTION!  Noone can guarantee that
all mask revisions of the Z80 execute these instructions, and the
Z80's successors will react with traps if they find one of these
instructions.  Use them on your own risk...


	4.17. Z380
        ----------

As this processor was designed as a grandchild of the still most
popular 8-bit microprocessor, it was a sine-qua-non design target to
execute existing Z80 programs without modification (of course, they
execute a bit faster, roughly by a factor of 10...).  Therefore, all
extended features can be enabled after a reset by setting two bits
which are named XM (eXtended Mode, i.e. a 32-bit instead of a 16-bit
address space) respectively LW (long word mode, i.e. 32-bit instead
of 16-bit operands).  One has to inform AS about their current
setting with the instructions EXTMODE resp. LWORDMODE, to enable AS
to check addresses and constants against the correct upper limits. 
The toggle between 32- and 16-bit instruction of course only
influences instructions that are available in a 32-bit variant. 
Unfortunately, the Z380 currently offers such variants only for load
and store instructions; arithmetic can only be done in 16 bits. 
Zilog really should do something about this, otherwise the most
positive description for the Z380 would be "16-bit processor with
32-bit extensions"...

The whole thing becomes complicated by the ability to override the
operand size set by LW with the instruction prefixes DDIR W resp. DDIR
LW.  AS will note the occurrence of such instructions and will toggle
setting for the instruction following directly.  By the way, one
should never explicitly use other DDIR variants than W resp. LW, as AS
will introduce them automatically when an operand is discovered that
is too long.  Explicit usage might puzzle AS.  The automatism is so
powerful that in a case like this:

        DDIR    LW
        LD      BC,12345678h   ,

the necessary IW prefix will automatically be merged into the previous
instruction, resulting in

        DDIR    LW,IW
        LD      BC,12345668h   .

The machine code that was first created for DDIR LW is retracted and
replaced, which is signified with an 'R' in the listing.


        4.18. TLCS-900(L)
        -----------------

These processors may run in two operating modes: on the one hand, in
minimum mode, which offers almost complete source code compatibility
to the Z80 and TLCS-90, and on the other hand in maximum mode, which
is necessary to make full use of the processor's capabilities.  The
main differences between these two modes are:

 - width of the registers WA, BC, DE, and HL: 16 or 32 bits;
 - number of register banks: 8 or 4;
 - code address space: 64 Kbytes or 16 Mbytes;
 - length of return addresses: 16 or 32 bits.

To allow AS to check against the correct limits, one has to inform
him about the current execution mode via the MAXMODE instruction (see
there).  The default is the minimum mode.

From this follows that, depending on the operating mode, the 16-bit
resp. 32-bit versions of the bank registers have to be used for
addressing, i.e. WA, BC, DE and HL for the minimum mode resp. XWA,
XBC, XDE and XHL for the maximum mode.  The registers XIX..XIZ and
XSP are ALWAYS 32 bits wide and therefore always have to to be used
in this form for addressing; in this detail, existing Z80 code
definitely has to be adapted (not including that there is no I/O
space and all I/O registers are memory-mapped...).

The syntax chosen by Toshiba is a bit unfortunate in the respect of
choosing an single quote (') to reference the previous register bank. 
The processor independent parts of AS already use this character to
mark character constants.  In an instruction like

  ld wa',wa   ,

AS will not recognize the comma for parameter separation.  This
problem can be circumvented by usage of an inverse single quote (`), for
example

  ld wa`,wa                              

Toshiba delivers an own assembler for the TLCS-900 series (TAS900),
which is different from AS in the following points:

    Symbol Conventions

 - TAS900 differentiates symbol names only on the first 32
   characters.  In contrast, AS always stores symbol names with the
   full length (up to 255 characters) and uses them all for
   differentiation.

 - TAS900 allows to write integer constants either in Intel or C
   notation (with a 0 prefix for octal or a 0x prefix for hexadecimal
   constants).  By default, AS only supports the Intel notation. 
   With the help of the RELAXED instruction, one also gets the C
   notation (among other).

 - AS does not distinguish between upper and lower case.  In
   contrast, TAS900 differentiates between upper- and lowercase
   letters in symbol names.  One needs to engage the -u command
   line option to force AS to do this.

    Syntax

For many instructions, the syntax checking of AS is less strict than
the checking of TAS900.  In some (rare) cases, the syntax is slightly
different.  These extensions and changes are on the one hand for the
sake of a better portability of existing Z80 codes, on the other hand
they provide a simplification and better orthogonality of the
assembly syntax:

 - In the case of LDA, JP, and CALL, TAS requires that address
   expressions like XIX+5 must not be placed in parentheses, as it
   is usually the case.  For the sake of better orthogonality, AS
   requires parentheses for LDA.  They are optional if JP resp. CALL
   are used with a simple, absolute address.

 - In the case of JP, CALL, JR, and SCC, AS leaves the choice to the
   programmer whether to explicitly write out the default condition
   "T" (= true) as first parameter or not.  TAS900 in contrast only
   allows to use the default condition implicitly (e.g. jp (xix+5)
   instead of jp t,(xix+5)).

 - For the EX instruction, AS allows operand combinations which are
   not listed in [Tosh900] but can be reduced to a standard
   combination by swapping the operands.  Combinations like EX f`,f
   or EX wa,(xhl) become possible.  In contrast, TAS900 limits to
   the 'pure' combinations.

 - AS allows to omit an increment resp. decrement of 1 when using the
   instructions INC and DEC.  TAS900 instead forces the programmer to
   explicit usage of '1'.

 - The similar is true for the shift instructions: If the operand is
   a register, TAS900 requires that even a shift count of 1 has to
   be written explicitly; however, when the operand is in memory,
   the hardware limits the shift count to 1 which must not be written
   in this case.  With AS, a shift count of 1 is always optional and
   valid for all types of operands.

    Macro Processor

The macro processor of TAS900 is an external program that operates
like a preprocessor.  It consists of two components: The first one is
a C-like preprocessor, and the second one is a special macro language
(MPL) that reminds of high level languages.  The macro processor of
AS instead is oriented towards "classic" macro assemblers like MASM
or M80 (both programs from Microsoft).  It is a fixed component of
AS.

    Output Format

TAS900 generates relocatable code that allows to link separately
compiled programs to a single application.  AS instead generates
absolute machine code that is not linkable.  There are currently no
plans to extend AS in this respect.

    Pseudo Instructions

Due to the missing linker, AS lacks a couple of pseudo instructions
needed for relocatable code TAS900 implements.  The following
instructions are available with equal meaning:

   EQU, DB, DW, ORG, ALIGN, END, TITLE, SAVE, RESTORE

The latter two have an extended functionality for AS.  Some TAS900
pseudo instructions can be replaced with equivalent AS instructions:

TAS900         AS                   meaning/function

DL <Data>      DD <Data>            define longword constants
DSB <number>   DB <number> DUP (?)  reserve bytes of memory
DSW <number>   DW <number> DUP (?)  reserve words of memory
DSD <number>   DD <number> DUP (?)  reserve longwords of memory
$MIN[IMUM]     MAXMODE OFF          following code runs in minimum mode
$MAX[IMUM]     MAXMODE ON           following code runs in maximum mode
$SYS[TEM]      SUPMODE ON           following code runs in system mode
$NOR[MAL]      SUPMODE OFF          following code runs in user mode
$NOLIST        LISTING OFF          turn off assembly listing
$LIST          LISTING ON           turn on assembly listing
$EJECT         NEWPAGE              start new page in listing

Toshiba manufactures two versions of the processor core, with the L
version being an "economy version".  AS will make the following
differences between TLCS-900 and TLCS-900L:

 - The instructions MAX and NORMAL are not allowed for the L version;
   the MIN instruction is disabled for the full version.
 - The L version does not know the normal stack pointer XNSP/NSP, but
   instead has the interrupt nesting register INTNEST.

The instructions SUPMODE and MAXMODE are not influenced, just as
their initial setting OFF.  The programmer has to take care of the
fact that the L version starts in maximum mode and does not have a
normal mode.  However, AS shows a bit of mercy against the L variant
by suppressing warnings for privileged instructions.


	4.19. TLCS-90
        -------------

Maybe some people might ask themselves if I mixed up the order a
little bit, as Toshiba first released the TLCS-90 as an extended Z80
and afterwards the 16-bit version TLCS-900.  Well, I discovered the
'90 via the '900 (thank you Oliver!).  The two families are quite
similar, not only regarding their syntax but also in their
architecture.  The hints for the '90 are therefore a subset of of the
chapter for the '900: As the '90 only allows shifts, increments, and
decrements by one, the count need not and must not be written as the
first argument.  Once again, Toshiba wants to omit parentheses for
memory operands of LDA, JP, and CALL, and once again AS requires them
for the sake of orthogonality (the exact reason is of course that
this way, I saved an extra in the address parser, but one does not
say such a thing aloud).

Principally, the TLCS-90 series already has an address space of 1
Mbyte which is however only accessible as data space via the index
registers.  AS therefore does not regard the bank registers and
limits the address space to 64 Kbytes.  This should not limit too
much as this area above is anyway only reachable via indirect
addressing.


        4.20. TLCS-870
        --------------

Once again Toshiba...a company quite productive at the moment! 
Especially this branch of the family (all Toshiba microcontrollers
are quite similar in their binary coding and programming model) seems
to be targeted towards the 8051 market: the method of separating the
bit position from the address expression with a dot had its root in
the 8051.  However, it creates now exactly the sort of problems I
anticipated when working on the 8051 part: On the one hand, the dot
is a legal part of symbol names, but on the other hand, it is part of
the address syntax.  This means that AS has to separate address and
bit position and must process them independently.  Currently, I
solved this conflict by seeking the dot starting at the END of the
expression.  This way, the last dot is regarded as the separator, and
further dots stay parts of the address.   I continue to urge everyone
to omit dots in symbol names, they will lead to ambiguities:

   LD    CF,A.7         ; accumulator bit 7 to carry
   LD    C,A.7          ; constant 'A.7' to accumulator


	4.21. TLCS-47
        -------------

This family of 4-bit microcontrollers should mark the low end of what
is supportable by AS.  Apart from the ASSUME instruction for the data
bank register (see there), there is only one thing that is worth
mentioning: In the data and I/O segment, nibbles are reserved instead
of byte (it's a 4-bitter...).  The situation is similar to the bit
data segment of the 8051, where a DB reserves a single bit, with the
difference that we are dealing with nibbles.

Toshiba defined an "extended instruction set" for this processor
family to facilitate the work with their limited instruction set.  In
the case of AS, it is defined in the include file STDDEF47.INC. 
However, some instructions that could not be realized as macros are
"builtins" and are therefore also available without the include file:

 - the B instruction that automatically chooses the optimal version
   of the jump instruction (BSS; BS, or BSL);
 - LD in the variant of HL with an immediate operand;
 - ROLC and RORC with a shift amplitude higher than one.


        4.22. TLCS-9000
        ---------------

This is the first time that I implemented a processor for AS which
was not available at that point of time.  Unfortunately, Toshiba
decided to put this processor "on ice", so we won't see any silicon
in the near future.  This has of course the result that this part

 1. is a "paper design", i.e. there was so far no chance to test
    it in the reality and
 2. the documentation for the '9000 I could get hold of [Tosh9000]
    were preliminary, so they could not deliver clarity on every
    detail.

Therefore, errors in this code generator are quite possible (and will
of course be fixed if it should ever become possible!).  At least the
few examples listed in [Tosh9000] are assembled correctly.


        4.23. 29xxx
        -----------

As it was already described in the discussion of the ASSUME
instruction, AS can use the information about the current setting of
the RBP register to detect accesses to privileged registers in user
mode.  This ability is of course limited to direct accesses (i.e.
without using the registers IPA...IPC), and there is one more
pitfall: as local registers (registers with a number >127) are
addressed relative to the stack pointer, but the bits in RBP always
refer to absolute numbers, the check is NOT done for local registers. 
An extension would require AS to know always the absolute value of
SP, which would at least fail for recursive subroutines...

   
        4.24. 80C16x
        ------------

As it was already explained in the discussion of the ASSUME
instruction, AS tries to hide the fact that the processor has more
physical than logical RAM as far as possible.  Please keep in mind
that the DPP registers are valid only for data accesses and only have
an influence on absolute addressing, neither on indirect nor on indexed
addresses.  AS cannot know which value the computed address may take
at runtime...
The paging unit unfortunately does not operate for code accesses so
one has to work with explicit long or short CALLs, JMPs, or RETs.  At
least for the "universal" instructions CALL and JMP, AS will
automatically use the shortest variant, but at least for the RET one
should know where the call came from.  JMPS and CALLS principally
require to write segment and address separately, but AS is written in
a way that it can split an address on its own, e.g. one can write

   jmps   12345h

instead of

   jmps   1,2345h

Unfortunately, not all details of the chip's internal instruction
pipeline are hidden: if CP (register bank address), SP (stack), or
one of the paging registers are modified, their value is not
available for the instruction immediately following.  AS tries to
detect such situations and will issue a warning in such cases.  Once
again, this mechanism only works for direct accesses.

Bits defined with the BIT instruction are internally stored as a
12-bit word, containing the address in bits 4..11 and the bit
position in the four LSBs.  This order allows to refer the next resp.
previous bit by incrementing or decrementing the address.  This will
however not work for explicit bit specifications when a word boundary
is crossed.  For example, the following expression will result in a
range check error:

   bclr   r5.15+1

We need a BIT in this situation:

msb bit   r5.15
    .
    .
    bclr  msb+1

The SFR area was doubled for the 80C167/165/163: bit 12 flags that a
bit lies in the second part.  Siemens unfortunately did not foresee
that 256 SFRs (128 of them bit addressable) would not suffice for
successors of the 80C166.  As a result, it would be impossible to
reach the second SFR area from F000H..F1DFH with short addresses or
bit instructions if the developers had not included a toggle
instruction:

  EXTR #n

This instruction has the effect that for the next n instructions
(0<n<5), it is possible to address the alternate SFR space instead of
the normal one.  AS does not only generate the appropriate machine
code when it encounters this instruction.  It also sets an internal
flag that will only allow accesses to the alternate SFR space for
the next n instructions.  Of course, they may not contain jumps...
Of course, it is always possible to define bits from either area at
any place, and it is always possible to reach all registers with
absolute addresses.  In contrast, short and bit addressing only works
for one area at a time, attempts contradicting to this will result in
an error message.

The situation is similar for prefix instructions and absolute resp.
indirect addressing: as the prefix argument and the address
expression cannot always be evaluated at assembly time, chances for
checking are limited and AS will limit itself to warnings...in
detail, the situation is as follows:

 - fixed specification of a 64K bank with EXTS or EXTSR: the address
   expression directly contains the lower 16 bits of the target
   address.  If the prefix and the following instruction have a
   constant operand, AS will check if the the prefix argument and bits
   16..23 of the target address are equal.

 - fixed specification of a 16K page with EXTP or EXTPR: the address
   expression directly contains the lower 14 bits of the target
   address.  Bits 14 and 15 are fixed to 0, as the processor ignores
   them in this mode.  If the prefix and the following instruction
   have a constant operand, AS will check if the the prefix argument
   and bits 14..23 of the target address are equal.

An example to clarify things a bit (the DPP registers have their
reset values):

        extp    #7,#1           ; range from 112K..128K
        mov     r0,1cdefh       ; results in address 0defh in code
        mov     r0,1cdefh       ; -->warning
        exts    #1,#1           ; range from 64K..128K
        mov     r0,1cdefh       ; results in address 0cdefh in code
        mov     r0,1cdefh       ; -->warning


        4.25. PIC16C5x/16C8x
        --------------------

Similar to the MCS-48 family, the PICs split their program memory
into several banks because the opcode does not offer enough space for
a complete address.  AS uses the same automatism for the instructions
CALL and GOTO, i.e. the PA bits in the status word are set according
to the start and target address.  However, this procedure is far more
problematic compared to the 48's:

  1. The instructions are not any more one word long (up to three
     words).  Therefore, it is not guaranteed that they can be 
     skipped with a conditional branch.
  2. It is possible that the program counter crosses a page boundary
     while the program sequence is executed.  The setting of PA bits
     AS assumes may be different from reality.

The instructions that operate on register W and another register
normally require a second parameter that specifies whether the result
shall be stored in W or the register.  Under AS, it is valid to omit
the second parameter.  The assumed target then depends upon the
operation's type: For unary operations, the result is by default
stored back into the register.  These instructions are:

    COMF, DECF, DECFSZ, INCF, INCFSZ, RLF, RRF, and SWAPF

The other operations by default regard W as an accumulator:

    ADDWF, ANDWF, IORWF, MOVF, SUBWF, and XORWF

The syntax defined by Microchip to write literals is quite obscure
and reminds of the syntax used on IBM 360/370 systems (greetings from
the stone-age...).  To avoid introducing another branch into the
parser, with AS one has to write constants in the Motorola syntax
(optionally Intel or C in RELAXED mode).


        4.26. PIC 17C4x
        ---------------

With two exceptions, the same hints are valid as for its two smaller
brothers: the corresponding include file only contains register
definitions, and the problems concerning jump instructions are much
smaller.  The only exception is the LCALL instruction, which allows a
jump with a 16-bit address.  It is translated with the following
"macro":

   MOVLW <addr15..8>   
   MOWF  3
   LCALL <addr0..7>


        4.27. ST62xx  
        ------------  

These processors have the ability to map their code ROM pagewise into
the data area.  I am not keen on repeating the whole discussion of
the ASSUME instruction at this place, so I refer to the corresponding
section for an explanation how to read constants out of the code ROM
without too much headache.

Some builtin "macros" show up when one analyzes the instruction set a
bit more in detail.  Here is a list of the instructions I found
(there are probably even more...):

    instruction in reality

    CLR A       SUB A,A 
    SLA A       ADD A,A 
    CLR addr    LDI addr,0
    NOP         JRZ PC+1

Especially the last case is a bit astonishing...unfortunately, some
instructions are really missing.  For example, there is an AND
instruction but no OR...not to speak of an XOR.  For this reason, the
include file STDDEF62.INC contains also some helping macros
(additionally to register definitions).

The original assembler AST6 delivered by SGS-Thomson partially uses
different pseudo instructions than AS.  Apart from the fact that AS
does not mark pseudo instructions with a leading dot, the following
instructions are identical:

  ASCII, ASCIZ, BLOCK, BYTE, END, ENDM, EQU, ERROR, MACRO,
  ORG, TITLE, WARNING 

The following instructions have AS counterparts with similar
function:

     AST6            AS                 meaning/function

     .DISPLAY        MESSAGE            output message
     .EJECT          NEWPAGE            new page in assembly listing
     .ELSE           ELSEIF             conditional assembly
     .ENDC           ENDIF              conditional assembly
     .IFC            IF...              conditional assembly
     .INPUT          INCLUDE            insert include file
     .LIST           LISTING, MACEXP    settings for listing
     .PL             PAGE               page length of listing
     .ROMSIZE        CPU                set target processor
     .VERS
     .SET            EVAL               redefine variables


        4.28. ST7
        ---------

In [ST7Man], the '.w' postfix to signify 16-bit addresses is only
defined for memory indirect operands.  It is used to mark that a
16-bit address is stored at a zero page address.  AS additionally
allows this postfix for absolute addresses or displacements of
indirect address expressions to force 16-bit displacements in spite
of an 8-bit value (0..255).


        4.29. ST9
        ---------

The ST9's bit addressing capabilities are quite limited: except for
the BTSET instruction, only bits within the current set of working
registers are accessible.  A bit address is therefore of the
following style:

  rn.[!]b   ,

whereby ! means an optional complement of a source operand.  If a bit
is defined symbolically, the bit's register number is stored in bits
7..4, the bit's position is stored in bits 3..1 and the optional
complement is kept in bit 0.  AS distinguishes explicit and symbolic
bit addresses by the missing dot.  A bit's symbolic name therefore
must not contain a dot, thought it would be legal in respect to the
general symbol name conventions.  It is also valid to invert a
symbolically referred bit:

bit2    bit     r5.3  
        .
        .
        bld     r0.0,!bit2

This opportunity also allows to undo an inversion that was done at
definition of the symbol.

The include file REGST9.INC defines the symbolic names of all on-chip
registers and their associated bits. Keep however in mind that the
bit definitions only work after previously setting the working
register bank to the address of these peripheral registers!

In contrast to the definition file delivered with the AST9 assembler
from SGS-Thomson, the names of peripheral register names are only
defined as general registers (R...), not also as working registers
(r...).  The reason for this is that AS does not support register
aliases; a tribute to assembly speed.


        4.30. 6804
        ----------

To be honest: I only implemented this processor in AS to quarrel
about SGS-Thomson's peculiar behaviour.  When I first read the 6804's
data book, the "incomplete" instruction set and the built-in macros
immediately reminded me of the ST62 series manufactured by the same
company.  A more thorough comparison of the opcodes gave surprising
insights: A 6804 opcode can be generated by taking the equivalent
ST62 opcode and mirroring all the bits!  So Thomson obviously did a
bit of processor core recycling...which would be all right if they
would not try to hide this:  different peripherals, motorola instead
of Zilog-style syntax, and the awful detail of NOT mirroring operand
fields in the opcode (e.g. bit fields containing displacements).  The
last item is also the reason that finally convinced me to support the
6804 in AS.  I personally can only guess which department at Thomson
did the copy...

In contrast to its ST62 counterpart, the include file for the 6804
does not contain instruction macros that help a bit to deal with the
limited machine instruction set.  This is left as an exercise to the
reader!


        4.31. TMS3201x
        --------------

It seems that every semiconductor's ambition is to invent an own
notation for hexadecimal numbers.  Texas Instrument took an
especially eccentric approach for these processors: a '>' sign as
prefix!  The support of such a format in AS would have lead to
extreme conflicts with AS's compare and shift operators.  I therefore
decided to use the Intel notation, which is what TI also uses for the
340x0 series and the 3201x's successors...

The instruction word of these processors unfortunately does not have
enough bits to store all 8 bits for direct addressing.  This is why
the data address space is split into two banks of 128 words.  AS
principally regards the data address space as a linear segment of 256
words and automatically clears bit 7 on direct accesses (an exception
is the SST instruction that can only write to the upper bank).  The
programmer has to take care that the bank flag always has the correct
value!

Another hint that is well hidden in the data book: The SUBC
instruction internally needs more than one clock for completion, but
the control unit already continues to execute the next instruction. 
An instruction following SUBC therefore may not access the
accumulator.  AS does not check for such conditions!


        4.32. TMS320C2x
        ---------------
            
As I did not write this code generator myself (that does not lower
its quality by any standard), I can only roughly line out why there
are some instructions that force a prefixed label to be untyped, i.e.
not assigned to any specific address space: The 2x series of TMS
signal processors has a code and a data segment which are both 64
Kbytes large.  Depending on external circuitry, code and data space may
overlap, e.g. to allow storage of constants in the code area and
access them as data.  Data storage in the code segment may be
necessary because older versions of AS assume that the data segment
only consists of RAM that cannot have a defined power-on state in a
single board system.  They therefore reject storage of contents in
other segments than CODE.  Without the feature of making symbols
untyped, AS would punish every access to a constant in code space
with a warning ("symbol out of wrong segment").  To say it in detail,
the following instructions make labels untyped:

  BSS, STRING, RSTRING, BYTE, WORD , LONG, FLOAT
  DOUBLE, EFLOAT, BFLOAT and TFLOAT

If one needs a typed label in front of one of these instructions, one
can work around this by placing the label in a separate line just
before the pseudo instruction itself.  On the other hand, it is
possible to place an untyped label in front of another pseudo
instruction by defining the label with EQU, e.g.

<name>  EQU     $        .


        4.33. TMS320C3x
        ---------------

The syntax detail that created the biggest amount of headache for me
while implementing this processor family is the splitting of parallel
instructions into two separate source code lines.  Fortunately, both
instructions of such a construct are also valid single instructions. 
AS therefore first generates the code for the first instruction and
replaces it by the parallel machine code when a parallel construct is
encountered in the second line.  This operation can be noticed in the
assembly listing by the machine code address that does not advance
and the double dot replaced with a "R".

Compared to the TI assembler, AS is not as flexible regarding the
position of the double lines that signify a parallel operation
('||'): One either has to place them like a label (starting in the
first column) or to prepend them to the second mnemonic.  The line
parser of AS will run into trouble if you do something else... 


        4.34. TMS9900
        -------------

Similar to most older TI microprocessor families, TI used an own
format for hexadecimal and binary constants.  AS instead favours the
Intel syntax which is also common for newer processor designs from
TI.

The documentation I had available [TI9900] unfortunately discussed
the processor's assembly syntax only as a side issue.  I therefore
had to guess at some places...for example the order of operands: I
selected to assume the source as first operand; this is the way other
TI microcontrollers also do it.  Further more, TI sometimes uses Rx
to name registers and WRx at other places...currently both variants
are recognized by AS.


        4.35. TMS70Cxx
        --------------

This processor family belongs to the older families developed by TI
and therefore TI's assemblers use their proprietary syntax for
hexadecimal resp. binary constants (a prefixed < resp. ? character). 
As this format could not be realized for AS, the Intel syntax is used
by default.  This is the format TI to which also switched over when
introducing the successors, of this family, the 370 series of
microcontrollers.  Upon a closer inspection of both's machine
instruction set, one discovers that about 80% of all instruction are
binary upward compatible, and that also the assembly syntax is almost
identical - but unfortunately only almost.  TI also took the chance to
make the syntax more orthogonal and simple.  I tried to introduce
the majority of these changes also into the 7000's instruction set:

- It is valid to use the more common # sign for immediate addressing
  instead of the percent sign.

- If a port address (P...) is used as source or destination in a 
  AND, BTJO, BTJZ, MOV, OR, or XOR instruction, it is not necessary
  to use the mnemonic variant with an appended 'P' - the general
  form is sufficient.

- The prefixed @ sign for absolute or B-relative addressing may be
  omitted.

- Instead of CMPA, CMP with A as target may be written.

- Instead of LDA resp. STA, one can simply use the MOV instruction
  with A as source resp. destination.

- One can write MOVW instead of MOVD.

- It is valid to abbreviate RETS resp. RETI as RTS resp. RTI.

- TSTA resp. TSTB may be written as TST A resp. TST B.

- XCHB B is an alias for TSTB.

An important note: these variants are only allowed for the TMS70Cxx -
the corresponding 7000 variants are not allowed for the 370 series!


        4.36. TMS370xxx
        ---------------

Though these processors do not have specialized instructions for bit
manipulation, the assembler creates (with the help of the DBIT
instruction - see there) the illusion as if single bits were
addressable.  To achieve this, the DBIT instructions stores an
address along with a bit position into an integer symbol which may
then be used as an argument to the pseudo instructions SBIT0, SBIT1,
CMPBIT, JBIT0, and JBIT1.  These are translated into the instructions
OR, AND, XOR, BTJZ, and BTJO with an appropriate bit mask.

There is nothing magic about these bit symbols, they are simple
integer values that contain the address in their lower and the bit
position in their upper half.  One could construct bit symbols
without the DBIT instruction, like this:

defbit  macro   name,bit,addr
name    equ     addr+(bit<<16)
        endm

but this technique would not lead to the EQU-style syntax defined by
TI (the symbol to be defined replaces the label field in a line). 
CAUTION! Though DBIT allows an arbitrary address, the pseudo
instructions can only operate with addresses either in the range from
0..255 or 1000h..10ffh.  The processor does not have an absolute
addressing mode for other memory ranges...


        4.37. MSP430
        ------------

The MSP was designed to be a RISC processor with a minimal power
consumption.  The set of machine instructions was therefore reduced
to the absolute minimum (RISC processors do not have a microcode ROM
so every additional instruction has to be implemented with additional
silicon that increases power consumption).  A number of instructions
that are hardwired for other processors are therefore emulated with
other instructions.  For AS, these instructions are defined in the
include file REGMSP.INC.  You will get error messages for more than
half of the instructions defined by TI if you forget to include this
file!

        4.38. COP8 & SC/MP
        ------------------

National unfortunately also decided to use the syntax well known from
IBM mainframes (and much hated by me..) to write non-decimal integer
constants.  Just like with other processors, this does not work with
AS's parser.  ASMCOP however fortunately also seems to allow the C
syntax, which is why this became the default for the COP series and
the SC/MP...


        4.39. 75K0
        ----------

Similar to other processors, the assembly language of the 75 series
also knows pseudo bit operands, i.e. it is possible to assign a
combination of address and bit number to a symbol that can then be
used as an argument for bit oriented instructions just like explicit
expressions.  The following three instructions for example generate
the same code:

ADM     sfr     0fd8h
SOC     bit     ADM.3

        skt     0fd8h.3
        skt     ADM.3
        skt     SOC

AS distinguishes direct and symbolic bit accesses by the missing dot
in symbolic names; it is therefore forbidden to use dots in symbol
names to avoid misunderstandings in the parser.

The storage format of bit symbols mostly accepts the binary coding in
the machine instructions themselves:  16 bits are used, and there is
a "long" and a "short" format.  The short format can store the
following variants:

 - direct accesses to the address range from 0FBxH to 0FFxH
 - indirect accesses in the style of Addr.@L (0FC0H <= Addr <= 0FFFH)
 - indirect accesses in the style of @H+d4.bit

The upper byte is set to 0, the lower byte contains the bit
expression coded according to [NEC75].  The long format in contrast
only knows direct addressing, but it can cover the whole address space
(given a correct setting of MBS and MBE).  A long expression stores
bits 0..7 of the address in the lower byte, the bit position in bits
8 and 9, and a constant value of 01 in bits 10 and 11.  The highest
bits allow to distinguish easily between long and short addresses via
a check if the upper byte is 0.  Bits 12..15 contain bits 8..11 of
the address; they are not needed to generate the code, but they have
to be stored somewhere as the check for correct banking can only
take place when the symbol is actually used.


        4.40. 78K0
        ----------

NEC uses different ways to mark absolute addressing in its data
books: 

 - absolute short: no prefix
 - absolute long: prefix of !
 - PC relative: prefix of $

Under AS, these prefixes are only necessary if one wants to force a
certain addressing mode and the instruction allows different
variants.  Without a prefix, AS will automatically select the shortest
variant.  It should therefore rarely be necessary to use a prefix in
practice.


        5. File Formats
        ===============

In this chapter, the formats of files AS generates shall be explained
whose formats are not self-explanatory.

        5.1. Code Files
        ---------------

The format for code files generated by the assembler must be able to
separate code parts that were generated for different target
processors; therefore, it is a bit different from most other formats. 
Though the assembler package contains tools to deal with code files,
I think is a question of good style to describe the format in short:

If a code file contains multibyte values, they are stored in little
endian order.  This rule is already valid for the 16-bit magic word
$1489, i.e. every code file starts with the byte sequence $89/$14.

This magic word is followed by an arbitrary number of "records".  A
record may either contain a continuous piece of the code or certain
additional information.  Even without switching to different
processor types, a file may contain several code-containing records,
in case that code or constant data areas are interrupted by reserved
memory areas that should not be initialized.  This way, the assembler
tries to keep the file as short as possible.

Common to all records is a header byte which defines the record's type
and its contents.  Written in a PASCALish way, the record structure
can be described in the following way:

FileRecord = RECORD CASE Header:Byte OF
              $00:(Creator:ARRAY[] OF Char);
              $01..
              $7f:(StartAdr : LongInt;
                   Length   : Word;
                   Data     : ARRAY[0..Length-1] OF Byte);
              $80:(EntryPoint:LongInt);
              $81:(Header   : Byte;
                   Segment  : Byte;
                   Gran     : Byte;
                   StartAdr : LongInt;
                   Length   : Word;
                   Data     : ARRAY[0..Length-1] OF Byte);
             END

This description does not express fully that the length of data
fields is variable and depends on the value of the 'Length' entries.

A record with a header byte of $81 is a record that may contain code
or data from arbitrary segments.  The first byte (Header) describes
the processor family the following code resp. data was generated for:

    header  family                header  family

    $01     680x0, 683xx          $05     PowerPC
    $09     DSP56000              $11     65xx/MELPS-740
    $12     MELPS-4500            $13     M16
    $14     M16C                  $19     65816/MELPS-7700      
    $21     MCS-48                $29     29xxx                 
    $31     MCS-(2)51             $32     ST9
    $33     ST7                   $39     MCS-96/196/296
    $3a     8X30x                 $3b     AVR
    $3c     XA                    $41     8080/8085
    $42     8086..V35             $48     TMS9900
    $49     TMS370xxx             $4a     MSP430
    $4c     80C166/167            $51     Z80/180/380
    $52     TLCS-900              $53     TLCS-90
    $54     TLCS-870              $55     TLCS-47
    $56     TLCS-9000             $61     6800, 6301 or 6811
    $62     6805/HC08             $63     6809
    $64     6804                  $65     68HC16
    $66     68HC12                $68     H8/300(H)
    $69     H8/500                $6c     SH7000
    $6e     SC/MP                 $6f     COP8
    $70     PIC16C8x              $71     PIC16C5x
    $72     PIC17C4x              $73     TMS7000
    $74     TMS3201x              $75     TMS320C2x
    $76     TMS320C3x             $77     TMS320C5x
    $78     ST62xx                $79     Z8
    $7a     µPD78(C)10            $7b     75K0
    $7c     78K0

The Segment field signifies the address space the following code
belongs to.  The following vaules are defined:

    number  segment               number  segment

    $00     <undefined>           $01     CODE
    $02     DATA                  $03     IDATA
    $04     XDATA                 $05     YDATA
    $06     BDATA                 $07     IO                    
    $08     REG

The Gran field describes the code's "granularity, i.e. the size of
the smallest addressable unit in the following set of data.  This
value is a function of processor type and segment and is an important
parameter for the interpretation of the following two fields that
describe the block's start address and its length: While the start
address refers to the granularity, the 'Length' value is always
expressed in bytes!  For example, if the start address is $300 and
the length is 12, the resulting end address would be $30b for a
granularity of 1, however $303 for a granularity of 4!  Granularities
that differ from 1 are rare and mostly appear in DSP CPU's that are
not designed for byte processing.  For example, a DSP56K's address
space is organized in 64 Kwords of 16 bits.  The resulting storage
capacity is 128 Kbytes, however it is organized as 2^16 words that
are addressed with addresses 0,1,2,...65535!

The start address is always 32 bits in size, independent of the
processor family.  In contrast, the length specification has only 16
bits, i.e. a record may have a maximum length of 4+4+2+(64K-1) =
65545 bytes.

Data records with a Header ranging from $01 to $7f present a shortcut
and preserve backward compatibility to earlier definitions of the
file format: in their case, the Header directly defines the processor
type, the target segment is fixed to CODE and the granularity is
implicitly given by the processor type, rounded up to the next power
of two.  AS prefers to use these records whenever data or code should
go into the CODE segment.

A record with a Header of $80 defines an entry point, i.e. the
address where execution of the program should start.  Such a record
is the result of an END statement with a corresponding address as
argument.

The last record in a file bears the Header $00 and has only a string
as data field.  This string does not have an explicit length
specification; its end is equal to the file's end.  The string
contains only the name of the program that created the file and has
no further meaning.


        5.2. Debug Files
        ----------------

Debug files may optionally be generated by AS.  They deliver
important information for tools used after assembly, like
disassemblers or debuggers.  This information is split into three
groups:

 - symbol table

 - memory usage per section

 - machine addresses of source lines

The second item is listed first in the file.  A single entry in this
list consists of two numbers that are separated by a ':' character:

 <line number>:<address>

Such an entry states that the machine code generated for the source
statement in a certain line is stored at the mentioned address
(written in hexadecimal notation).  With such an information, a
debugger can display the corresponding source lines while stepping
through a program.  As a program may consist of several include
files, and due to the fact that a lot of processors have more than
one address space (though admittedly only one of them is used to
store executable code), the entries described above have to be
sorted.  AS does this sorting in two levels: The primary sorting
criteria is the target segment, and the entries in one of these
sections are sorted according to files.  The sections resp.
subsections are separated by special lines in the style of

Segment <segment name>

resp.

File <file name>   .

The source line info is followed by the symbol table.  Similar to the
source line info, the symbol table is primarily sorted by the
segments individual symbols are assigned to.  In contrast to the
source line info, an additional section NOTHING exists which contains
the symbols that are not assigned to any specific segment (e.g.
symbols that have been defined with a simple EQU statement).  A
section in the symbol table is started with a line of the following
type:

Symbols in Segment <segment name>

The symbols in a section are sorted according to the alphabetical
order of their names, and one symbol entry consists of exactly one
line.  Such a line consists of 5 fields witch are separated by at
least a single space:

The first field is the symbol's name, possibly extended by a section
number enclosed in brackets.  Such a section number limits the
range of validity for a symbol.  The second field designates the
symbol's type: Int stands for integer values, Float for floating
point numbers, and String for character arrays.  The third field
finally contains the symbol's value.  If the symbol contains a
string, it is necessary to use a special encoding for control
characters and spaces.  Without such a coding, spaces in a string
could be misinterpreted as delimiters to the next field.  AS uses the
same syntax that is also valid for assembly source files: Instead of
the character, its ASCII value with a leading backslash (\) is
inserted.  For example, the string

 This is a test

becomes

 This\032is\032\a\032test   .

The numerical value always has three digits and has to be interpreted
as a decimal value.  Naturally, the backslash itself also has to be
coded this way.

The fourth field specifies - if available - the size of the data
structure placed at the address given by the symbol.   A debugger may
use this information to automatically display variables in their
correct length when they are referred symbolically.  In case AS does
not have any information about the symbol size, this field simply
contains the value -1.

Finally,the fifth field states via the values 0 or 1 if the symbol
has been used during assembly.  A program that reads the symbol table
can use this field to skip unused symbols as they are probably unused
during the following debugging/disassembly session.

The third section in a debug file describes the program's sections in
detail.  The need for such a detailed description arises from the
sections' ability to limit the validity range of symbols.  A symbolic
debugger for example cannot use certain symbols for a reverse
translation, depending on the current PC value.  It may also have to
regard priorities for symbol usage when a value is represented by
more than one symbol.  The definition of a section starts with a line
of the following form:

Info for Section nn ssss pp

nn specifies the section's number (the number that is also used in
the symbol table as a postfix for symbol names), ssss gives its name
and pp the number of its parent section.  The last information is
needed by a retranslator to step upward through a tree of sections
until a fitting symbol is found.  This first line is followed by a
number of further lines that describe the code areas used by this
section.  Every single entry (exactly one entry per line) either
describes a single address or an address range given by a lower and
an upper bound (separation of lower and upper bound by a minus sign). 
These bounds are "inclusive", i.e. the bounds themselves also belong
to the area.  Is is important to note that an area belonging to a
section is not additionally listed for the section's parent sections
(an exception is of course a deliberate multiple allocation of address
areas, but you would not do this, would you?).  On the one hand, this
allows an optimized storage of memory areas during assembly. On the
other hand, this should not be an obstacle for symbol backtranslation
as the single entry already gives an unambiguous entry point for the
symbol search path.  The description of a section is ended by an
empty line or the end of the debug file.

Program parts that lie out of any section are not listed separately. 
This implicit "root section" carries the number -1 and is also used
as parent section for sections that do not have a real parent
section.

It is possible that the file contains empty lines or comments (semi
colon at line start).  A program reading the file has to ignore such
lines.


     	6. Utility programs
        ===================

To simplify the work with the assembler's code format a bit, I added
some tools to aid processing of code files.  These programs are
released under the same license terms as stated in section 1.1!

Common to all programs are the possible return codes they may deliver
upon completion:

return code   error condition

0             no errors
1             error in command line parameters
2             I/O error
3             file format error

Just like AS, all programs take their input from STDIN and write
messages to STDOUT (resp. error messages to STDERR).  Therefore,
input and output redirections should not be a problem.

In case that numeric or address specifications have to be given in
the command line, they may also be written in hexadecimal notation
when they are prefixed with a dollar sign (e.g. $10 instead of 16).

+------+
| UNIX |
+------+
Unix shells however \marginpar{{\em UNIX}} assign a special meaning
to the dollar sign, which makes it necessary to escape a dollar sign
with a backslash.

Otherwise, calling conventions and variations are equivalent to those
of AS (except for PLIST and AS2MSG); i.e. it is possible to store
frequently used parameters in an environment variable (whose name is
constructed by appending CMD to the program's name, i.e. BINDCMD for
BIND), to negate options, and to use all upper- resp. lower-case
writing (for details on this, see section 2.1).

Address specifications always relate to the granularity of the
processor currently in question; for example, on a PIC, an address
difference of 1 means a word and not a byte.


        6.1. PLIST
        ----------

PLIST is the simplest one of the five programs supplied: its purpose
is simply to list all records that are stored in a code file.  As the
program does not do very much, calling is quite simple:

    PLIST <file name>

The file name will automatically be extended with the extension P if
it doesn't already have one.

CAUTION! At this place, no wildcards are allowed!  If there is a
necessity to list several files with one command, use the following
"mini batch": 

    for %n in (*.p) do plist %n

PLIST prints the code file's contents in a table style, whereby
exactly one line will be printed per record.  The individual rows
have the following meanings:

code type     : the processor family the code has been generated for.

start address : absolute memory address that expresses the load
                destination for the code.

length        : length of this code chunk in bytes.

end address   : last address of this code chunk.  This address 
                is calculated as start address+length-1.

All outputs are in hexadecimal notation.

Finally, PLIST will print a copyright remark (if there is one in the
file), together with a summaric code length.

Simply said, PLIST is a sort of DIR for code files.  One can use it
to examine a file's contents before one continues to process it.


        6.2. BIND
        ---------

BIND is a program that allows to concatenate the records of several
code files into a single file.  A filter function is available that
can be used to copy only records of certain types.  Used in this way,
BIND can also be used to split a code file into several files.

The general syntax of BIND is

   BIND <source file(s)> <target file> [options]

Just like AS, BIND regards all command line arguments that do not
start with a +, - or / as file specifications, of which the last one
must designate the destination file.  All other file specifications
name sources, which may again contain wildcards.

Currently, BIND defines only one command line option:

f <Header[,Header]> :  sets a list of record headers that should
                       be copied.  Records with other header IDs will
                       not be copied.  Without such an option, all
                       records will be copied.  The headers given in
                       the list correspond to the HeaderID field of the
                       record structure described in section 5.1 . 
                       Individual headers in this list are separated
                       with commas.

For example, to filter all MCS-51 code out of a code file, use BIND
in the following way:

   BIND <source name> <target name> -f $31

If a file name misses an extension, the extension P will be added
automatically.


        6.3. P2HEX
        ----------

P2HEX is an extension of BIND.  It has all command line options of BIND and
uses the same conventions for file names.  In contrary to BIND, the
target file is written as a Hex file, i.e. as a sequence of lines
which represent the code as ASCII hex numbers.

P2HEX knows 7 different target formats, which can be selected via the
command line parameter F:

 - Motorola S-Records (-F Moto)
 - MOS Hex (-F MOS)
 - Intel Hex (Intellec-8, -F Intel)
 - 16-Bit Intel Hex (MCS-86, -F Intel16)
 - 32-Bit Intel Hex (-F Intel32)
 - Tektronix Hex (-F Tek)
 - Texas Instruments DSK (-F DSK)

If no target format is explicitly specified, P2HEX will automatically
choose one depending in the processor type:  S-Records for Motorola
CPUs, Hitachi, and TLCS-900, MOS for 65xx/MELPS, DSK for the 16 bit
signal processors from Texas and Intel Hex for the rest.  Depending
on the start addresses width, the S-Record format will use Records of
type 1, 2, or 3, however, records in one group will always be of the
same type.  The Intel, MOS and Tektronix formats are limited to 16
bit addresses, the 16-bit Intel format reaches 4 bits further. 
Addresses that are to long for a given format will be reported by
P2HEX with a warning; afterwards, they will be truncated (!).

For the PIC microcontrollers, the switch

-m <0..3>

allows to generate the three different variants of the Intel Hex
format.  Format 0 is INHX8M which contains all bytes in a
Lo-Hi-Order.  Addresses become double as large because the PICs have
a word-oriented address space that increments addresses only by one
per word.  This format is also the default.  With Format 1 (INHX16M),
bytes are stored in their natural order.  This is the format
Microchip uses for its own programming devices.  Format 2 (INHX8L)
resp. 3 (INHX8H) split words into their lower resp. upper bytes. 
With these formats, P2HEX has to be called twice to get the complete
information, like in the following example:

  p2hex test -m 2
  rename test.hex test.obl
  p2hex test -m 3
  rename test.hex test.obh

For the Motorola format, P2HEX additionally uses the S5 record type
mentioned in [CPM68K].  This record contains the number of data
records (S1/S2/S3) to follow.  As some programs might not know how to
deal with this record, one can suppress it with the option

 +5  .

In case a source file contains code record for different processors,
the different hex formats will also show up in the target file - it
is therefore strongly advisable to use the filter function.

Apart form this filter function, P2HEX also supports an address
filter, which is useful to split the code into several parts (e.g.
for a set of EPROMs):

-r <start address>-<end address>

The start address is the first address in the window, and the end
address is the last address in the window, NOT the first address
that is out of the window.  For example, to split an 8051 program
into 4 2764 EPROMs, use the following commands:

p2hex <source file> eprom1 -f $31 -r $0000-$1fff
p2hex <source file> eprom2 -f $31 -r $2000-$3fff 
p2hex <source file> eprom3 -f $31 -r $4000-$5fff 
p2hex <source file> eprom4 -f $31 -r $6000-$7fff 

By default, the address window is 32 KBytes large and starts at
address 0.  

CAUTION! This type of splitting does not change the absolute
addresses that will be written into the files!  If the addresses in
the individual hex files should rather start at 0, one can force this
with the additional switch

-a     .

A special value for start and stop address arguments is a single
dollar sign ($).  This stands for the very first resp. last address
that has been used in the code file.  So, if you want to be sure
that always the whole program is stored in the hex file, set the
address filter

 -r $-$

and you do not have to worry about address filters any more.  Dollar
signs and fixed addresses may of course me mixed.  For example, the
setting

 -r $-$7fff

limits the upper end to 32 KBytes. 

By using an offset, it is possible to move a file's contents to an arbitrary position. 
This offset is simply appended to a file's name, surrounded with
parentheses.  For example, if the code in a file starts at address 0
and you want to move it to address 1000 hex in the hex file, append
($1000) to the file's name (without spaces!).

As the TI DSK format has the ability to distinguish between data and
code, there is a switch

 -d <start>-<end>

to designate the address range that should be written as data instead
of code.  For this option, single dollar signs are NOT allowed! While
this switch is only relevant for the DSK format, the option

 -e <address>

is also valid for the Intel and Motorola formats.  Its purpose is to
set the entry address that will be inserted into the hex file.  If
such a command line parameter is missing, P2HEX will search a
corresponding entry in the code file.  If even this fails, no entry
address will be written to the hex file (DSK/Intel) or the field
reserved for the entry address will be set to 0 (Motorola).

Unfortunately, one finds different statements about the last line of
an Intel-Hex file in literature.  Therefore, P2HEX knows three
different variants that may be selected via the command-line
parameter i and an additional number:

 0  :00000001FF
 1  :00000001
 2  :0000000000

By default, variant 0 is used which seems to be the most common one.

If the target file name does not have an extension, an extension of
HEX is supposed.

By default, P2HEX will print a maximum of 16 data bytes per line,
just as most other tools that output Hex files.  If you want to
change this, you may use the switch

-l <count>   .

The allowed range of values goes from 2 to 254 data bytes; odd values
will implicitly be rounded down to an even count.

In contrast to BIND, P2HEX will not produce an empty target file if
only one file name (i.e. the target name) has been given.  Instead,
P2HEX will use the corresponding code file.  Therefore, a minimal
call in the style of

 P2HEX <name>

is possible, to generate <name>.hex out of <name>.p .


        6.4. P2BIN
        ----------

P"BIN works similar to P2HEX and offers the same options (except for
the a and i options that do not make sense for binary files),
however, the result is stored as a simple binary file instead of a
hex file.  Such a file is for example suitable for programming an
EPROM.

P2BIN knows three additional options to influence the resulting binary
file:

 l <8 bit number> :  sets the value that should be used to fill
                     unused memory areas.  By default, the value
                     $ff is used.  This value assures that every
                     half-way intelligent EPROM burner will skip
                     these areas.  This option allows to set dif-
                     ferent values, for example if you want to 
                     generate an image for the EPROM versions of 
                     MCS-48 microcontrollers (empty cells of their
                     EPROM array contain zeroes, so $00 would be
                     the correct value in this case).

 s                :  commands the program to calculate a checksum
                     of the binary file.  This sum is printed as 
                     a 32-bit value, and the two's complement of
                     the least significant bit will be stored in
                     the file's last byte.  This way, the modulus-
                     256-sum of the file will become zero.

 m                :  is designed for the case that a CPU with a 
                     16- or 32-bit data bus is used and the file
                     has to be split for several EPROMs.  The 
                     argument may have the following values:

                     ALL    : copy everything
                     ODD    : copy all bytes with an odd address
                     EVEN   : copy all bytes with an even address
                     BYTE0..: copy only bytes with an address of
                     BYTE1    4n+0 .. 4n+3
                     WORD0, : copy only the lower resp. upper 16-
                     WORD1    bit word of a 32-bit word

                     To avoid confusions: If you use this option, 
                     the resulting binary file will become smaller
                     because only a part of the source will be 
                     copied.  Therefore, the resulting file will
                     be smaller by a factor of 2 or 4 compared to
                     ALL.  This is just natural...


        6.5. AS2MSG
        -----------

AS2MSG is not a tool in the real sense, it is a filter that was
designed to simplify the work with the assembler for (fortunate)
users of Borland Pascal 7.0.  The DOS IDEs feature a 'tools' menu
that can be extended with own programs like AS.  The filter allows to
directly display the error messages paired with a line
specification delivered by AS in the editor window.  A new entry has
to be added to the tools menu to achieve this (Options/Tools/New).
Enter the following values:

 - Title: ~m~acro assembler
 - Program path: AS
 - Command line: -E !1 $EDNAME $CAP MSG(AS2MSG) $NOSWAP $SAVE ALL
 - assign a hotkey if wanted (e.g. Shift-F7)

The -E option assures that Turbo Pascal will not become puzzled by
STDIN and STDERR.

I assume that AS and AS2MSG are located in a directory listed in the
PATH variable.  After pressing the appropriate hotkey (or selecting
AS from the tools menu), as will be called with the name of the file
loaded in the active editor window as parameter.  The error messages
generated during assembly are redirected to a special window that
allows to browse through the errors.  Ctrl-Enter jumps to an
erroneous line.  The window additionally contains the statistics AS
prints at the end of an assembly.  These lines obtain the dummy line
number 1.

TURBO.EXE (Real Mode) and BP.EXE (Protected Mode) may be used for
this way of working with AS.  I recommend however BP, as this version
does not have to 'swap' half of the DOS memory before before AS is
called. 


                        --- Appendices ---


	A. Error Messages of AS
	========================

Here is a list of all error messages emitted by AS.  Each error
message is described by:

- the internal error number (it is displayed only if AS is started with the
                              -n option)

- the text of the error message

- error type:  Warning   : informs the user that a possible error was
                           found, or that some inefficient binary code
                           could be generated. The assembly process is not
                           stopped.

               Error     : an error was detected. The assembly process
                           continues, but no binary code is emitted.


               Fatal     : unrecoverable error. The assembly process is
                           terminated.

- reason of the error    : the situation originating the error.

- argument:  a further explanation of the error message.


--------------------------------------------------------------------------

0     useless displacement

      Type:     warning
      Reason:   680x0, 6809 and COP8 CPUs: an address displacement of
                0 was given.  An address expressionwithout displacement
                is generated, and a convenient number of NOPs are
                emitted to avoid phasing errors.
      Argument: none


10    short addressing possible

      Type:     warning
      Reason:   680x0-, 6502 and 68xx CPUs: a given memory location can be
                reached using short addressing. A short addressing
                instruction is emitted, together with the required
                number of NOPs to avoid phasing errors.
      Argument: none


20    short jump possible

      Type:     warning
      Reason:   680x0- and 8086 CPUs can execute jumps using a short or long
                displacement. If a shorter jump was not explicitly
                requested, in the first pass room for the long jump is
                reserved.  Then the code for the shorter jump is emitted, and
                the remaining space is filled with NOPs to avoid phasing
                errors.
      Argument: none


30    no sharefile created, SHARED ignored

      Type:     warning
      Reason:   A SHARED directive was found, but on the command line no
                options were specified, to generate a shared file.
      Argument: none


40    FPU possibly cannot read this value (>=1E1000)

      Type:     warning
      Reason:   The BCD- floating point format used by the 680x0- FPU
                allows such a large exponent, but according to the
                latest databooks, this cannot be fully interpreted.
                The corresponding word is assembled, but the
                associated function is not expected to produce the
                correct result.
      Argument: none


50    privileged instruction
      Type:     warning
      Reason:   A Supervisor-mode directive was used, that was not preceded
                by an explicit SUPMODE ON directive
      Argument: none


60    distance of 0 not allowed for short jump (NOP created instead)
      Type:     warning
      Reason:   A short jump with a jump distance equal to 0 is not
                allowed for 680x0 resp. COP8 processors, since the
                associated code word is used to identify long jump
                instruction. Instead of a jump instruction, AS emits
                a NOP.
      Argument: none


70    symbol out of wrong segment
      Type:     warning
      Reason:   The symbol used as an operand comes from an address space
                that cannot be addressed together with the given instruction
      Argument: none


75    segment not accessible
      Type:     warning
      Reason:   The symbol used as an operand belongs to an address space
                that cannot be accessed with any of the segment registers of
                the 8086
      Argument: The name of the inaccessible segment

80    change of symbol values forces additional pass
      Type:     warning
      Reason:   A symbol changed value, with respect to previous pass. This
                warning is emitted only if the -r option is used.
      Argument: name of the symbol that changed value.

90    overlapping memory usage
      Type:     warning
      Reason:   The analysis of the usage list shows that part of the
                program memory was used more than once. The reason can be an
                excessive usage of ORG directives.
      Argument: none

100   none of the CASE conditions was true
      Type:     warning
      Reason:   A SWITCH...CASE directive without ELSECASE clause was
                executed, and none of the CASE conditions was found
                to be true.
      Argument: none

110   page might not be addressable
      Type:     warning
      Reason:   The symbol used as an operand was not found in the memory
                page defined by an ASSUME directive (ST62xx, 78(C)10).
      Argument  none

120   register number must be even
      Type:     warning
      Reason:   The CPU allows to concatenate only register pairs, whose
                start address is even (RR0, RR2, ..., only for Z8).
      Argument: none

130   obsolete instruction, usage discouraged
      Type:     warning
      Reason:   The instruction used, although supported, was superseded by
                a new instruction. Future versions of the CPU could no more
                implement the old instruction.
      Argument: none

140   unpredictable execution of this instruction
      Type:     warning
      Reason:   The addressing mode used for this instruction is allowed,
                however a register is used in such a way that its
                contents cannot be predicted after the execution of the
                instruction.
      Argument:  none

150   localization operator senseless out of a section
      Type:     warning
      Reason:   An aheaded @ must be used, so that it is explicitly
                referred to the local symbol used in the section. When
                the operator is used out of a section, there are no local
                symbols, because this operator is useless in this context.
      Argument: none

160   senseless instruction
      Type:     warning
      Reason:   The instruction used has no meaning, or it can be
                substituted by an other instruction, shorter and more
                rapidly executed.
      Argument: none

170   unknown symbol value forces additional pass
      Type:     warning
      Reason:   AS expects a forward definition of a symbol, i.e. a symbol
                was used before it was defined. A further pass must be
                executed. This warning is emitted only if the -r option was
                used.
      Argument: none

180   address is not properly aligned
      Type:     warning
      Reason:   An address was used that is not an exact multiple of the
                operand size. Although the CPU databook forbids this, the
                address could be stored in the instruction word, so AS
                simply emits a warning.
      Argument: none.

190   I/O-address must not be used here
      Type:     warning
      Reason:   The addressing mode or the address used are correct, but the
                address refers to the peripheral registers, and it
                cannot be used in this circumstance.  Argument: none.

200   possible pipelining effects
      Type:     warning
      Reason:   A register is used in a series of instructions, so that a
                sequence of instructions probably does not generate the
                desired result. This usually happens when a register is
                used before its new content was effectively loaded in it.
      Argument: the register probably causing the problem.

210   multiple use of address register in one instruction
      Type:     warning
      Reason:   An register used for the addressing is used once more in the
                same instruction, in a way that results in a modification
                of the register value. The resulting address does not have a
                well defined value.
      Argument: the register used more than once.

1000  symbol double defined
      Type:     error
      Reason:   A new value is assigned to a symbol, using a label or a
                EQU, PORT, SFR, LABEL, SFRB or BIT instruction: however this
                can be done only using SET/EVAL.
      Argument: the name of the offending symbol, and the line number where
                it was defined for the first time, according to the symbol
                table.

1010  symbol undefined
      Type:     error
      Reason:   A symbol is still not defined in the symbol table, also
                after a second pass.
      Argument: the name of the undefined symbol.

1020  invalid symbol name
      Type:     error
      Reason:   A symbol does not fulfill the requirements that symbols
                must have to be considered valid by AS. Please pay
                attention that more stringent syntax rules exist for
                macros and function parameters.
      Argument: the wrong symbol

1090  invalid format
      Type:     error
      Reason:   The instruction format used does not exist for this
                instruction.
      Argument: the known formats for this command

1100  useless attribute
      Type:     error
      Reason:   The instruction (processor or pseudo) cannot be used
                with a point-suffixed attribute.
      Argument: none

1105  attribute may only be one character long
      Type:     error
      Reason:   The attribute following a point after an instruction
                must not be longer or shorter than one character.
      Argument: none

1110  wrong number of operands
      Type:     error
      Reason:   The number of arguments issued for the instruction
                (processor or pseudo) does not conform with the
                accepted number of operands.
      Argument: none

1115  wrong number of operations
      Type:     error
      Reason:   The number of options given with this command is not
                correct.
      Argument: none

1120  addressing mode must be immediate
      Type:     error
      Reason:   The instruction can be used only with immediate operands
                (preceded by #).
      Argument: none

1130  invalid operand size
      Type:     error
      Reason:   Although the operand is of the right type, it does not have
                the correct length (in bits).
      Argument: none

1131  conflicting operand sizes
      Type:     error
      Reason:   The operands used have different length (in bits)
      Argument: none

1132  undefined operand size

      Type:     error
      Reason:   It is not possible to estimate, from the opcode and from
                the operands, the size of the operand (a trouble with
                8086 assembly). You must define it with a BYTE or WORD
                PTR prefix.
      Argument: none

1135  invalid operand type
      Type:     error
      Reason:   an expression does not have a correct operand type
                (integer/decimal/string)
      Argument: the operand type

1140  too many arguments
      Type:     error
      Reason:   No more than 20 arguments can be given to any
                instruction
      Argument: none

1200  unknown opcode
      Type:     error
      Reason:   An instruction was used that is neither an AS
                instruction, nor a known mnemonic for the current
                processor type.
      Argument: none

1300  number of opening/closing brackets does not match
      Type:     error
      Reason:   The expression parser found an expression enclosed by
                parentheses, where the number of opening and closing
                parentheses does not match.
      Argument: the wrong expression

1310  division by 0
      Type:     error
      Reason:   An expression on the right side of a division or modulus
                operation was found to be equal to 0.
      Argument: none

1315  range underflow
      Type:     error
      Reason:   An integer word underflowed the allowed range.
      Argument: the value of the word and the allowed minimum (most
                case, maybe I will complete thisone day...)

1320  range overflow
      Type:     error
      Reason:   An integer word overflowed the allowed range.
      Argument: the value of the world, and the allowed maximum (in
                most cases, maybe I will complete this one day...)

1325  address is not properly aligned
      Type:     error
      Reason:   The given address does not correspond with the size needed
                by the data transfer, i.e. it is not an integral multiple of
                the operand size. Not all processor types can use unaligned
                data.
      Argument: none

1330  distance too big
      Type:     error
      Reason:   The displacement used for an address is too large.
      Argument: none

1340  short addressing not allowed
      Type:     error
      Reason:   The address of the operand is outside of the address space
                that can be accessed using short-addressing mode.
      Argument: none

1350  addressing mode not allowed here
      Type:     error
      Reason:   the addressing mode used, although usually possible,
                cannot be used here.
      Argument: none

1351  number must be even
      Type:     error
      Reason:   At this point, only even addresses are allowed, since the
                low order bit is used for other purposes or it is reserved.
      Argument: none

1355  addressing mode not allowed in parallel operation
      Type:     error
      Reason:   The addressing mode(s) used are allowed in sequential,
                but not in parallel instructions
      Argument: none

1360  undefined condition
      Type:     error
      Reason:   The branch condition used for a conditional jump does not
                exist.
      Argument: none

1370  jump distance too big
      Type:     error
      Reason:   the jump instruction and destination are too apart to
                execute the jump with a single step
      Argument: none

1375  jump distance is odd
      Type:     error
      Reason:   Since instruction must only be located at even addresses,
                the jump distance between two instructions must always be
                even, and the LSB of the jump distance is used otherwise.
                This issue was not verified here. The reason is usually the
                presence of an odd number of data in bytes or a wrong ORG.
      Argument: none

1380  invalid argument for shifting
      Type:     error
      Reason:   only a constant or a data register can be used for defining
                the shift size. (only for 680x0)
      Argument: none

1390  operand must be in range 1..8
      Type:     error
      Reason:   constants for shift size or ADDQ argument can be only
                within the 1..8 range (only for 680x0)
      Argument: none

1400  shift amplitude too big
      Type:     error
      Reason:   (no more used)
      Argument: none

1410  invalid register list
      Type:     error
      Reason:   The register list argument of MOVEM or FMOVEM has a
                wrong format (only for 680x0)
      Argument: none

1420  invalid addressing mode for CMP
      Type:     error
      Reason:   The operand combination used with the CMP instruction is
                not allowed (only for 680x0)
      Argument: none

1430  invalid CPU type
      Type:     error
      Reason:   The processor type used as argument for CPU command is
                unknown to AS.
      Argument: the unknown processor type

1440  invalid control register
      Type:     error
      Reason:   The control register used by a MOVEC is not (yet) available
                for the processor defined by the CPU command.
      Argument: none

1445  invalid register
      Type:     error
      Reason:   The register used, although valid, cannot be used in this
                context.
      Argument: none

1450  RESTORE without SAVE
      Type:     error
      Reason:   A RESTORE command was found, that cannot be coupled with a
                corresponding SAVE.
      Argument: none

1460  missing RESTORE
      Type:     error
      Reason:   After the assembling pass, a SAVE command was missing.
      Argument: none.

1465  unknown macro control instruction
      Type:     error
      Reason:   A macro option parameter is unknown to AS.
      Argument: the dubious option.

1470  missing ENDIF/ENDCASE
      Type:     error
      Reason:   after the assembling, some of the IF- or CASE- constructs
                were found without the closing command
      Argument: none

1480  invalid IF-structure
      Type:     error
      Reason:   The command structure in a IF- or SWITCH- sequence is
                wrong.
      Argument: none

1483  section name double defined
      Type:     error
      Reason:   In this program module a section with the same name still
                exists.
      Argument: the multiple-defined name

1484  unknown section
      Type:     error
      Reason:   In the current scope, there are no sections with this
                name
      Argument: the unknown name

1485  missing ENDSECTION
      Type:     error
      Reason:   Not all the sections were properly closed.
      Argument: none

1486  wrong ENDSECTION
      Type:     error
      Reason:   The given ENDSECTION does not refer to the most
                deeply nested one.
      Argument: none

1487  ENDSECTION without SECTION
      Type:     error
      Reason:   An ENDSECTION command was found, but the associated section
                was not defined before.
      Argument: none

1488  unresolved forward declaration
      Type:     error
      Reason:   A symbol declared with a FORWARD or PUBLIC statement could
                not be resolved.
      Argument: the name of the unresolved symbol.

1489  conflicting FORWARD <-> PUBLIC-declaration
      Type:     error
      Reason:   A symbol was defined both as public and private.
      Argument: the name of the symbol.

1490  wrong numbers of function arguments
      Type:     error
      Reason:   The number of arguments used for referencing a function
                does not match the number of arguments defined in the
                function definition.
      Argument: none

1495  unresolved literals (missing LTORG)
      Type:     error
      Reason:   At the end of the program, or just before switching to
                another processor type, unresolved literals still remain.
      Argument: none

1500  order not allowed on
      Type:     error
      Reason:   Although the instruction is correct, it cannot be used
                with the selected member of the CPU family.
      Argument: none

1505  addressing mode not allowed on
      Type:     error
      Reason:   Although the addressing mode used is correct, it cannot be
                used with the selected member of the CPU family.
      Argument: none

1510  invalid bit position
      Type:     error
      Reason:   Either the number of bits specified is not allowed, or
                the command is not completely specified.
      Argument: none

1520  only ON/OFF allowed
      Type:     error
      Reason:   This pseudo command accepts as argument either ON or OFF
      Argument: none

1600  unexpected end of file
      Type:     error
      Reason:   It was tried to read past the end of a file with a 
                BINCLUDE statement.
      Argument: none

1700  ROM-offset must be in range 0..63
      Type:     error
      Reason:   The ROM table of the 680x0 coprocessor has only 64 entries.
      Argument: none

1710  invalid function code
      Type:     error
      Reason:   The only function code arguments allowed are SFC, DFC, a
                data register, or a constant in the interval of 0..15 (only
                for 680x0 MMU).
      Argument: none

1720  invalid function code mask
      Reason:   Only a number in the interval 0..15 can be used as
                function code mask (only for 680x0 MMU)
      Type:     error
      Argument: none

1730  invalid MMU register
      Type:     error
      Reason:   The MMU does not have a register with this name (only for
                680x0 MMU).

      Argument:

1740  level must be in range 0..7
      Type:     error
      Reason:   The level for PTESTW and PTESTR must be a constant in the
                range of 0...7 (only for 680x0 MMU).
      Argument: none

1750  invalid bit mask
      Type:     error
      Reason:   The bit mask used for a bit field command has a wrong
                format (only for 680x0).
      Argument: none

1760  invalid register pair
      Type:     error
      Reason:   The register here defined cannot be used in this
                context, or there is a syntactic error (only for
                680x0).
      Argument: none

1800  open macro definition
      Type:     error
      Reason:   An incomplete macro definition was found. Probably an
                ENDM was forgotten.
      Argument: none

1805  EXITM not called from within macro
      Type:     error
      Reason:   EXITM is designed to terminate a macro expansion.  This
                instruction only makes sense within macros and an attempt
                was made to call it in the absence of macros.
      Argument: none

1810  more than 10 macro parameters
      Type:     error
      Reason:   A macro cannot have more than 10 parameters
      Argument: none

1815  macro double defined
      Type:     error
      Reason:   A macro was defined more than once in a program section.
      Argument: the multiply defined macro name.

1820  expression must be evaluatable in first pass
      Type:     error
      Reason:   The command used has an influence on the length of the
                emitted code, so that forward references cannot be resolved
                here.
      Argument: none

1830  too many nested IFs
      Type:     error
      Reason:   (no more implemented)
      Argument: none

1840  ELSEIF/ENDIF without IF
      Type:     error
      Reason:   A ELSEIF- or ENDIF- command was found, that is not preceded
                by an IF- command.
      Argument: none

1850  nested / recursive macro call
      Type:     error
      Reason:   (no more implemented)
      Argument: none

1860  unknown function

      Type:     error
      Reason:   The function invoked was not defined before.
      Argument: The name of the unknown function

1870  function argument out of definition range
      Type:     error
      Reason:   The argument does not belong to the allowed argument range
                associated to the referenced function.
      Argument: none

1880  floating point overflow
      Type:     error
      Reason:   Although the argument is within the range allowed to the
                function arguments, the result is not valid
      Argument: none

1890  invalid value pair
      Type:     error
      Reason:   The base-exponent pair used in the expression cannot be
                computed
      Argument: none

1900  order must not start on this address
      Type:     error
      Reason:   No jumps can be performed by the selected CPU from this
                address.
      Argument: none

1905  invalid jump target
      Type:     error
      Reason:   No jumps can be performed by the selected CPU to this
                address.
      Argument: none

1910  jump target not on same page
      Type:     error
      Reason:   Jump command and destination must be in the same memory
                page.
      Argument: none

1920  code overflow
      Type:     error
      Reason:   An attempt was made to generate more than 1024 code or
                data bytes in a single memory page.
      Argument: none

1925  address overflow
      Type:     error
      Reason:   The address space for the processor type actually used was
                filled beyond the maximum allowed limit.
      Argument: none

1930  constants and placeholders cannot be mixed
      Type:     error
      Reason:   Instructions that reserve memory and instructions that
                define constants cannot be mixed in a single pseudo
                instruction.
      Argument: none

1940  code may only be generated in code segment
      Type:     error
      Reason:   Segments not used for code can be used only for reserving
                memory. Inside them neither code nor data can be stored.
                (not used anymore)
      Argument: none

1950  parallel construct not possible here
      Type:     error
      Reason:   Either these instructions cannot be executed in parallel,
                or they are not close enough each other, to do parallel
                execution.
      Argument: none

1960  invalid segment
      Type:     error
      Reason:   The referenced segment cannot be used here.
      Argument: The name of the segment used.

1961  unknown segment
      Type:     error
      Reason:   The segment referenced with a SEGMENT command does not
                exist for the CPU used.
      Argument: The name of the segment used

1962  unknown segment register
      Type:     error
      Reason:   The segment referenced here does not exist (8086 only)
      Argument: none

1970  invalid string
      Type:     error
      Reason:   The string has an invalid format.
      Argument: none

1980  invalid register name
      Type:     error
      Reason:   The referenced register does not exist, or it cannot
                be used here.
      Argument: none

1985  invalid argument
      Type:     error
      Reason:   The command used cannot be performed with the REP- prefix.
      Argument: none

1990  indirect mode not allowed
      Type:     error
      Reason:   Indirect addressing cannot be used in this way
      Argument: none

1995  not allowed in current segment
      Type:     error
      Reason:   (no more implemented)
      Argument: none

1996  not allowed in maximum mode
      Type:     error
      Reason:   This register can be used only in minimum mode
      Argument: none

1997  not allowed in minimum mode
      Type:     error
      Reason:   This register can be used only in maximum mode
      Argument: none

2000  invalid combination of prefixes
      Type:     error
      Reason:   The prefix combination here defined is not allowed, or it
                cannot be translated into binary code
      Argument:


2010  invalid escape sequence
      Type:     error
      Reason:   The special character defined using a backslash sequence
                is not defined
      Argument: none

10001 error in opening file
      Type:     fatal
      Reason:   An error was detected while trying to open a file for input.
      Argument: description of the I/O error

10002 error in writing listing
      Type:     fatal
      Reason:   An error happened while AS was writing the listing file.
      Argument: description of the I/O error

10003 file read error
      Type:     fatal
      Reason:   An error was detected while reading a source file.
      Argument: description of the I/O error

10004 file write error
      Type:     fatal
      Reason:   While AS was writing a code or share file, an error happened.
      Argument: description of the I/O error

10006 heap overflow
      Type:     fatal
      Reason:   The memory available is not enough to store all the data
                needed by AS. Try using the DPMI or OS/2 version of AS.
      Argument: none

10007 stack overflow
      Type:     fatal
      Reason:   The program stack crashed, because too complex formulas, or
                a bad disposition of symbols and/or macros were used. Try
                again, using AS with the option -A.
      Argument: none


        B. I/O Error Messages
        =====================

The following error messages are generated not only by AS, but also by
the auxiliary programs, like PLIST, BIND, P2HEX, and P2BIN. Only the most
probable error messages are here explained. Should you meet an undocumented
error message, then you probably met a program bug ! Please inform us
immediately about this !!

2     file not found
      The file requested does not exist, or it is stored on another drive.

3     path not found
      The path of a file does not exist, or it is on another drive.

4     too much open files
      There are no more file handles available to DOS. Increase
      their number changing the value associated to FILES= in the file
      CONFIG.SYS.

5     file access not allowed
      Either the network access rights do not allow the file access, or
      an attempt was done to rewrite or rename a protected file.

6     invalid file handler

12    invalid access mode

15    invalid drive letter
      The required drive does not exist.

16    The file cannot be deleted

17    RENAME cannot be done on this drive

100   Unexpected end of file
      A file access tried to go beyond the end of file, although according
      to its structure this should not happen. The file is probably
      corrupted.

101   disk full
      This is self explaining! Please, clean up !

102   ASSIGN failed

103   file not open

104   file not open for reading

105   file not open for writing

106   invalid numerical format

150   the disk is write-protected
      When you don't use a hard disk as work medium storage, you should
      sometimes remove the protecting tab from your diskette !

151   unknown device
      you tried to access a peripheral unit that is unknown to DOS. This
      should not usually happen, since the name should be automatically
      interpreted as a filename.

152   drive not ready
      close the disk drive door.

153   unknown DOS function

154   invalid disk checksum
      A bad read error on the disk. Try again; if nothing changes,
      reformat the floppy disk resp. begin to take care of your hard disk!

155   invalid FCB

156   position error
      the diskette/hard disk controller has not found a disk track. See
      nr. 154 !

157   format unknown
      DOS cannot read the diskette format

158   sector not found
      As nr. 156, but the controller this time could not find a disk
      sector in the track.

159   end of paper
      You probably redirected the output of AS to a printer. Assembler
      printout can be veeery long...

160   device read error
      The operating system detected an unclassificable read error

161   device write error
      The operating system detected an unclassificable write error

162   general failure error
      The operating system has absolutely no idea of what happened to the
      device.


        C. Frequently Asked Questions
        =============================

In this chapter, I tried to collect some questions that arise very often
together with their answers.  Answers to the problems presented in
this chapter might also be found at other places in this manual, but
one maybe does not find them immediately...

Q: I am fed up with DOS.  Are there versions of AS for other
   operating systems ?
A: Apart from the protected mode version that offers more memory when
   working under DOS, ports exist for OS/2 and Unix systems like
   Linux (currently in test phase).  Versions that help operating 
   system manufacturers located in Redmont to become even richer are
   currently not planned.  I will gladly make the sources of AS
   available for someone else who wants to become active in this
   direction.  The C variant is probably the best way to start a
   port into this direction.  He should however not expect support
   from me that goes beyond the sources themselves...

Q: Is a support of the XYZ processor planned for AS?
A: New processors are appearing all the time and I am trying to keep
   pace by extending AS.  The stack on my desk labeled "undone"
   however never goes below the 4 inch watermark... Wishes coming
   from users of course play an important role in the decision which
   candidates will be done first.  The internet and the rising amount
   of documentation published in electronic form make the acquisition
   of data books easier than it used to be, but it always becomes
   difficult when more exotic or older architectures are wanted.  If
   the processor family in question is not in the list of families
   that are planned (see chapter 1), adding a data book to a request
   will have a highly positive influence.  Borrowing books is also 
   fine.

Q: Having a free assembler is really fine, but I now also had use for
   a disassembler...and a debugger...a simulator would also really be
   cool!
A: AS is a project I work on in leisure time, the time I have when I
   do not have to care of how to make my living.  AS already takes a
   significant portion of that time, and sometimes I make a time-out
   to use my soldering iron, enjoy a Tangerine Dream CD, watch TV, or
   simply to fulfill some basic human needs... I once started to
   write the concept of a disassembler that was designed to create
   source code that can be assembled and that automatically
   separates code and data areas.  I quickly stopped this project
   again when I realized that the remaining time simply did not
   suffice.  I prefer to work on one good program than to struggle for
   half a dozen of mediocre apps.  Regarded that way, the answer to
   the question is unfortunately "no"...

Q: The screen output of AS is messed up with strange characters, e.g.
   arrows and brackets.  Why?
A: AS will by default use some ANSI control sequences for screen
   control.  These sequences will appear unfiltered on your screen
   if you did not install an ANSI driver.  Either install an ANSI
   driver or use the DOS command 'SET USEANSI=N' to turn the
   sequences off.

Q: AS suddenly terminates with a stack overflow error while
   assembling my program.  Did my program become to large?
A: Yes and No.  Your program's symbol table has grown a bit
   unsymmetrically what lead to high recursion depths while accessing
   the table.  Errors of this type especially happen in the
   16-bit-OS/2 version of AS which has a very limited stack area.
   Restart AS with the -A command line switch.  If this does not
   help, too complex formula expression are also a possible cause of
   stack overflows.  In such a case, try to split the formula into
   intermediate steps.

Q: It seems that AS does not assemble my program up to the end.  It
   worked however with an older version of AS (1.39). 
A: Newer versions of AS no longer ignore the END statement; they
   actually terminate assembly when an END is encountered. 
   Especially older include files made by some users tended to
   contain an END statement at their end.  Simply remove the
   superfluous END statements.

Q: I made an assembly listing of my program because I had some more
   complicated assembly errors in my program.  Upon closer
   investigation of the listing, I found that some branches do not
   point to the desired target but instead to themselves!
A: This effect happens in case of forward jumps in the first pass.
   The formula parser does not yet have the target address in its
   symbol table, and as it is a completely independent module, it has
   to think of a value that even does not hurt relative branches with
   short displacement lengths.  This is the current program counter
   itself...in the second pass, the correct values would have
   appeared, but the second pass did not happen due to errors in the
   first one.  Correct the other errors first so that AS gets into
   the second pass, and the listing should look more meaningful
   again.

Q: Assembly of my program works perfectly, however I get an empty
   file when I try to convert it with P2HEX or P2BIN.
A: You probably did not set the address filter correctly.  This
   filter by default cuts out an area ranging from 0 to 32 Kbytes.
   If you program contains memory chunks outside this range, they
   will be ignored.  If your code is completely beyond the 32K 
   barrier (this is commonplace for processors of the 65xx and 68xx
   series), you will get the result you just described.  Simply
   set the address filter to a range that suits your needs (see the
   chapter dealing with P2BIN/P2HEX).


        D. Pseudo-Instructions Collected
        ================================

This appendix is designed as a quick reference to look up all pseudo
instructions provided by AS.  The list is ordered in two parts: The
first part lists the instructions that are always available, and this
list is followed by lists that enumerate the instructions
additionally available for a certain processor family.

        Instructions that are always available
        --------------------------------------

=             :=             ALIGN          BINCLUDE       CASE
CHARSET       CPU            DEPHASE        ELSECASE       ELSEIF
END           ENDCASE        ENDIF          ENDM           ENDSECTION
ENUM          ERROR          EQU            EXITM          FATAL
FORWARD       FUNCTION       GLOBAL         IF             IFB
IFDEF         IFEXIST        IFNB           IFNDEF         IFNEXIST
IFNUSED       IFUSED         INCLUDE        IRP            LABEL
LISTING       MACEXP         MACRO          MESSAGE        NEWPAGE
ORG           PAGE           PHASE          POPV           PUSHV
PRTEXIT       PRTINIT        PUBLIC         READ           RELAXED
REPT          RESTORE        SAVE           SECTION        SEGMENT
SHARED        SWITCH         TITLE          WARNING        WHILE

There is an additional SET resp. EVAL instruction (in case SET is
already a machine instruction).

        Motorola 680x0
        --------------

DC[.<size>]   DS[.<size>]    FULLPMMU       FPU            PADDING
PMMU          SUPMODE


        Motorola 56000
        --------------

DC            DS             XSFR           YSFR


        PowerPC
        -------

BIGENDIAN     DB             DD             DQ             DS
DT            DW             SUPMODE


        Motorola 68xx/Hitachi 6309
        --------------------------

ADR           BYT            DC[.<size>]    DFS            DS[.<size>]
FCB           FCC            FDB            PADDING        RMB


        Motorola 6805/68HC08
        --------------------

ADR           BYT            DFS            FCB            FCC
FDB           RMB


        Motorola 6809/Hitachi 6309
        --------------------------

ADR           ASSUME         BYT            DFS            FCB
FCC           FDB            RMB


        Motorola 68HC12
        ---------------

ADR           BYT            DC[.<size>]    DFS            DS[.<size>]
FCB           FCC            FDB            PADDING        RMB


        Motorola 68HC16
        ---------------

ADR           ASSUME         BYT            DFS            FCB
FCC           FDB            RMB


        Hitachi H8/300(L/H)
        -------------------

DC[.<size>]   DS[.<size>]    MAXMODE        PADDING


        Hitachi H8/500
        --------------

ASSUME        DC[.<size>]    DS[.<size>]    MAXMODE        PADDING


        Hitachi SH7x00
        --------------

COMPLITERALS  DC[.<size>]    DS[.<size>]    LTORG          PADDING
SUPMODE


        65xx/MELPS-740
        --------------

ADR           ASSUME         BYT            DFS            FCB
FCC           FDB            RMB


        65816/MELPS-7700
        ----------------

ADR           ASSUME         BYT            DB             DD
DQ            DS             DT             DW             DFS
FCB           FCC            FDB            RMB


        Mitsubishi MELPS-4500
        ---------------------

DATA          RES            SFR


        Mitsubishi M16
        --------------

DB            DD             DQ             DS             DT
DW


        Mitsubishi M16C
        ---------------

DB            DD             DQ             DS             DT
DW


        Intel MCS-48
        ------------

DB            DD             DQ             DS             DT
DW


        Intel MCS-(2)51
        ---------------

BIGENDIAN     BIT            DB             DD             DQ
DS            DT             DW             PORT           SFR
SFRB          SRCMODE


        Intel MCS-96
        ------------

ASSUME        DB             DD             DQ             DS
DT            DW
 

        Intel 8080/8085
        ---------------

DB            DD             DQ             DS             DT
DW            PORT

 
        Signetics 8X30x
        ---------------

LIV           RIV


        Philips XA
        ----------

ASSUME        BIT            DB             DC[.<size>]    DD 
DQ            DS[.<size>]    DT             DW             PADDING
PORT          SUPMODE


        AMD 29K
        -------

ASSUME        DB             DD             DQ             DS
DT            DW             EMULATED       SUPMODE


        Siemens 80C166/167
        ------------------

ASSUME        BIT            DB             DD             DQ
DS            DT             DW


        Zilog Zx80
        ----------

DB            DD             DEFB           DEFW           DQ
DS            DT             DW             EXTMODE        LWORDMODE


        Zilog Z8
        --------

DB            DD             DQ             DS             DT
DW            SFR


        Toshiba TLCS-900
        ----------------

DB            DD             DQ             DS             DT
DW            MAXIMUM        SUPMODE


        Toshiba TLCS-90
        ---------------

DB            DD             DQ             DS             DT
DW


        Toshiba TLCS-870
        ----------------

DB            DD             DQ             DS             DT
DW


        Toshiba TLCS-47(0(A))
        ---------------------

ASSUME        DB             DD             DQ             DS
DT            DW             PORT


        Toshiba TLCS-9000
        -----------------

DB            DD             DQ             DS             DT
DW


        Microchip PIC16C5x
        ------------------

DATA          RES            SFR            ZERO


        Microchip PIC16C5x
        ------------------

DATA          RES            SFR            ZERO


        Microchip PIC17C42
        ------------------

DATA          RES            SFR            ZERO


        SGS-Thomson ST6
        ---------------

ASCII         ASCIZ          ASSUME         BYTE           BLOCK
SFR           WORD      


        SGS-Thomson ST7
        ---------------

DC[.<size>]   DS[.<size>]    PADDING


        SGS-Thomson ST9
        ---------------

ASSUME        BIT            DB             DD             DQ
DS            DT             DW             REG


        6804
        ----

ADR           BYT            DFS            FCB            FCC
FDB           RMB            SFR


        Texas TM3201x
        -------------

DATA          PORT           RES


        Texas TM32C02x
        --------------

BFLOAT        BSS            BYTE           DATA           DOUBLE
EFLOAT        TFLOAT         LONG           LQxx           PORT
Qxx           RES            RSTRING        STRING         WORD


        Texas TMS320C3x
        ---------------

ASSUME        BSS            DATA           EXTENDED       SINGLE
WORD


        Texas TM32C05x
        --------------

BFLOAT        BSS            BYTE           DATA           DOUBLE
EFLOAT        TFLOAT         LONG           LQxx           PORT
Qxx           RES            RSTRING        STRING         WORD


        Texas TMS9900
        -------------

BSS           BYTE           PADDING        WORD


        Texas TMS70Cxx
        --------------

DB            DD             DQ             DS             DT
DW


        Texas TMS370
        ------------

DB            DBIT           DD             DQ             DS
DT            DW


        Texas MSP430
        ------------

BSS           BYTE           PADDING        WORD


        National SC/MP
        --------------

DB            DD             DQ             DS             DT
DW
	

        National COP8
        -------------

ADDR          ADDRW          BYTE           DB             DD
DQ            DS             DSB            DSW            DT
DW            FB             FW             SFR            WORD


        NEC uPD78C1x
        ------------

ASSUME        DB             DD             DQ             DS
DT            DW


        NEC 75K0
        --------

ASSUME        BIT            DB             DD             DQ
DS            DT             DW             SFR

   
        NEC 78K0
        --------

DB            DD             DQ             DS             DT
DW


        E. Predefined Symbols
        =====================

name         data type  definition  meaning

BIGENDIAN    boolean    dyn.(0)     storage of constants MSB first ?

CASESENSITIVE boolean   normal      case sensitivity in symbol names ?

CONSTPI      float      normal      constant Pi (3.1415.....)

DATE         string     predef.     date of begin of assembly
                                    (first pass)

FALSE        boolean    predef.     0 = logically "false"

HASFPU       boolean    dyn.(0)     coprocessor instructions enabled ?

HASPMMU      boolean    dyn.(0)     MMU instructions enabled ?

INEXTMODE    boolean    dyn.(0)     XM flag set for 4 Gbyte address 
                                    space ?

INLWORDMODE  boolean    dyn.(0)     LW flag set for 32 bit
                                    instructions ?

INMAXMODE    boolean    dyn.(0)     processor in maximum mode ?

INSUPMODE    boolean    dyn.(0)     processor in supervisor mode ?

INSRCMODE    boolean    dyn.(0)     processor in source mode ?

FULLPMMU     boolean    dyn.(0/1)   full PMMU instruction set
                                    allowed ?

LISTON       boolean    dyn.(1)     listing enabled ?

MACEXP       boolean    dyn.(1)     expansion of macro constructs in
                                    listing enabled ?

MOMCPU       integer    dyn.        number of target CPU currently
			(68008)	    set

MOMCPUNAME   string     dyn.        name of target CPU currently
                        (68008)     set

MOMFILE      string     special     current source file
                                    (including include files)

MOMLINE      integer    special     current line number in 
                                    source file

MOMPASS      integer    special     number of current pass

MOMSECTION   string     special     name of current section or
				    empty string if out of any
                                    section

MOMSEGMENT   string     special     name of address space currently
                                    selected with SEGMENT

PADDING      boolean    dyn.(1)     pad byte field to even count ?

RELAXED      boolean    dyn.(0)     any syntax allowed integer 
                                    constants ?

PC           integer    special     curr. program counter (Thomson)

TIME         string     predef.     time of begin of assembly
                                    (1. pass)

TRUE         integer    predef.     1 = logically "true"

VERSION      integer    predef.     version of AS in BCD coding,
				    e.g. 1331 hex for version 1.33p1

*            integer    special     curr. program counter (Motorola,
                                    Rockwell, Microchip, Hitachi)

$            integer    special     curr. program counter (Intel, Zilog,
                                    Texas, Toshiba, NEC, Siemens, AMD)

To be exact, boolean symbols are just ordinary integer symbols with the
difference that AS will assign only two different values to them (0 or 1,
corresponding to False or True).  AS does not store special symbols
in the symbol table.  For performance reasons, they are realized with
hardcoded comparisons directly in the parser.  They therefore do not
show up in the assembly listing's symbol table.  Predefined symbols
are only set once at the beginning of a pass.  The values of dynamic
symbols may in contrast change during assembly as they reflect
settings made with related pseudo instructions.  The values added in
parentheses give the value present at the beginning of a pass.

The names given in this table also reflect the valid way to reference
these symbols in case-sensitive mode.

The names listed here should be avoided for own symbols; either one
can define but not access them (special symbols), or one will receive
an error message due to a double-defined symbol.  The ugliest case is
when the redefinition of a symbol made by AS at the beginning of a
pass leads to a phase error and an infinite loop...


        F. Acknowledgments
        ===================

If one decides to rewrite a chapter that has been out of date for two
years, it is almost unavoidable that one forgets to mention some of
the good ghosts who contributed to the success this project had up
to now.  The first "thank you" therefore goes to the people whose
names I unwillingly forgot in the following enumeration!

The concept of AS as a universal cross assembler came from Bernhard
(C.) Zschocke who needed a "student friendly", i.e. free cross
assembler for his microprocessor course and talked me into extending
an already existing 68000 assembler.  The rest is history...
The microprocessor course held at RWTH Aachen also always provided the
most engaged users (and bug-searchers) of new AS features and
therefore contributed a lot to today's quality of AS.

The internet and FTP have proved to be a big help for spreading AS and
reporting of bugs.  My thanks therefore go to the FTP admins (Bernd
Casimir in Stuttgart, Norbert Breidor in Aachen, and Jürgen Meißburger
in Jülich).  Especially the last one personally engaged a lot to
establish a practicable way in Jülich.

As we are just talking about the ZAM: Though Wolfgang E. Nagel is not
personally involved into AS, he is at least my boss and always puts
at least four eyes on what I am doing.  Regarding AS, there seems to
be at least one that smiles...

A program like AS cannot be done without appropriate data books and
documentation.  I received information from an enormous amount of
people, ranging from tips up to complete data books.  An enumeration
follows (as stated before, without guarantee for completelessness!):

Ernst Ahlers, Charles Altmann, Bernd Casimir, Gunther Ewald,
Stephan Hruschka, Peter Kliegelhöfer, Ulf Meinke, Matthias Paul,
Norbert Rosch, Steffen Schmid, Leonhard Schneider, Oliver Sellke,   
Christian Stelter, Oliver Thamm, Thorsten Thiele.

...and an ironic "thank you" to Rolf-Dieter-Klein and Tobias Thiel who
demonstrated with their ASM68K how one should NOT do it and thereby
indirectly gave me the impulse to write something better!

I did not entirely write AS on my own. AS contains the OverXMS
routines from Wilbert van Leijen which can move the overlay modules
into the extended memory.  A really nice library, easy to use without
problems!

The TMS320C2x/5x code generators and the file STDDEF2x.INC come from
Thomas Sailer, ETH Zurich.  It's surprising, he only needed one weekend
to understand my coding and to implement the new code generator. 
Either that was a long nightshift or I am slowly getting old...


        G. Changes since Version 1.3
        ============================

version 1.31:  - additional MCS-51 processor type 80515.  The number
                 is again only stored by the assembler.  The file
                 STDDEF51.INC was extended by the necessary SFRs.
                 CAUTION! Some of the 80515 SFRs have moved to other
                 addresses!

               - additional support for the Z80 processor;
  
               - faster 680x0 code generator.

version 1.32:  - syntax for zero page addresses for the 65xx family
                 was changed from addr.z to <addr (similar to 68xx);

               - additional support for the 6800, 6805, 6301, and
                 6811 processors;

               - the 8051 part now also understands DJNZ, PUSH, and
                 POP (sorry);

               - the assembly listing now not also list the symbols
                 but also the macros that have been defined;

               - additional instructions IFDEF/IFNDEF for conditional
                 assembly based on the existence of a symbol;

               - additional instructions PHASE/DEPHASE to support code
                 that shall be moved at runtime to a different address;

               - additional instructions WARNING/ERROR/FATAL to print
                 user-defined error messages;

               - the file STDDEF51.INC additionally contains the macro
                 USING to simplify working with the MCS-51's register
                 banks;

               - command line option u to print segment usage;

version 1.33:  - additionally supports the 6809 processor;

               - added string variables;

               - The instructions TITLE, PRTINIT, PRTEXIT, ERROR,
                 WARNING, and FATAL now expect a string expression.
                 Constants therefore now have to be enclosed in 
                 " instead of ' characters.  This is also true
                 for DB, DC.B, and BYT;

               - additional instruction ALIGN to align the program
                 counter for Intel processors;

               - additional instruction LISTING to turn the generation
                 of an assembly listing on or off;

               - additional instruction CHARSET for user-defined 
                 character sets.

version 1.34:  - the second pass is now omitted if there were errors
                 in the first pass;

               - additional predefined symbol VERSION that contains
                 the version number of AS;

               - additional instruction MESSAGE to generate additional
                 messages under program control;

               - formula parser is now accessible via string constants;

               - if an error in a macro occurs, additionally the line
                 number in the macro itself is shown;

               - additional function UPSTRING to convert a string to
                 all upper-case.

version 1.35:  - additional function TOUPPER to convert a single 
                 character to upper case;

               - additional instruction FUNCTION for user-defined
                 functions;

               - additional command line option D to define symbols
                 from outside;

               - the environment variable ASCMD for commonly used
                 command line options was introduced;

               - the program will additionally be checked for double
                 usage of memory areas if the u option is enabled;

               - additional command line option C to generate a cross
                 reference list.

version 1.36:  - additionally supports the PIC16C5x and PIC17C4x 
                 processor families;

               - the assembly listing additionally shows the nesting
                 depth of include files;

               - the cross reference list additionally shows the
                 definition point of a symbol;

               - additional command line option A to force a more
                 compact layout of the symbol table.

version 1.37:  - additionally supports the processors 8086, 80186,
                 V30, V35, 8087, and Z180;

               - additional instructions SAVE and RESTORE for an
                 easier switching of some flags;

               - additional operators for logical shifts and bit
                 mirroring;

               - command line options may now be negated with a
                 plus sign;

               - additional filter AS2MSG for a more comfortable
                 work with AS under Turbo-Pascal 7.0;

               - ELSEIF now may have an argument for construction
                 of IF-THEN-ELSE ladders;

               - additional CASE construct for a more comfortable
                 conditional assembly;

               - user-defined functions now may have more than one
                 argument;

               - P2HEX can now additionally generate hex files in
                 a format suitable for 65xx processors;

               - BIND, P2HEX, and P2BIN now have the same scheme
                 for command line processing like AS;

               - additional switch i for P2HEX to select one out
                 three possibilities for the termination record;

               - additional functions ABS and SGN;

               - additional predefined symbols MOMFILE and MOMLINE;

               - additional option to print extended error messages;

               - additional instruction IFUSED and IFNUSED to check
                 whether a symbol has been used so far;

               - The environment variables ASCMD, BINDCMD etc. now
                 optionally may contain the name of a file that
                 provides more space for options;

               - P2HEX can now generate the hex formats specified
                 by Microchip (p4);

               - a page length specification of 0 now allows to
                 suppress automatic formfeeds in the assembly listing
                 completely (p4);

               - symbols defined in the command line now may be
                 assigned an arbitrary value (p5).

version 1.38:  - changed operation to multipass mode.  This enables
                 AS to generate optimal code even in case of forward
                 references;

               - the 8051 part now also knows the generic JMP and
                 CALL instructions;

               - additionally supports the Toshiba TLCS-900 series
                 (p1);

               - additional instruction ASSUME to inform the assembler
                 about the 8086's segment register contents (p2);

               - additionally supports the ST62xx series from
                 SGS-Thomson (p2);

               - ..and the 3201x signal processors from Texas
                 Instruments (p2);

               - additional option F for P2HEX to override the
                 automatic format selection (p2);

               - P2BIN now can automatically set the start resp.
                 stop address of the address window by specifying
                 dollar signs (p2);

               - the 8048 code generator now also knows the 8041/42
                 instruction extensions (p2);

               - additionally supports the Z8 microcontrollers (p3).

version 1.39:  - additional opportunity to define sections and local
                 symbols;

               - additional command line switch h to force hexadecimal
                 numbers to use lowercase;

               - additional predefined symbol MOMPASS to read the
                 number of the currently running pass;

               - additional command line switch t to disable
                 individual parts of the assembly listing;

               - additionally knows the L variant of the TLCS-900
                 series and the MELPS-7700 series from Mitsubishi
                 (p1);

               - P2HEX now also accepts dollar signs as start resp.
                 stop address (p2);

               - additionally supports the TLCS-90 family from 
                 Toshiba (p2);

               - P2HEX now also can output data in Tektronix and
                 16 bit Intel Hex format (p2);

               - P2HEX now prints warnings for address overflows
                 (p2);

               - additional include file STDDEF96.INC with address
                 definitions for the TLCS-900 series (p3);

               - additional instruction READ to allow interactive
                 input of values during assembly (p3);

               - error messages are written to the STDERR channel
                 instead of standard output (p3);

               - the STOP instruction missing for the 6811 is now
                 available (scusi,p3);

               - additionally supports the µPD78(C)1x family from
                 NEC (p3);

               - additionally supports the PIC16C84 from NEC (p3);

               - additional command line switch E to redirect error
                 messages to a file (p3);

               - The MELPS-7700's 'idol' 65816 is now also available
                 (p4);

               - the ST62xx pseudo instruction ROMWIN has been removed
                 was integrated into the ASSUME instruction (p4);

               - additionally supports the 6804 from SGS-Thomson (p4);

               - via the NOEXPORT option in a macro definition, it is
                 now possible to define individually for every macro
                 whether it shall appear in the MAC file or not (p4);

               - the meaning of MACEXP regarding the expansion of
                 macros has changed slightly due to the additional
                 NOEXPAND option in the macro definition (p4);

               - The additional GLOBAL option in the macro definition
                 now additionally allows to define macros that are
                 uniquely identified by their section name (p4).

version 1.40:  - additionally supports the DSP56000 from Motorola;

               - P2BIN can now also extract the lower resp. upper
                 half of a 32-bit word;

               - additionally supports the TLCS-870 and TLCS-47
                 families from Toshiba (p1);

               - a prefixed ! now allows to reach machine instructions
                 hidden by a macro (p1);

               - the GLOBAL instruction now allows to export symbols
                 in a qualified style (p1);

               - the additional r command line switch now allows to
                 print a list of constructs that forced additional
                 passes (p1);

               - it is now possible to omit an argument to the E
                 command line option; AS will then choose a fitting
                 default (p1);

               - the t command line option now allows to suppress
                 line numbering in the assembly listing (p1);

               - escape sequences may now also be used in ASCII style
                 integer constants (p1);

               - the additional pseudo instruction PADDING now allows
                 to enable or disable the insertion of padding bytes
                 in 680x0 mode (p2);

               - ALIGN is now a valid instruction for all targets
                 (p2);

               - additionally knows the PIC16C64's SFRs (p2);

               - additionally supports the 8096 from Intel (p2);

               - DC additionally allows to specify a repetition factor
                 (r3);

               - additionally supports the TMS320C2x family from Texas
                 Instruments (implementation done by Thomas Sailer, ETH
                 Zurich, r3); P2HEX has been extended appropriately;

               - an equation sign may be used instead of EQU (r3);

               - additional ENUM instruction to define enumerations
                 (r3);

               - END now has a real effect (r3);

               - additional command line switch n to get the internal 
                 error numbers in addition to the error messages (r3);

               - additionally supports the TLCS-9000 series from
                 Toshiba (r4);

               - additionally supports the TMS370xxx series from Texas
                 Instruments, including a new DBIT pseudo instruction
                 (r5);

               - additionally knows the DS80C320's SFR's (r5);

               - the macro processor is now also able to include files
                 from within macros.  This required to modify the
                 format of error messages slightly.  If you use
                 AS2MSG, replace it with the new version! (r5)

               - additionally supports the 80C166 from Siemens (r5);

               - additional VAL function to evaluate string
                 expressions (r5);

               - it is now possible to construct symbol names with the
                 help of string expressions enclosed in braces (r5);

               - additionally knows the 80C167's peculiarities (r6);

               - the MELPS740's special page addressing mode is now
                 supported (r6);

               - it is now possible to explicitly reference a symbol
                 from a certain section by appending its name enclosed
                 in brackets.  The construction with an @ sign has
                 been removed! (r6)

               - additionally supports the MELPS-4500 series from
                 Mitsubishi (r7);

               - additionally supports H8/300 and H8/300H series from
                 Hitachi (r7);

               - settings made with LISTING resp. MACEXP may now be
                 read back from predefined symbols with the same names
                 (r7);

               - additionally supports the TMS320C3x series from Texas
                 Instruments (r8);

               - additionally supports the SH7000 from Hitachi (r8);

               - the Z80 part has been extended to also support the
                 Z380 (r9);

               - the 68K part has been extended to know the
                 differences of the 683xx micro controllers (r9);

               - a label not any more has to be placed in the first
                 row if it is marked with a double dot (r9);

               - additionally supports the 75K0 series from NEC (r9);

               - the additional command line option o allows to set
                 a user-defined name for the code file (r9);

               - the ~~ operator has been moved to a bit more senseful
                 ranking (r9);

               - ASSUME now also knows the 6809's DPR register and its
                 implications (pardon, r9);

               - the 6809 part now also knows the 6309's secret
                 extensions (r9);

               - binary constants now also may be written in a C-like
                 notation (r9);

version 1.41:  - the new predefined symbol MOMSEGMENT allows to
                 inquire the currently active segment;

               - := is now allowed as a short form for SET/EVAL;

               - the new command line switch q allows to force a
                 "silent" assembly;

               - the key word PARENT to reference the parent section
                 has been extended by PARENT0..PARENT9;

               - the PowerPC part has been extended by the
                 microcontroller versions MPC505 and PPC403;

               - symbols defined with SET or EQU may now be assigned
                 to a certain segment (r1);

               - the SH7000 part now also knows the SH7600's
                 extensions (and should compute correct
                 displacements...) (r1);

               - the 65XX part now differentiates between the 65C02
                 and 65SC02 (r1);

               - additionally to the symbol MOMCPU, there is now also
                 a string symbol MOMCPUNAME that contains the
                 processor's full name (r1);

               - P2HEX now also knows the 32-bit variant of the Intel
                 hex format (r1);

               - additionally knows the 87C750's limitations (r2);

               - the internal numbers for fatal errors have been moved
                 to the area starting at 10000, making more space for
                 normal error messages (r2);

               - unused symbols are now marked with a star in the
                 symbol table (r2);

               - additionally supports the 29K family from AMD (r2);

               - additionally supports the M16 family from Mitsubishi
                 (r2);

               - additionally supports the H8/500 family from Hitachi
                 (r3);

               - the number of data bytes printed per line by P2HEX
                 can now be modified (r3);

               - the number of the pass that starts to output warnings
                 created by the r command line switch is now variable
                 (r3);

               - the macro processor now knows a WHILE statement that
                 allows to repeat a piece of code a variable number of
                 times (r3);

               - the PAGE instruction now also allows to set the line
                 with of the assembly listing (r3);

               - CPU aliases may now be defined to define new pseudo
                 processor devices (r3);

               - additionally supports the MCS/251 family from Intel
                 (r3);

               - if the cross reference list has been enabled, the
                 place of the first definition is given for double
                 definitions of symbols (r3);

               - additionally supports the TMS320C5x family from Texas
                 Instruments (implementation done by Thomas Sailer,
                 ETH Zurich, r3);

               - the OS/2 version should now also correctly work with
                 long file names.  If one doesn't check every s**t 
                 personally... (r3);

               - the new pseudo instruction BIGENDIAN now allows to
                 select in MCS-51/251 mode whether constants should
                 be stored in big endian or little endian format (r3);

               - the 680x0 part now differentiates between the full
                 and reduced MMU instruction set; a manual toggle can
                 be done via the FULLPMMU instruction (r3);

               - the new command line option I allows to print a list
                 of all include files paired with their nesting level
                 (r3);

               - additionally supports the 68HC16 family from Motorola
                 (r3);

               - the END statement now optionally accepts an argument
                 as entry point for the program (r3);

               - P2BIN and P2HEX now allow to move the contents of a
                 code file to a different address (r4);

               - comments appended to a SHARED instruction are now
                 copied to the share file (r4);

               - additionally supports the 68HC12 family from Motorola
                 (r4);

               - additionally supports the XA family from Philips
                 (r4);

               - additionally supports the 68HC08 family from Motorola
                 (r4);

               - additionally supports the AVR family from Atmel (r4);

               - to achieve better compatibility to the AS11 from
                 Motorola, the pseudo instructions FCB, FDB, FCC, and
                 RMB were added (r5);

               - additionally supports the M16C from Mitsubishi (r5);

               - additionally supports the COP8 from National
                 Semiconductor (r5);

               - additional instructions IFB and IFNB for conditional
                 assembly (r5);

               - the new EXITM instruction now allows to terminate a
                 macro expansion (r5);

               - additionally supports the MSP430 from Texas
                 Instruments (r5);

               - LISTING now knows the additional variants NOSKIPPED
                 and PURECODE to remove code that was not assembled
                 from the listing (r5);

               - additionally supports the 78K0 family from NEC (r5);

               - BIGENDIAN is now also available in PowerPC mode
                 (r5);

               - additional BINCLUDE instruction to include binary
                 files (r5);

               - additional TOLOWER and LOWSTRING functions to convert
                 characters to lower case (r5);

               - it is now possible to store data in other segments
                 than CODE.  The file format has been extended
                 appropriately (r5);

               - the DS instruction to reserve memory areas is now
                 also available in Intel mode (r5);

               - the U command line switch now allows to switch AS
                 into a case sensitive mode that differentiates
                 between upper and lower case in the names of symbols,
                 user-defined functions, macros, macro parameters, and 
                 sections (r5);

               - SFRB now also knows the mapping rules for bit
                 addresses in the RAM areas; warnings are generated
                 for addresses that are not bit addressable (r5);

               - additional instructions PUSHV and POPV to save symbol
                 values temporarily (r5);

               - additional functions BITCNT, FIRSTBIT, LASTBIT, and
                 BITPOS for bit processing (r5);

               - the 68360 is now also known as a member of the CPU32
                 processors (r5);

               - additionally supports the ST9 family from SGS-Thomson
                 (r6);

               - additionally supports the SC/MP from National
                 Semiconductor (r6);

               - additionally supports the TMS70Cxx family from Texas
                 Instruments (r6);

               - additionally supports the TMS9900 family from Texas
                 Instruments (r6);

               - additionally knows the 80296's instruction set
                 extensions (r6);

               - the supported number of Z8 derivatives has been
                 extended (r6);

               - additionally knows the 80C504's mask defects (r6);

               - additional register definition file for Siemens' C50x
                 processors (r6);

               - additionally supports the ST7 family from SGS-Thomson
                 (r6);

               - the Intel pseudo instructions for data disposal are
                 now also valid for the 65816/MELPS-7700 (r6);

               - for the 65816/MELPS-7700, the address length may now
                 be set explicitly via prefixes (r6);

               - additionally supports the 8X30x family from
                 Signetics (r6);

        
        H. Hints for the AS Source Code
        ===============================

As I already mentioned in the introduction, I release the source code of
AS on request.  the following shall give a few hints to their usage.

        H.1. Language Preliminaries
        ---------------------------

AS has been implemented in Turbo-Pascal.  "Ouch", I hear the C freaks
crying, "such a thing is easier done in C, and it would be universally
portable!".  Welllll, if things were that simple...AS is a project I
have been working on for several years now, and the operating system
world of a PC user at that time consisted of DOS, DOS, and again -
DOS.  My experience that I had to juggle with 4 floppies to use
Turbo-C and that Turbo-Pascal still fitted on one was still very
alive.  The jungle of memory models offered by a DOS C compiler also
did not make the language more attractive.  Pascal was furthermore
the language I knew best, and it was the language that gave me the
highest productivity.  I had tried C a few times, and it gave me an
impression of chaos and archaism:

  - The structurization on top of the function level is
    assembler-like (like a usual assembler, sections and local
    variables enable AS to do a bit more than C in this respect),
    i.e. there is no way to define a procedure that is local to
    another procedure and has access to all its variables.  Language
    extensions like in GNU-C do not help if you want to stay
    portable!

  - Something comparable to Pascal's WITH statement is missing.

  - If one limited oneself to the K&R standard that was still
    commonplace at that time, there was practically no way for a
    compile-time check of function parameters.

  - There is no way to define a function that returns a string by
    VALUE.  This forces the programmer to use cumbersome additional
    code to copy things back and forth.

All this lead to the result that I used Turbo Pascal to implement AS,
and it stayed that way until today.  The times however have changed:
With the demise of Borland's Turbo/Borland Pascal line, the only
Pascal compiler that is still supported is Delphi, something that is
IMHO only good for programs that consist of 90% user interface,
completely unusable for a command-line driven like AS.  My operating
system focus also meanwhile changed into the direction of Unix, and
the ANSI standard is now widely accepted.  A port of the AS source
code to C is almost finished, but the Pascal version is currently
still the "reference".  Borland Pascal version 7 is recommended for
compilation; version 6 should also work, but you will not be able to
use some features (like protected mode).

An important hint for users of version 7.0 of Turbo/Borland Pascal:
As one should know, this version has some bugs, which was also the
reason for Borland having to release a version 7.01.  AS is affected
by the problem because it partially uses longint shifts of more than
16 bits; the version 7.0 contains a faulty 386 optimization for this
case.  If you did not want to spend the money for the update (like
me) but have the runtime library's sources, you can fix the bug on
you own by replacing the erroneous routines in LONG.ASM, like this:

; Longint shift right
; In	DX:AX = Value
;	CX    = Shift count
; Out	DX:AX = Result
; Correction 11.6.1994 AA

LongShr:

	CMP	Test8086,2
	JB	@@1
    .386
        SHL     EAX,16
        SHRD    EAX,EDX,16
        SHR     EAX,CL
        SHLD    EDX,EAX,16
	RETF
    .8086
@@1:	AND	CX,1FH
	JE	@@3
@@2:	SHR	DX,1
	RCR	AX,1
	LOOP	@@2
@@3:	RETF

; Longint shift left
; In	DX:AX = Value
;	CX    = Shift count
; Out	DX:AX = Result
; Correction 11.6.1994 AA

LongShl:

	CMP	Test8086,2
	JB	@@1
    .386
        SHL     EAX,16
        SHRD    EAX,EDX,16
        SHL     EAX,CL
        SHLD    EDX,EAX,16
	RETF
    .8086
@@1:	AND	CX,1FH
	JE	@@3
@@2:	SHL	AX,1
	RCL	DX,1
	LOOP	@@2
@@3:	RETF

People without the sources may alternitavely use the "emergency fix"
to set the predefined variable Test8086 to a value smaller than 2
right at the main program's beginning, thereby disabling the
optimizations at all...


        H.2 Module Separation
        ---------------------

Programs that have a size like AS necessarily have to be split into
several modules, not only to get things better structured, but also
to surpass DOS's eternal 64Kbytes limit.  In detail, AS consists of
the following modules:

        STDINC.PAS

This is an include file and not a module in the word's real sense. 
It contains the unavoidable compiler switches that also unavoidably
vary from one platform to another.

        AS.PAS

This file contains the main module of AS and therefore has to be
entered as "Primary File" in the IDE.  It contains the overall
control mechanisms for the individual passes, routines to read from
the source file(s), and parts of the macro processor.  This part is
independent of the target processor.

        ASMDEF.PAS

This module only contains declarations of commonly used constants and
global variables.  

        ASMSUB.PAS

This is the place where some frequently used subroutines are
collected.  They mainly cover string manipulation and error handling.

        ASMPARS.PAS

This is the place where you really go into AS's guts: This module
stores the symbol tables (global and local symbols) in two binary
trees.  It furthermore contains a rather large procedure
EvalExpression that analyzes and evaluates a formula expression.  The
procedure delivers the result (integer, floating point or string) as
a variable record.  One should however instead use the functions
EvalIntExpression, EvalFloatExpression, and EvalStringExpression for
code generation.  No modifications at this place are necessary to add
a new processor.  Changes at this place should generally done with
great caution, as you are working at the base of AS!

        ASMMAC.PAS

This module contains several routines to store and retrieve macros. 
The real macro processor is part of AS.PAS!!

        ASMIF.PAS

All routines that control conditional assembly are grouped in this
module.  The only exported variable of importance is the flag IfAsm
that signifies whether code generation is currently turned on or off.

        ASMCODE.PAS

This module contains the housekeeping necessary for the code output
file.  It exports an interface that allows to open and close a code
file and to write code to the file (resp. to retract code already
written).  An important task of this module is to buffer the write
operation.  This buffering increases the speed of output by writing
the code in larger chunks.

        CODEALLG.PAS

This module deals with pseudo instructions defined for all target
processors, like EQU or ORG.  The CPU instruction that switches among
different target processors is also located in this module.  

        CODEPSEU.PAS

You will find at this place pseudo instructions that are used by a
couple of code generators.  On the one hand, this is the Intel group
of DB..DT, and on the other hand their counterparts for 8/16 bit CPUs
from Motorola or Rockwell.  Someone who wants to extend AS by a
processor fitting into one of these groups can get the biggest part
of the necessary pseudo instructions with one call to this module.

        DECODECM.PAS

This module implements the mechanism of command line parameters.  It
needs a specification of all valid parameters, parses the command line
and makes calls to the appropriate callbacks.  The mechanism will in
detail do the following:

  - processing of options stored in an environment variable or a
    corresponding file;

  - return of a set that describes which parameters have not been
    processed;

  - distinction between normal and negated switches;

  - a backdoor for cases where a development environment placed on top
    of AS can only output command lines completely in upper or lower
    case.

This module is not only used by AS; the tools BIND, P2HEX, and P2BIN
also include it.

        STDHANDL.PAS

This is by far the shortest module and exists only for one purpose
(which may make it also useful for other programs): it extends Pascal
by the ability known from C to write to other channels than the
standard output:

 - STDERR (output channel for error messages)
 - STDPRN (default printer)
 - STDAUX (serial port)

These channels are predefined by DOS and are now accessible via
normal text variables.  AS currently only uses STDERR.

         NLS.PAS

This module deals with an issue Borland and other programmers usually
pay very little attention to: the national language support DOS
offers starting with version 2.0.  This unit delivers information
about things that are different from one country to another:

- date format: order of day, month, and year and the separation
  character;
- time format: 12 or 24 hour format;
- translation from lower to upper case;
- separation characters for fractions and thousands places in
  numbers;
- currency names and formats;
- collation order of characters.

AS currently does not use all information offered by this unit (what
should an assembler do with money ;-) ), but NLS support will become
better in the future.  This is a unit that is especially suited for
use in other programs: simple inclusion delivers an UpCase function
that works correctly for all characters, something that Borland did
not offer though people have been quarreling for years about it!

        STRINGLI.PAS 

This is only a small "hack" to supply routines that deal with linear
lists of strings, something needed e.g. in the macro processor of AS.

        STRINGUT.PAS 

This is the place where some very common string manipulations are
located.

        CHUNKS.PAS   

This module defines a data type that can store a list of address
ranges.  AS uses this function to create usage lists, and P2BIN and
P2HEX use it to warn about overlaps in memory.

        INCLIST.PAS  

This module defines the list structure that enables AS to print a
list about which include files have been included together with their
nesting.

        FILENUMS.PAS

AS tokenizens file names in many situations, i.e. they are stored as
numerical codes instead of their full name.  This module keeps lists
that allow a translation between file names and tokens.

        CODExxxx.PAS 

Last but not least, these files contain the code generators for the
different target processors.  They are built according to the same
scheme (but obviously with different contents!) which is explained in
the following section.


        H.3. A New Processor...And Now?
        -------------------------------

The probably most common reason for a modification of AS's source
code is probably the extension to a new target processor.  The way to
do this has dramatically changed with version 1.39p5: it has become a
lot more indirect but it has the advantage that there is only ONE
place in the standard modules left that has to be modified.  The
method heavily relies on indirect references and procedural
variables, so a bit more advanced knowledge about (Turbo) Pascal is
required.  Nevertheless, it should not bear any principal problems. 
I will describe the steps necessary to introduce a new target CPU in
a cookbook style:


        Choosing the Processor's Name
        - - - - - - - - - - - - - - -

The name chosen for the new processor has to fulfill two criterias:

 1. The name must not be already in use by another processor.  If one
    starts AS without any parameters, a list of the names already in
    use will be printed.

 2. If the name shall appear completely in the symbol MOMCPU, it may
    not contain other letters than A..F (except right at the
    beginning).  The variable MOMCPUNAME however will always report
    the full name during assembly.  Special characters are generally
    disallowed, lowercase letters will be converted by the CPU
    command to uppercase letters and are therefore senseless in the
    processor name.


        Definition of the Code Generator Module
        - - - - - - - - - - - - - - - - - - - - -

The unit's name that shall be responsible for the new processor
should bear at least some similarity to the processor's name (just
for the sake of uniformity) and should be named in the style of
CODExxxx.  The unit head with compiler switches and Uses statements
is best taken from another existing code generator.

The unit neither has to export variable nor procedures or functions
as the complete communication is done at runtime via indirect calls. 
The initializations necessary for this have to be done in the unit's
initialization part.  They are simply done by a call to the function
AddCPU for each processor type that shall be treated by this unit:

   CPUxxxx:=AddCPU('XXXX',SwitchTo_xxxx);

'XXXX' is the name chosen for the processor which later must be used
in assembler programs to switch AS to this target processor. 
SwitchTo_xxxx (abbreviated as the "switcher" in the following) is a
procedure without parameters that is called by AS when the switch to
the new processor actually takes place.  AddCPU delivers an integer
value as result that serves as an internal "handle" for the new
processor.  The global variable MomCPU always contains the handle of
the target processor that is currently set.  The value returned by
AddCPU should be stored in a private variable of type CPUVar (called
CPUxxxx in the example above).  In case a code generator module
implements more than one processor (e.g. several processors of a
family), the module can find out which instruction subset is
currently allowed by comparing MomCPU against the stored handles.

The switcher's task is to "reorganize" AS for the new target
processor.  This is done by changing the values of several global
variables:

  - ConstMode: This variable may take the values ConstModeIntel,
    ConstModeMoto, or ConstModeC and rules which syntax has to be
    used to specify the base of integer constants.

  - PCSymbol: This variable contains the string an assembler program
    may use to to get the current value of the program counter. 
    Intel processors for example usually use a dollar sign.

  - HeaderID: This variable contains the ID that is used to mark the
    current processor family in the the code output file (see the
    description of the code format described by AS).  I urge to
    contact me before selecting the value to avoid ambiguities.
    Values outside the range of $01..$7f should be avoided as they
    are reserved for special purposes (like a future extension to
    allow linkable code).

  - NOPCode: There are some situations where AS has to fill unused
    code areas with NOP statements.  This variable contains the
    machine code of the NOP statement.

  - SetIsOccupied: Some processors have a SET machine instruction.
    AS will allow SET instructions to pass through to the code
    generator and instead use EVAL if this flag is set.

  - ValidSegs: Not all processors have all address spaces defined
    by AS.  This set defines which subset the SEGMENT instruction
    will enable for the currently active target processor.  At least
    the CODE segment has to be enabled.  The complete set of allowed
    segments can be looked up the module ASMDEF (Seg.... constants).

  - SegInits: This array stores the initial program counter values
    for the individual segments (i.e. the values the program counters
    will initially take when there is no ORG statement).  There are 
    only a few exceptions (like logically separated address spaces
    that physically overlap) which justify other initial values than
    0.

  - Grans: This array specifies the size of the smallest addressable
    element in bytes for each segment, i.e. the size of an element
    that increases an address by 1.  Most processors need a value of
    1, even if they are 16- or 32-bit processors, but the PICs and
    signal processors are cases where higher values are required.

  - ListGrans: This array specifies the size of byte groups that shall
    be shown in the assembly listing.  For example, instruction words
    of the 68000 are always 2 bytes long though the code segment's
    granularity is 1.  The ListGran entry therefore has to be set to
    2.

  - TurnWords: If the target processor uses big-endian addressing and
    one of the fields in ListGran is larger than one, set this flag
    to true to get the correct byte order in the code output file.

  - DivideChars: This string contains the characters that are valid
    separation characters for instruction parameters.  Only extreme
    exotics like the DSP56 require something else than a single comma
    in this string.

  - HasAttrs: Some processors like the 68k series additionally split
    an instruction into mnemonic and attribute.  If the new processor
    also does something like that, set this flag to true and AS will
    deliver the instructions' components readily split in the string
    variables OpPart and AttrPart.  If this flag is however set to
    false, no splitting will take place and the instruction will be
    delivered as a single piece in OpPart.  AttrPart will stay empty
    in this case.  One really should set this flag to false if the
    target processor does not have attributes as one otherwise looses
    the opportunity to use macros with a name containing dots (e.g.
    to emulate other assemblers).

  - AttrChars: In case HasAttrs is true, this string has to contain 
    all characters that can separate mnemonic and attribute.  In most
    cases, this string only contains a single dot.

Do not assume that any of these variables has a predefined value; set
them ALL!!

Apart from these variables, there are three procedure variables to be
set that form the link form AS to the "active" parts of the code
generator:

  - MakeCode: This routine is called after a source line has been
    split into mnemonic and parameters.  The mnemonic is stored into
    the variable OpPart, and the parameters can be looked up in the
    array ArgStr.  The number of arguments may be read from ArgCnt.
    The binary code has to be stored into the array BAsmCode, its
    length into CodeLen.  In case the processor is word oriented
    like the 68000 (i.e. the ListGran element corresponding to the
    currently active segment is 2), the field may be addressed
    wordwise via WAsmCode.  There is also DAsmCode for extreme
    cases... The code length has to be given in units corresponding
    to the current segment's granularity.

  - Most processors use only an address space that is much smaller
    than the 32 address bits offered by AS.  This function tells AS
    if the program counter's current value is out of the allowed
    address range.  It may naturally become a bit more complex
    if the processor has more than one address space.  Such an example
    is the ChkPC routine found in the MCS-51/251 code generator
    Code51.  The function should return TRUE if everything is fine
    and otherwise FALSE.  CAUTION!  Turbo Pascal currently does not
    support unsigned 32 bit integers so one might have to deal with
    negative program counter values!  A check if the current program
    counter is smaller than zero is therefore necessary!

  - IsDef: Some processors know additional instructions that impose a
    special meaning on a label in the first row like EQU does.  One
    example is the BIT instruction found in an 8051 environment. 
    This function has to return TRUE if such a special instruction is
    present.  In the simplest case (no such instructions), the
    routine may return a constant FALSE.

  - SwitchFrom: This parameter-less procedure enables the code
    generator module to do "cleanups" when AS switches to another
    target processor.  This hook allows e.g. to free memory that has
    been allocated in the generator and that is not needed as long as
    the generator is not active.  It may point to an empty procedure
    in the simplest case.  One example for the usage of this hook is
    the module CODE370 that builds its instruction tables dynamically
    and frees them again after usage.

All these routines do not receive any parameters and have to be coded 
as FAR procedures (like the switcher itself); assignment to procedure
variables would otherwise be impossible.

If needed, the unit may also use its initialization part to hook into
a list of procedures that are called prior to each pass of assembly.
Such a need for example arises when the module's code generation
depends on certain flags that can be modified via pseudo
instructions.  An example is a processor that can operate in either
user or supervisor mode.  In user mode, some instructions are
disabled.  The flag that tells AS whether the following code executes
in user or supervisor mode might be set via a special pseudo
instruction.  But there must also be an initialization that assures
that all passes start with the same state.  The hook offered via
InitPassProc offers a chance to do such initializations.  The
principle is similar to the redirection of an interrupt vector: the
unit saves the old value prior to pointing the procedure variable to
its own routine (the routine must be parameter-less and FAR coded).
The new routine first calls the old chain of procedures and
afterwards does its own operations.

From time to time, a processor architecture provides symbols that do
not have to be defined explicitly.  An example for this is the TMS370
series that allows to reference the first 256 memory addresses as
"registers" R0..R255 resp. R0FF.  AS provides the procedure variable
InternSymbol that may be set by the code generator.  The parser calls
this procedure directly after the check for constants whenever an
expression has to be analyzed.  The routine has to store the result
in a record of type TempResult passed by reference when an internal
symbol has been detected.  The record's Type field has to carry the
result type (TempInt for integral values, TempFloat for floating
point values, or TempString for strings) and the result itself has to
be stored in the respective fields Int, Float, or Ascii.  If the
check was without success, simply set the Type field to TempNone. 
Errors messages from this routine should be avoided as unidentified
names could signify ordinary symbols (the parser will check this
afterwards).  Be extreme careful with this routine as it allows you
to intervene into the parser's heart!

By the way: People who want to become immortal may add a copyright
string.  This is done by adding a call to the procedure AddCopyright
in the unit's initialization part (right next to the AddCPU calls):

    AddCopyright("Intel 80986 code generator (C) 2010 Jim Bonehead");

The string passed to AddCopyright will be printed upon program start
in addition to the standard message.


        Inserting the Code Generator Module
        - - - - - - - - - - - - - - - - - -

While it may be difficult to write a code generator that is formally
correct, its addition to AS becomes trivial: The only thing that has
to be done is to add the unit to the USES list of the main module
AS.PAS.  The definition as resident or overlay module is a decision
between speed and free memory.


        Writing the Code Generator itself
        - - - - - - - - - - - - - - - - -

Now we finally reached the point where your creativity is challenged:
It is up to you how you manage to translate mnemonic and parameters
into a sequence of machine code.  The symbol tables are of course
accessible (via the formula parser) just like everything exported
from ASMSUB.  Some general rules (take them as advises and not as
laws...):

  - Try to split the instruction set into groups of instructions that
    have the same operand syntax and that differ only in a few bits
    of their machine code.  For example, one can do all instructions
    without parameters in a single table this way.

  - Most processors have a fixed spectrum of addressing modes.  Place
    the parsing of an address expression in a separate routine so you
    an reuse the code.

  - The subroutine WrError defines a lot of possible error codes and
    can be easily extended.  Use this!  It is no good to simply issue
    a "syntax error" on all error conditions!

Studying other existing code generators should also prove to be
helpful.


        Modifications of  Tools
        - - - - - - - - - - - -

PLIST's array of code headers has to be expanded to enable it to list
code files containing code for the new processor.

In case one of the segments should have a granularity other than one
byte per address (see the discussion of the Gran variable above), the
function Granularity in TOOLS.PAS has to be extended.  On further has
to decide which hex output format should be used by default.  Without
an extension of the CASE statement in ProcessFile, P2HEX will
terminate with an error message if no hex format is specified
explicitly in the command line.  P2HEX up to now knows how to create
Motorola S-Records (up to 32 bits), Intel-, Tektronix-, and MOS hex.


        H.4. RSC...what's that?
        -----------------------

It is necessary to modify all string constants AS uses in case one
wants to adapt AS to a different language.  These strings are
collected in RSC files to make such a translation simpler. 
IOERRORS.RSC contains all I/O error messages and is used by AS and
the tools.  TOOLS.RSC contains string constants that are used by all
tools.  Otherwise, every program has its own RSC file.  You do not
have to care about RSC files as long as you do not intend to
translate as to another language.


        I. Bibliography
        ===============

[Williams]	Steve Williams:
		68030 Assembly Language Reference.
		Addison-Wesley, Reading, Massachusetts, 1989

[AMD29K]	Advanced Micro Devices:
		AM29240, AM29245, and AM29243 RISC Microcontrollers.
		1993

[AtAVR]         Atmel Corp.:
                AVR Enhanced RISC Microcontroller Data Book.
                May 1996

[CMD816]  	CMD Microcircuits:
		G65SC802/G65SC816 CMOS 8/16-Bit Microprocessor
		Family Data Sheet.

[CPM68K]  	Digital Research:
		CP/M 68K Operating System User's Guide.
        	1983

[Cyrix]  	Cyrix Corp.:
		FasMath 83D87 User's Manual.
		1990

[Dallas320]  	Dallas Semiconductor:
		DS80C320 High-Speed Micro User's Guide.
		Version 1.30, 1/94

[Hit180]  	Hitachi Ltd.:
		8-/16-Bit Microprocessor Data Book.
		1986

[Hit63]  	Trevor J.Terrel & Robert J. Simpson:
		Understanding HD6301X/03X CMOS Microprocessor
                Systems.
		published by Hitachi

[HitH8_3]  	Hitachi Microcomputer:
		H8/300H Series Programming Manual.
		(21-032, no year of release given)

[SH7000] 	Hitachi Semiconductor Design & Development Center:
		SH Microcomputer Hardware Manual (Preliminary)

[HitH8_5] 	Hitachi Semiconductor and IC Div:
        	H8/500 Series Programming Manual.
        	(21-20, 1st Edition Feb. 1989)

[HitH8_532] 	Hitachi Ltd.:
        	H8/532 Hardware Manual.
		(21-30, no year of release given)

[HitH8_534] 	Hitachi Ltd.:
        	H8/534,H8/536 Hardware Manual.
		(21-19A, no year of release given)

[PPC403] 	IBM Corp.:
		PPC403GA Embedded Controller User's Manual.
        	First Edition, September 1994

[IntEmb] 	Intel Corp.:
		Embedded Controller Handbook.
		1987

[IntMic] 	Intel Corp.:
		Microprocessor and Peripheral Handbook.
		Volume I Microprocessor
		1988

[Int196]        Intel Corp.:
                8XC196NT Microcontroller User's Manual.
                June 1995 

[Int251]        Intel Corp.:
                8XC251SB High Performance CHMOS Single-Chip
                Microcontroller.
                Sept. 1995, Order Number 272616-003

[Int296]        Intel Corp.:
                80296SA Microcontroller User's Manual.
                Sept. 1996 

[Kaku] 		Hirotsugu Kakugawa:
		A memo on the secret features of 6309.
        	(available via World Wide Web:
        	http://www.cs.umd.edu/users/fms/comp/CPUs/6309.txt)

[MicroChip] 	Microchip Technology Inc.:
		Microchip Data Book.
		1993 Edition

[Mit41] 	Mitsubishi Electric:
		Single-Chip 8-Bit Microcomputers.
        	Vol.2, 1987

[Mit16] 	Mitsubishi Electric:
		Single-Chip 16-Bit Microcomputers.
		Enlarged edition, 1991

[Mit8] 		Mitsubishi Electric:
		Single-Chip 8 Bit Microcomputers.
        	Vol.2, 1992

[Mit4500] 	Mitsubishi Electric:
		M34550Mx-XXXFP Users's Manual.
		Jan. 1994

[MitM16] 	Mitsubishi Electric:
        	M16 Family Software Manual.
        	First Edition, Sept. 1994

[MitM16C] 	Mitsubishi Electric:
        	M16C Software Manual.
        	First Edition, Rev. C, 1996

[Mit30600]      Mitsubishi Electric:
                M30600-XXXFP Data Sheet.
                First Edition, April 1996

[GreenM16] 	documentation about the M16/M32-developer's package
                from Green Hills Software

[MotMic] 	Motorola Inc.:
		Microprocessor, Microcontroller and Peripheral Data.
		Vol. I+II, 1988

[Mot81] 	Motorola Inc.:
		MC68881/882 Floating Point Coprocessor User's Manual.
		Second Edition, Prentice-Hall, Englewood Cliffs 1989

[Mot51] 	Motorola Inc.:
		MC68851 Paged Memory Management Unit User's Manual.
		Second Edition, Prentice-Hall, Englewood Cliffs 1989,1988

[Mot32] 	Motorola Inc.:
		CPU32 Reference Manual.
        	Rev. 1, 1990

[Mot56] 	Motorola Inc.:
		DSP56000/DSP56001 Digital Signal Processor User's Manual.
		Rev. 2, 1990

[Mot340] 	Motorola Inc.:
		MC68340 Technical Summary.
        	Rev. 2, 1991

[Mot16]         Motorola Inc.:
                CPU16 Reference Manual.
                Rev. 1, 1991

[Mot332] 	Motorola Inc.:
		MC68332 Technical Summary.
        	Rev. 2, 1993

[Mot601] 	Motorola Inc.:
		PowerPC 601 RISC Microprocessor User's Manual.
		1993

[Mot505]	Motorola Inc.:
		PowerPC(tm) MPC505 RISC Microcontroller Technical Summary.
        	1994

[Mot12]         Motorola Inc.:
                CPU12 Reference Manual.
                1st edition, 1996

[Mot08]         Motorola Inc.:
                CPU08 Reference Manual.
                Rev. 1 (no year of release given im PDF-File)

[Mot360]        Motorola Inc:
                MC68360 User's Manual.

[SCMP]          National Semiconductor:
                SC/MP Programmier- und Assembler-Handbuch.
                Publication Number 4200094A, Aug. 1976

[AsmCop]        National Semiconductor:
                COP800 Assembler/Linker/Librarian User's Manual.
                Customer Order Number COP8-ASMLNK-MAN
                NSC Publication Number 424421632-001B
                August 1993

[Cop87L84]      National Semiconductor:
                COP87L84BC microCMOS One-Time-Programmable (OTP) Microcontroller.
                Preliminary, March 1996

[NECV] 		NEC Corp.:
		µpD70108/µpD70116/µpD70208/µpD70216/µpD72091 Data Book.
		(no year of release given)

[NEC78] 	NEC Electronics Europe GmbH:
		User's Manual µCOM-87 AD Family.
		(no year of release given)

[NEC75] 	NEC Corp.:
		µCOM-75x Family 4-bit CMOS Microcomputer User's Manual.
        	Vol. I+II (no year of release given)

[NEC78]         NEC Corp.:
                µPD78070A, 78070AY 8-Bit Single-Chip Microcontroller
                User's Manual.
                Document No. U10200EJ1V0UM00 (1st edition), August 1995

[NEC7814]       NEC Corp.:
                Data Sheet uPD78014.

[PhilXA]        Philips Semiconductor: 
                16-bit 80C51XA Microcontrollers (eXtended
                Architecture).
                Data Handbook IC25, 1996

[SGS04] 	SGS-Thomson Microelectronics:
		8 Bit MCU Families EF6801/04/05 Databook.
		1st edition, 1989

[SGS62] 	SGS-Thomson Microelectronics:
		ST6210/ST6215/ST6220/ST6225 Databook.
		1st edition, 1991

[ST7Man]        SGS-Thomson Microelectronics:
                ST7 Family Programming Manual.
                June 1995

[SGS9]          SGS-Thomson Microelectronics:
                ST9 Programming Manual.
                3rd edition, 1993

[Siem166] 	Siemens AG:
		SAB80C166/83C166 User's Manual.
		Edition 6.90

[Siem167] 	Siemens AG:
		SAB C167 Preliminary User's Manual.
		Revision 1.0, July 1992

[Siem502]       Siemens AG:
                SAB-C502 8-Bit Single-Chip Microcontroller User's Manual.
                Edition 8.94

[Siem501]       Siemens AG:
                SAB-C501 8-Bit Single-Chip Microcontroller User's Manual.
                Edition 2.96

[Siem504]       Siemens AG:
                C504 8-Bit CMOS Microcontroller User's Manual.
                Edition 5.96

[Syb68K] 	C.Vieillefond:
		Programmierung des 68000.
		Sybex-Verlag Düsseldorf, 1985

[Ti9900]        Texas Instruments:
                TMS9995 16-Bit Microcomputer
                Preliminary Data Manual.
                1981

[TiC10] 	Texas Instruments:
		First-Generation TMS320 User's Guide.
		1988, ISBN 2-86886-024-9

[Ti7000]        Texas Instruments:
                TMS7000 family Data Manual.
                1991, DB103

[TiC30] 	Texas Instruments:
		TMS320C3x User's Guide.
		Revision E, 1991

[TiC20] 	Texas Instruments:
		TMS320C2x User's Guide.
		Revision C, Jan. 1993

[Ti370] 	Texas Instruments:
		TMS370 Family Data Manual.
		1994, SPNS014B

[Ti430FamSoft]  Texas Instruments:
                MSP430 Family Software User's Guide.
                1994, SLAUE11

[Ti430Met]      Texas Instruments:
                MSP430 Metering Application.
                1996, SLAAE10A

[Ti430FamArch]  Texas Instruments:
                MSP430 Family Architecture User's Guide.
                1995, SLAUE10A

[Tosh90] 	Toshiba Corp.:
		8-Bit Microcontroller TLCS-90 Development System Manual.
		1990

[Tosh870] 	Toshiba Corp.:
		8-Bit Microcontroller TLCS-870 Series Data Book.
		1992

[Tosh900] 	Toshiba Corp.:
		16-Bit Microcontroller TLCS-900 Series Users Manual.
		1992

[Tosh900L] 	Toshiba Corp.:
		16-Bit Microcontroller TLCS-900 Series Data Book:
		TMP93CM40F/TMP93CM41F.
		1993

[Tosh47] 	Toshiba Corp.:
		4-Bit Microcontroller TLCS-47E/47/470/470A Development
		System Manual.
		1993

[Tosh9000] 	Toshiba Corp.:
		TLCS-9000/16 Instruction Set Manual Version 2.2 .
		10. Feb 1994

[Val8X]         Valvo GmbH:
                Bipolare Mikroprozessoren und bipolare
                LSI-Schaltungen 
                Datenbuch, 1985, ISBN 3-87095-186-9

[Zilog] 	data sheets from Zilog about the Z80 family

[ZilZ8] 	Zilog Inc.:
		Z8 Microcontrollers Databook.
		1992

[ZilZ8_2]       Zilog Inc.:
                Discrete Z8 Microcontrollers Databook.
                (no year of release given)

[ZilZ380] 	Zilog Inc.:
		Z380 CPU Central Processing Unit User's Manual.
        	(no year of release given)

