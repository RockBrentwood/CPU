







			   Makroassembler AS V1.41
			      Benutzeranleitung

                              Stand Juli 1997



			     Inhaltsverzeichnis




     1. Einleitung

      1.1. Lizenzbedingungen

      1.2. allgemeine Fähigkeiten des Assemblers

      1.3. Unterstützte Plattformen

     2. Benutzung des Assemblers

      2.1. Hardware-Anforderungen

      2.2. Lieferumfang

      2.3. Installation

      2.4. Aufruf, Parameter

      2.5. Format der Eingabedateien

      2.6. Format des Listings

      2.7. Symbolkonventionen

      2.8. Formelausdrücke

      2.9. Vorwärtsreferenzen und andere Desaster

      2.10. Sharefile

      2.11. Prozessor-Aliasse

     3. Pseudobefehle

      3.1. Definitionen

       3.1.1. EQU und SET
       3.1.2. SFR und SFRB
       3.1.3. XSFR und YSFR
       3.1.4. LABEL
       3.1.5. BIT
       3.1.6. DBIT
       3.1.7. PORT
       3.1.8. REG
       3.1.9. LIV und RIV
       3.1.10. CHARSET
       3.1.11. ENUM
       3.1.12. PUSHV und POPV

      3.2. Codebeeinflussung

       3.2.1. ORG
       3.2.2. CPU
       3.2.3. SUPMODE, PMMU und FPU
       3.2.4. FULLPMMU
       3.2.5. PADDING
       3.2.6. MAXMODE
       3.2.7. EXTMODE und LWORDMODE
       3.2.8. SRCMODE
       3.2.9. BIGENDIAN
       3.2.10. SEGMENT
       3.2.11. PHASE und DEPHASE
       3.2.12. SAVE und RESTORE
       3.2.13. ASSUME
       3.2.14. EMULATED

      3.3. Datendefinition

       3.3. 1. DC
       3.3. 2. DS
       3.3. 3. DB, DW, DD, DQ und DT
       3.3. 4. DS
       3.3. 5. BYT oder FCB
       3.3. 6. BYTE
       3.3. 7. ADR oder FDB
       3.3. 8. WORD
       3.3. 9. LONG
       3.3.10. SINGLE und EXTENDED
       3.3.11. FLOAT und DOUBLE
       3.3.12. EFLOAT, BFLOAT, TFLOAT
       3.3.13. Qxx und LQxx
       3.3.14. DATA
       3.3.15. ZERO
       3.3.16. FB und FW
       3.3.17. ASCII und ASCIZ
       3.3.18. STRING und RSTRING
       3.3.19. FCC
       3.3.20. DFS oder RMB
       3.3.21. BLOCK
       3.3.22. RES
       3.3.23. BSS
       3.3.24. DSB und DSW
       3.3.25. ALIGN
       3.3.26. LTORG

      3.4. Makrobefehle

       3.4.1. MACRO
       3.4.2. IRP
       3.4.3. REPT
       3.4.4. WHILE
       3.4.5. EXITM
       3.4.6. FUNCTION

      3.5. bedingte Assemblierung

       3.5.1. IF / ELSEIF / ENDIF
       3.5.2. SWITCH / CASE / ELSECASE / ENDCASE

      3.6. Listingsteuerung

       3.6.1. PAGE
       3.6.2. NEWPAGE
       3.6.3. MACEXP
       3.6.4. LISTING
       3.6.5. PRTINIT und PRTEXIT
       3.6.6. TITLE

      3.7. lokale Symbole

       3.7.1. Grunddefinition (SECTION/ENDSECTION)
       3.7.2. Verschachtelung und Sichtbarkeitsregeln
       3.7.3. PUBLIC
       3.7.4. FORWARD
       3.7.5. Geschwindigkeitsaspekte

      3.8. Diverses

       3.8.1. SHARED
       3.8.2. INCLUDE
       3.8.3. BINCLUDE
       3.8.4. MESSAGE, WARNING, ERROR und FATAL
       3.8.5. READ
       3.8.6. RELAXED
       3.8.7. END

     4. Prozessorspezifische Hinweise

      4.1. 6811
      4.2. DSP56000
      4.3. PowerPC
      4.4. H8/300
      4.5. SH7000/7600
      4.6. MELPS-4500
      4.7. MELPS-740
      4.8. MELPS-7700/65816
      4.9. M16
      4.10. MCS/48
      4.11. MCS/51
      4.12. MCS/251
      4.13. 8086..V35
      4.14. 8X30x
      4.15. XA
      4.16. Z80UNDOC
      4.17. Z380
      4.18. TLCS-900(L)
      4.19. TLCS-90
      4.20. TLCS-870
      4.21. TLCS-47
      4.22. TLCS-9000
      4.23. 29XXX
      4.24. 80C16x
      4.25. PIC16C5x/16C8x
      4.26. PIC17C4x
      4.27. ST62xx
      4.28. ST7
      4.29. ST9
      4.30. 6804
      4.31. TMS3201x
      4.32. TMS3202x
      4.33. TMS32C03x
      4.34. TMS9900
      4.35. TMS70Cxx
      4.36. TMS370xxx
      4.37. MSP430
      4.38. COP8 & SC/MP
      4.39. 75K0
      4.40. 78K0

     5. Datenformate

      5.1. Code-Dateien

      5.2. Debug-Dateien

     6. Hilfsprogramme

       6.1. PLIST

       6.2. BIND

       6.3. P2HEX

       6.4. P2BIN

       6.5. AS2MSG


     A. Fehlermeldungen von AS

     B. E/A-Fehlermeldungen

     C. Häufig gestellte Fragen

     D. Pseudobefehle gesammelt

     E. Vordefinierte Symbole

     F. Danksagungen

     G. Änderungen seit Version 1.3

     H. Hinweise zum Quellcode von AS

       H.1 Sprachvoraussetzungen

       H.2 Modulaufteilung

       H.3 Neuer Prozessor...was nun ?

       H.4 RSC...was ist das denn?

     I. Literaturhinweise


----------------------------------------------------------------------------

	1. Allgemeines
	==============

Diese Anleitung wendet sich an Leute, die bereits in Assembler pro-
grammiert haben und sich darüber informieren möchten, wie man mit
AS umgeht.  Sie hat eher die Form eines Referenz- und nicht Benut-
zerhandbuches.  Als solches macht sie weder den Versuch, die Sprache
Assembler an sich zu erklären, noch erläutert sie die Architektur
bestimmter Prozessoren.  Im Literaturverzeichnis habe ich weiter-
führende Literatur aufgelistet, die bei der Implementation der ein-
zelnen Codegeneratoren maßgebend war.  Um Assembler von Grund auf zu
lernen, kenne ich kein Buch; ich habe es im wesentlichen im "Trial and
error"-Verfahren gelernt.

	1.1 Lizenzbedingungen
	---------------------

Bevor es in medias res geht, erst einmal der unvermeidliche Prolog:

AS in der vorliegenden Version gebe ich als "Public Domain" weiter,
d.h. die Programm-und Overlaydatei sowie die dazugehörenden Hilfs-
programme dürfen frei kopiert und benutzt werden.  Es existieren
keine Planungen, AS in ein kommerzielles oder Shareware-Programm
umzuwandeln. Diese Erlaubnis gilt jedoch nur unter der Voraussetzung,
daß die Startmeldung der Programme - insbesondere die Copyrightmel-
dung - nicht entfernt oder überschrieben wird und für das Kopieren/
Verschicken nicht mehr als eine Aufwandsentschädigung ( <=DM 20,-)
verlangt wird.

Auf Anfrage wird auch der Quellcode dieses Programmes ausgegeben.
Daraus abgeleitete oder darauf aufbauende Programme müssen unter
den gleichen Bedingungen weitergegeben werden wie dieses Programm.

Ich fordere ausdrücklich dazu auf, dieses Programm per Diskette oder
Mailbox/Netzwerk zu verbreiten!

Es mag sein, daß Sie dieses Programm als Beilage zu einem kommer-
ziellen Programm erhalten haben.  Die für das kommerzielle Programm
geltenden Lizenzbedingungen beziehen sich jedoch auf keinen Fall
auf AS.

Sollte Ihnen der Assembler so gut gefallen, daß sie mir unbedingt
Geld dafür schicken wollen, so fordere ich Sie dazu auf, den Be-
trag für Greenpeace zu spenden.

Ich habe mich bemüht, das Programm so fehlerfrei wie nur irgendmög-
lich zu machen.  Da es aber grundsätzlich keine fehlerfreie Software
gibt (die einzigen Leute, die keine Fehler machen, liegen auf dem
Friedhof!), übernehme ich keine Garantie für die Funktion von AS
in einer bestimmten Umgebung (Hard-oder Software) oder Haftung für
entstehende Schäden.  Für Hinweise auf Fehler bin ich selbstverständ-
lich immer dankbar und werde mich bemühen, sie zu korrigieren.

Um eine möglichst schnelle Fehlerdiagnose und -korrektur zu ermög-
lichen, bitte ich, dem Fehlerbericht folgende Angaben beizufügen:

 - Hardware:  - Prozessortyp  ( mit/ohne Koprozessor )
	      - Speicherausbau
	      - Grafikkarte
	      - Festplatte und Typ deren Interfaces

 - Software:  - Betriebssystem ( MS/DR/Novell-DOS, OS/2, Windows )
                und Version
	      - installierte speicherresidente Programme
	      - benutzte Version von AS + Datum des EXE-Files

 - möglicht die Quelldatei, bei der der Fehler auftritt

Zu erreichen bin ich folgendermaßen:

  per Post   : Alfred Arnold
               Bröltalstr. 5a
               53773 Hennef(Sieg)

  per E-Mail : a.arnold@kfa-juelich.de

Wer mir persönlich Fragen stellen will (und in der Nähe von Aachen
wohnt), kann dies mit hoher Wahrscheinlichkeit donnerstags von 19.00
bis 21.00 Uhr im Computerclub an der RWTH Aachen (Eilfschornstein-
straße 16, Keller Philosophengebäude Rückseite).

Von Telefonanrufen bitte ich abzusehen.  Erstens, weil sich die
komplizierten Zusammenhänge am Telefon nur äußerst schwer erörten
lassen, und zweitens ist die Telekom schon reich genug...

Die neueste Version (DOS,DPMI,OS/2) von AS findet sich auf folgendem
FTP-Server:

 ftp.uni-stuttgart.de
   Verzeichnis  pub/systems/msdos/programming/as

Die C-Version kann von folgendem Server geholt werden:

 sunsite.unc.edu
   Verzeichnis pub/Linux/devel/lang/assemblers/asl-<version>.tar.gz

...und damit natürlich von jedem Sunsite-Spiegel der Welt!

Wer über keinen FTP-Zugang verfügt, kann den Assembler auch von mir
anfordern.  Ich werde aber nur Anfragen beantworten, die zwei
Disketten (für 720K/1,2M-Format 4/3 Stück) und einen passenden, fran-
kierten Rückumschlag enthalten.  KEIN Geld schicken!!!

So. Nach diesem unvermeidlichen Vorwort können wir wohl beruhigt
zur eigentlichen Anleitung schreiten:



	1.2. allgemeine Fähigkeiten des Assemblers
	------------------------------------------

AS bietet im Gegensatz zu normalen Assemblern die Möglichkeit, Code
für völlig verschiedene Prozessoren zu erzeugen.  Momentan sind fol-
gende Prozessorfamilien implementiert:

 - Motorola 68000..68030,683xx inkl. Koprozessor und MMU
 - Motorola DSP56000
 - Motorola/IBM MPC601/MPC505/PPC403
 - Motorola 6800, 6805, 68HC08, 6809, 68(HC)11, 68HC12, 68HC16 sowie Hitachi 6301
 - Hitachi 6309
 - Hitachi H8/300(H)
 - Hitachi H8/500
 - Hitachi SH7000/7600
 - Rockwell 6502 und 65(S)C02
 - CMD 65816
 - Mitsubishi MELPS-740
 - Mitsubishi MELPS-7700
 - Mitsubishi MELPS-4500
 - Mitsubishi M16
 - Mitsubishi M16C
 - Intel MCS-48/41
 - Intel MCS-51/251
 - Intel MCS-96/196(Nx)/296
 - Intel 8080/8085
 - Signetics 8X30x
 - Philips XA
 - Atmel AVR
 - AMD 29K
 - Siemens 80C166/167
 - Zilog Z80, Z180, Z380
 - Zilog Z8
 - Toshiba TLCS-900(L)
 - Toshiba TLCS-90
 - Toshiba TLCS-870
 - Toshiba TLCS-47
 - Toshiba TLCS-9000
 - Microchip PIC16C54..16C57
 - Microchip PIC16C84/PIC16C64
 - Microchip PIC17C42
 - SGS-Thomson ST62xx
 - SGS-Thomson ST7
 - SGS-Thomson ST9
 - SGS-Thomson 6804
 - Texas Instruments TMS32010/32015
 - Texas Instruments TMS3202x
 - Texas Instruments TMS320C3x
 - Texas Instruments TMS320C5x
 - Texas Instruments TMS9900
 - Texas Instruments TMS7000
 - Texas Instruments TMS370xxx
 - Texas Instruments MSP430
 - National Semiconductor SC/MP
 - National Semiconductor COP8
 - NEC µPD 78(C)1x
 - NEC µPD 75xxx (alias 75K0)
 - NEC µPD 78xxx (alias 78K0)

in Arbeit / Planung / Überlegung :

 - SGS-Thomson ST20
 - Texas Instruments TMS320C6x
 - Texas Instruments TMS320C4x
 - Texas Instruments TMS320C8x
 - Toshiba TC9331
 - Intel i960
 - Analog Devices ADSP21xx

Noch gesucht werden Unterlagen für:

 - Fujitsu F²MC
 - NEC 78K4
 - die ganze Palette der OKI-Controller

ungeliebt, aber DOCH vorhanden :

 - Intel 80x86, 80186, NEC V30&V35 inkl. Koprozessor 8087

Die Umschaltung des Codegenerators darf dabei auch mitten in der Da-
tei erfolgen, und das beliebig oft!

Der Grund für diese Flexibilität ist, daß AS eine Vorgeschichte hat,
die auch in der Versionsnummer deutlich wird: AS ist als Erweiterung
eines Makroassemblers für die 68000er-Familie entstanden.  Auf beson-
deren Wunsch habe ich den ursprünglichen Assembler um die Fähigkeit
zur Übersetzung von 8051-Mnemonics erweitert, und auf dem Weg (Ab-
stieg?!) vom 68000 zum 8051 sind eine Reihe anderer fast nebenbei ab-
gefallen...die restlichen Prozessoren wurden allesamt auf Benutzer-
anfrage hin integriert.  Die Versionsnummer ist also nicht nur Marke-
ting, sondern sie drückt wirklich aus, daß dies hier keine 1.0er Ver-
sion mit Kinderkrankheiten ist (was nichts am Gewicht des in Teil 1.1
gesagten ändert).

Diese Flexibilität bedingt ein etwas exotisches Codeformat, für des-
sen Bearbeitung ich einige Tools beigelegt habe.  Deren Beschreibung
findet sich in Kapitel 6.

AS ist ein Makroassembler, d.h. dem Programmierer ist die Möglichkeit
gegeben, sich mittels Makros neue "Befehle" zu definieren.  Zusätz-
lich beherrscht er die bedingte Assemblierung.  Labels in Makrorümpfen
werden automatisch als lokal betrachtet.

Symbole können für den Assembler sowohl Integer-, String- als auch
Gleitkommawerte haben.  Diese werden - wie Zwischergebnisse bei
Formeln - mit einer Breite von 32 Bit für Integerwerte, 80/64 Bit für
Gleitkommawerte und 255 Zeichen für Strings gespeichert.  Für die
eine Reihe von Mikrokontrollern besteht die Möglichkeit, durch Seg-
mentbildung die Symbole bestimmten Klassen zuzuordnen.  Dem Assembler
kann man auf diese Weise die - begrenzte - Möglichkeit geben, Zugrif-
fe in falsche Adreßräume zu erkennen.

Der Assembler kennt keine expliziten Beschränkungen bzgl. Verschach-
telungstiefe von Includefiles oder Makros, eine Grenze bildet ledig-
lich die durch den Hauptspeicher beschränkte Rekursionstiefe.  Eben-
so gibt es keine Grenze für die Symbollänge, diese wird nur durch
die maximale Zeilenlänge begrenzt.

Ab Version 1.38 ist AS ein Mehrpass-Assembler.  Dieser hochtrabende
Begriff bedeutet nicht mehr, als das die Anzahl der Durchgänge durch
die Quelltexte nicht mehr zwei sein muß.  Sind keine Vorwärtsrefe-
renzen im Quellcode enthalten, so kommt AS mit einem Durchgang aus.
Stellt sich dagegen im zweiten Durchgang heraus, daß ein Befehl mit
einer kürzeren oder längeren Kodierung benutzt werden muß, so wird
ein dritter (vierter, fünfter...) Durchgang eingelegt, um alle Sym-
bolreferenzen richtig zu stellen.  Mehr steckt hinter dem Begriff
"Multipass" nicht...er wird im weiteren Verlauf dieser Anleitung
deswegen auch nicht mehr auftauchen.

Nach soviel Lobhudelei ein dicker Wermutstropfen: AS erzeugt keinen
linkfähigen Code.  Eine Erweiterung um einen Linker wäre mit erheb-
lichem Aufwand verbunden und ist momentan nicht in Planung.

Zum Thema "Herausgabe von Sourcen": Die Sourcen von AS sind nicht
in einer Form, die ein einfaches Verständnis ermöglicht (== null
Kommentare).  Sourcen werde ich daher nur für den Fall herausgeben,
daß jemand wirklich damit etwas anfangen will (z.B. AS auf einen
anderen Rechner portieren) und das daraus entstehende wiederum
Public Domain wird.  Insbesondere will ich verhindern, daß jemand
5 Zeilen ändert (bevorzugt den Copyrighteintrag) und das Ergebnis
dann kommerziell als "sein" Programm vertreibt.


        1.3. Unterstützte Plattformen
        -----------------------------

+-----+
+ DOS +
+-----+
Obwohl AS als ein reines DOS-Programm angefangen hat, stehen auch
eine Reihe von Versionen zur Verfügung, die etwas mehr als den Real-
Mode eines Intel-Prozessors ausnutzen können.  Diese sind in ihrer
Benutzung soweit als möglich kompatibel gehalten zur DOS-Version, es
ergeben sich natürlich bisweilen Unterschiede in der Installation und
der Einbindung in die jeweilige Betriebssystemumgebung.  Abschnitte
in dieser Anleitung, die nur für eine bestimmte Version von AS gel-
ten, sind mit einem entsprechenden, vorangestellten Kästchen (an die-
sem Absatz fÜr die DOS-Version) gekennzeichnet.  Im einzelnen existie-
ren die folgenden, weiteren Versionen (die als getrennte Pakete dis-
tributiert werden):

+------+
| DPMI |
+------+
Für den Fall, daß man bei der Übersetzung großer, komplexer Program-
me Speicherplatzprobleme bekommt, existiert eine DOS-Version, die mit-
tels eines DOS-Extenders im Protected Mode abläuft und so das komplet-
te Extended Memory eines ATs nutzen kann.  Die Übersetzung wird durch
den Extender merklich langsamer, aber immerhin läuft es dann noch...

+------+
| OS/2 |
+------+
Für Freunde von IBM's Betriebssystem OS/2 gibt es eine native OS/2-
Version von AS.  Diese ist zwar zur Zeit nur 16-bittig, aber man er-
spart sich immerhin den Umweg Über DOS-Boxen und hat auch keine Pro-
bleme mehr mit längeren Dateinamen.

+------+
| UNIX |
+------+
Den reinen PC-Bereich verläßt man mit der C-Version von AS, die so ge-
halten wurde, daß sie auf einer möglichst großen Zahl von UNIX-artigen
Systemen (dazu zählt aber auch OS/2 mit dem emx-Compiler) ohne großar-
tige Verrenkungen übersetzbar ist.  Im Gegensatz zu den vorherigen
Versionen (die auf den auf Anfrage erhältlichen Pascal-Sourcen basie-
ren) wird die C-Version im Quellcode ausgeliefert, d.h. man muß sich
mittels eines Compilers selbst die Binaries erzeugen.  Dies ist aber
(für mich) der eindeutig einfachere Weg, als ein Dutzend Binaries für
Maschinen vorzukompilieren, auf die ich auch nicht immer Zugriff
habe...

+-----+                          
| ??? |
+-----+
Wer die bisherige Aufzählung liest, wird feststellen, daß das meist-
verkaufte Betriebssystem der Welt aus Redmont in dieser Aufzählung
fehlt.  Wer mich persönlich kennt, weiß, daß ich Windows (egal, ob
3.X, 95 oder NT) NICHT für das Ei des Kolumbus halte.  Kurzgesagt, ich
bin ein "Windows-Hasser".  Auch wenn eine große Zahl an Leuten diese
Einstellung für überholt bis lächerlich erachten und mir jetzt vorhal-
ten, ich würde hier einem großen Teil potentieller Anwender AS vorent-
halten, so werden sie sich doch damit abfinden m"ussen: Ich treibe die
Entwicklung an AS primär weiter, weil sie mir Spaß macht; AS ist ein
nicht-kommerzielles Projekt und ich nehme mir deswegen die Freiheit,
nicht auf potentielle Marktanteile zu schielen.  Ich suche mir die
Plattformen aus, auf denen das Programmieren MIR Spaß macht, und Pro-
grammieren unter Windows macht mir definitiv keinen Spaß!  Ich habe
übrigens durchaus schon einmal Windows-Programme schreiben müssen, es
ist also nicht so, daß ich hier ohne Erfahrung etwas daherreden würde.
Sofern irgendjemand AS in diese Richtung portieren will, werde ich
mich ihm nicht in den Weg stellen, über die Sourcen hinaus hat er aber
nicht viel Hilfe von mir zu erwarten (und muß sich selber mit den An-
fragen der Qualität herumschlagen, warum AS denn jetzt nicht mehr
läuft, nachdem man den Brummi-CAD 18.53-Eintrag in der Registry von
Groß- in Kleinbuchstaben geändert hat...).


	2.Benutzung des Assemblers
	==========================


        2.1. Hardware-Anforderungen
        ---------------------------

Je nach Version von AS variieren die Hardware-Anforderungen deut-
lich:

+-----+
| DOS |
+-----+
Die DOS-Version läuft prinzipiell auf allen  IBM-kompatiblen PCs,
angefangen vom PC/XT mit vierkommawenig Megaherz bis hin zum Pentium.
Wie bei vielen anderen Programmen aber  auch, steigt der Lustgewinn
mit der Hardware-Ausstattung.  So dürfte ein XT-Benutzer ohne Fest-
platte erhebliche Probleme haben, die über 500 Kbyte große Overlay-
Datei von AS auf einer Diskette unterzubringen...eine Festplatte sol-
lte der PC also schon haben, allein um vernünftige Ladezeiten zu er-
reichen.  Im Hauptspeicherbedarf ist AS recht genügsam: Das Programm
selber belegt knapp 300 Kbyte Hauptspeicher, AS sollte also ab einer
Hauptspeichergröße von 512 Kbyte ausführbar sein.

+------+
| DPMI |
+------+
Die Version von AS für das DOS-Protected-Mode-Interface (DPMI)  benö-
tigt zum Ablaufen mindestens einen 80286-Prozessor und 1 Mbyte freies
extended memory.  Daher stellen 2 Mbyte Hauptspeicher das absolute Mi-
nimum dar, wenn man im XMS sonst keine anderen Spielereien (Platten-
Cache, RAM-Disk, hochgeladenes DOS) installiert hat, sonst entspre-
chend mehr.  Falls man die DPMI-Version in einer DOS-Box von OS/2 lau-
fen läßt, so sollte DPMI auch in den DOS-Einstellungen der Box erlaubt
sein (Einstellung "An" oder "Auto") und der Box eine entsprechende
Menge von XMS-Speicher zugeordnet sein.  Die virtuelle Speicherverwal-
tung von OS/2 sorgt hier übrigens dafür, daß man sich keine Gedanken
machen muß, ob der eingestellte Speicher auch real verfügbar ist.

+------+
| OS/2 |
+------+
Die Hardware-Anforderungen der OS/2-Version ergeben sich weitestgehend
durch die des darunterliegenden Betriebssytemes, d.h. mindestens ein
80386SX-Prozessor, 8 Mbyte RAM (bzw. 4 ohne grafische Benutzeroberflä-
che) sowie ca 100..150 Mbyte Platz auf der Festplatte.  Da AS2 nur
eine 16-Bit-Applikation ist, sollte er theoretisch auch auf älteren
OS/2-Versionen (und damit 80286-Prozessoren) lauffähig sein; auspro-
bieren konnte ich dies aber nicht.

+------+
| UNIX |
+------+
Die C-Version von AS wird im Quellcode ausgeliefert und erfordert da-
mit ein Unix- oder OS/2-System mit einem C-Compiler.  Der Compiler muß
dem ANSI-Standard genügen (GNU-C erfüllt diese Bedingung zum Bei-
spiel).  Ob Ihr UNIX-System bereits getestet und die nötigen Definiti-
onen vorgenommen wurden, können Sie der README-Datei entnehmen.  Als
zur Kompilation benötigten Plattenplatz sollten Sie ca. 15 Mbyte ver-
anschlagen; dieser Wert (und der nach der Übersetzung noch benötigte
Platz für die übersetzten Programme) variiert allerdings stark von
System zu System, so daß man diesen Wert nur als Richtschnur betrach-
ten sollte.


	2.2. Lieferumfang
	-----------------

Je nach Plattform beinhalten die Distributionen eine unterschiedliche
Menge an Dateien.  Dies ist zum einen darin begründet, daß einige
Pakete Dateien aus anderen Paketen mitbenutzen, zum anderen
benötigen bestimmte Pakete Zusatzdateien, die für den Betrieb z.B.
mit DOS-Extendern erforderlich sind.  Falls eine der im folgenden
aufgeführten Dateien fehlt, hat jemand (im Zweifelsfalle ich) beim
Kopieren geschlafen...

+-----+
| DOS |
+-----+
Das DOS-Paket beinhaltet die folgenden Dateien, die sich grob in
Programmdateien, Dokumentation, Includes und Testprogramme aufteilen
lassen:

    Datei               Funktion
    -----               --------

   AS.EXE               Assembler
   AS.OVR               Overlay zum Assembler

   AS.DOC               diese Datei mit der Anleitung

   PLIST.EXE            Listet Inhalt von Codedateien auf
   BIND.EXE             kopiert Codedateien zusammen
   P2HEX.EXE            wandelt Codedateien in Hexdateien um
   P2BIN.EXE            wandelt Codedateien in Binärdateien um
   AS2MSG.EXE           Fehlerfilter AS --> Borland-Pascal

   80C50X.INC           Registeradressen SAB C50x
   80C552.INC		Registeradressen 80C552
   H8_3048.INC          Registeradressen H8/3048
   STDDEF04.INC		Registeradressen 6804
   STDDEF16.INC         Befehlsmakros und Registeradressen PIC16C5x
   STDDEF17.INC         Registeradressen PIC17C4x
   STDDEF18.INC         Registeradressen PIC16C8x
   STDDEF2X.INC         Registeradressen TMS 3202x
   STDDEF37.INC         Register- & Bitadressen TMS370xxx
   STDDEF3X.INC         Peripherieadressen TMS 320C3x
   STDDEF47.INC         Befehlsmakros TLCS-47
   STDDEF51.INC         Definition von SFRs und Bits für 8051/8052/
			80515
   STDDEF56.INC         Registeradressen DSP56000
   STDDEF5X.INC         Peripherieadressen TMS 320C5x
   STDDEF60.INC         Befehlsmakros & Registeradressen PowerPC
   STDDEF62.INC         Registeradressen & Makros ST62xx
   STDDEF75.INC         Registeradressen 75K0
   STDDEF87.INC         Register- & Speicheradressen TLCS-870
   STDDEF90.INC		Register- & Speicheradressen TLCS-90
   STDDEF96.INC 	Register- & Speicheradressen TLCS-900
   STDDEFXA.INC         SFR- & Bitadressen Philips XA
   STDDEFZ8.INC         Registeradressen Z8-Familie
   REG166.INC           Adressen & Befehlsmakros 80C166/167
   REG251.INC           Adressen & Bits 80C251
   REG29K.INC           Peripherieadressen AMD 2924x
   REG53X.INC           Registeradressen H8/53X
   REG683XX.INC         Registeradressen 68332/68340/68360
   REG7000.INC          Registeradressen TMS70Cxx
   REG78K0.INC          Register- und Speicheradressen 78K0
   REG96.INC            Registeradressen MCS-96
   REGAVR.INC           Registeradressen Atmel AVR
   REGCOP8.INC          Registeradressen COP8
   REGHC12.INC          Registeradressen Motorola 68HC12...
   REGM16C.INC          Registeradressen Mitsubishi M16C
   REGMSP.INC           Befehlsmakros & Registeradressen MSP430
   REGST9.INC           Registeradressen ST9
   REGZ380.INC          On-Chip-Register Z380
   CTYPE.INC            Standardfunktionen zur Analyse von Zeichen
   BITFUNCS.INC		Standardfunktionen zur Bitmanipulation

   DEMOCODE.ASM		Beispielprogramme für die Nutzung des Assemblers
   DEMOMAC.ASM
   DEMOPHAS.ASM
   DEMOLIST.ASM


+------+
| DPMI |
+------+
Das Paket der DPMI-Version ist wesentlich kleiner, da sie weder Inc-
lude-Dateien noch Dienstprogramme noch Testprogramme enthält.  Die-
se können und müssen aus der DOS-Version übernommen werden.  Die
Dienstprogramme wurden nicht gesondert für den Protected Mode über-
setzt, da sie einerseits vom größeren Speicherplatz nicht profitie-
ren würden, andererseits aber die durch DPMI bedingte Verlangsamung
erfahren würden.  Das Paket kann sich daher auf das AS-Exectutable
selber und den benötigten DOS-Extender beschränken:

    Datei               Funktion
    -----               --------

   ASX.EXE              Protected-Mode-Assembler

   DPMI16BI.OVL         DPMI-Server für den Assembler
   DPMILOAD.EXE         Lader für den DPMI-Server
   RTM.EXE              Run-Time-Modul des Assemblers

   RTMRES.EXE           DPMI-Server resident laden

   DPMINST.EXE          DPMI-Server auf den Rechner installieren

   DPMIUSER.DOC         Informationen zur Benutzung des DPMI-Servers

+------+
| OS/2 |
+------+
Mit der OS/2-Version verhält es sich ähnlich wie mit der DPMI-Version
von AS, d.h. Include-Dateien und Testprogramme wurden nicht extra
hinzukopiert, aber die Dienstprogramme wurden natürlich "nativ" über-
setzt.  AS2MSG fehlt mangels Masse (==kein Borland-Pascal für OS/2):

    Datei               Funktion
    -----               --------

   AS2.EXE              Assembler, OS/2-Version

   PLIST2.EXE           Dienstprogramme zu AS2; Funktion analog zu
   BIND2.EXE            den MSDOS-Versionen
   P2HEX2.EXE
   P2BIN2.EXE

+------+
| UNIX |
+------+
Da die C-Version im Gegensatz zu allen vorigen Versionen im Quellcode
ausgeliefert wird, ist ihr Lieferumfang deutlich umfangreicher (zu-
mindest so, daß dessen Auflistung an dieser Stelle in erster Linie
auf Papierverschwendung hinauslaufen würde...).  So beinhaltet er ne-
ben den Quellen auch eine im Vergleich zu den Testprogrammen der DOS-
Version ziemlich kompette Test-Suite, mit der man die Funktion der
frisch übersetzen Version verifizieren kann.


        2.3. Installation
        -----------------

+-----+
| DOS |
+-----+
Eine besondere Installation ist für die Nutzung von AS nicht erfor-
derlich, es genügt, alle EXE- sowie OVR-Dateien in ein Verzeichnis
kopieren, das in der PATH-Variable auftaucht.  Ob man ein bestehen-
des Verzeichnis nutzt oder ein neues anlegt, ist dabei egal.  Die
Dokumentation, Beispielprogramme sowie Includefiles können völlig
nach belieben verteilt werden...als Beispiel hier eine Installation,
die ein UNIX-Anhänger vornehmen würde:

Legen Sie folgende Verzeichnise an (im folgenden nehme ich an, daß
Sie AS auf Laufwerk C installieren wollen):

c:\as
c:\as\bin
c:\as\include
c:\as\lib
c:\as\doc
c:\as\demos

Als erstes kopieren Sie alle EXE- sowie OVR-Dateien aus dem Archiv in
das bin-Verzeichnis; um dieses Verzeichnis ergänzen Sie dann auch die
PATH-Anweisung in Ihrer AUTOEXEC.BAT.  In das include-Verzeichnis 
kommen alle INC-Dateien.  In dem lib-Verzeichnis erzeugen Sie eine
Datei AS.RC mit folgendem Inhalt:

-i c:\as\include

Diese sogenannte Key-Datei zeigt AS, in welchem Verzeichnis er seine 
Include-Dateien suchen soll.  Damit AS diese Key-Datei bei Start 
auch beachtet, muß noch folgende Anweisung in die AUTOEXEC.BAT:

set ASCMD=@c:\as\lib\as.rc

Was Sie alles noch in der Key-Datei voreinstellen können, steht im
folgenden Abschnitt.  Zuguterletzt wandern noch alle DOC-Dateien
ins gleichnamige Verzeichnis sowie die Demo-Assemblerquellen ins
demos-Verzeichnis.  Das war's auch schon!

+------+
| DPMI |
+------+
Da die DPMI-Version im wesentlichen ein Addon zur DOS-Version für be-
stimmte Fälle darstellt, installiert man am besten zuerst die DOS-
Version nach obigem Schema und kopiert danach zusätzlich AS2.EXE und
die Dateien des DPMI-Servers in das bin-Verzeichnis (DPMIUSER.DOC kann
z.B. mit ins DOC-Verzeichnis).  Beim ersten Start kann es sein, daß
Sie auf 80286-Rechnern mit einer Meldung der folgenden Form konfron-
tiert werden:

  machine not in database (run DPMIINST)

Da bei der Programmausführung ständig zwischen Real und Protected   
Mode hin- und hergeschaltet wird, ist es sehr wichtig, die effizien-
teste Möglichkeit dafür zu finden. Zu diesem Zweck (und nur zu die-
sen) müssen Sie einmal das Programm DPMIINST starten.  Da DPMIINST 
alleiniger Herr über den Protected Mode sein möchte, müssen Sie für
die Installation wahrscheinlich einen installierten HIMEM-Treiber  
herausnehmen (nach dem Lauf darf HIMEM aber wieder hinein).  Folgen
Sie einfach den Anweisungen, die DPMIINST ausgibt.  Nach dieser Pro-
zedur benötigen Sie dieses Programm nicht mehr, sondern nur noch fol-
gende Programme:

  - DPMI16BI.OVL :  DPMI-Server
  - DPMILOAD.EXE :  Lader für den DPMI-Server
  - RTM.EXE      :  Laufzeitsteuerprogramm

+------+
| OS/2 |
+------+
Die Installation der OS/2-Version kann in weiten Zügen genauso ablau-
fen wie für die DOS-Version, nur daß man alle EXE- und OVR-Dateien
direkt entsorgen und durch die standesgemäßen OS/2-Gegenstücke erset-
zen kann.  Im Gegensatz zu DOS muß man bei OS/2 das Setzen der ASCMD-
Variablen in der CONFIG.SYS vornehmen (die Position ist aber auch in
diesem Fall beliebig).

+------+
| UNIX |
+------+
Da die C-Version im Quellcode kommt, ist die Installation naturgemäß
etwas aufwendiger.  Grob gesagt bestehen die Schritte darin, die Make-
files anzupassen, die Übersetzung anzuwerfen, einen Testlauf durchzu-
führen und die entstandenen Executables sowie die Include-Dateien und
Dokumentation zu installieren.  Die Details finden sich in der Datei
README.  OS/2-Benutzer sollten unbedingt auch einen Blick in
README.OS2 werfen, um Schiffbruch zu vermeiden! 


	2.4. Aufruf, Parameter
	----------------------

AS ist ein kommandozeilengesteuertes Programm, d.h. alle Parameter
und Dateiangaben sind in der Kommandozeile anzugeben.  

+-----+
| DOS |
+-----+ 
Um den Speicherbedarf von AS unter DOS überhaupt befriedigen zu kön-
nen, wurden die verschiedenen Codegeneratormodule in der DOS-Version
in eine Overlaydatei verlegt, deren Existenz der Assembler sofortnach
Programmstart prüft.  Findet er diese nicht, so ist der Programmlauf
auch schon an dieser Stelle zu Ende...die Datei AS.OVR sollte sich
immer im gleichen Verzeichnis wie das EXE-File befinden.  Die Verwen-
dung von Overlays ergibt naturgemäß etwas Overhead.  AS versucht die-
sen aber zu reduzieren, indem er eventuell vorhandenen EMS- oder XMS-
Speicher zur Ablage von Overlays nutzt.  Sollte dies zu Problemenfüh-
ren, so können Sie die Verwendung von EMS bzw. XMS unterbinden, indem
Sie einer Environment-Variablen USEXMS bzw. USEEMS den Wert n zuwei-
sen.  So kann man z.B. mit dem Befehl

   SET USEXMS=n

die Verwendung von extended memory verhindern.

Da AS alle Ein-und Ausgaben über das Betriebssystem abwickelt (und
daher unter DOS auch auf nicht ganz so kompatiblen PC's laufen sol-
lte) und eine rudimentäre Bildschirmsteuerung benötigt, gibt er
während der Assemblierung ANSI-Steuersequenzen aus.  

+----------+
| DOS/DPMI |
+----------+
Falls Sie in den Ausgaben von AS also seltsame Zeichen sehen sol-
lten, fehlt offensichtlich in Ihrer CONFIG.SYS eine Zeile der Art

   device=ansi.sys  ,

die weitere Funktion von AS wird dadurch aber nicht beeinflußt.  Al-
ternativ können Sie aber auch die Ausgabe von ANSI-Sequenzen durch
das Setzen der Environment-Variablen USEANSI auf n ganz unterdrücken.

+------+
| DPMI |
+------+
Der DOS-Extender der DPMI-Version läßt sich in seiner Speicherbele-
gung durch diverse Kommandozeilenoptionen beeinflussen.  Diese können
Sie bei Bedarf der Datei DPMIUSER.DOC entnehmen.  Zusätzlich ist ASX
in der Lage, bei Bedarf den vorhanden Speicher durch eine Swap-Datei
zu "erweitern".  Dazu belegt man eine Envirionment-Variable ASXSWAP
folgendermaßen:

  SET ASXSWAP=<Größe>[,Dateiname]

Die Größenangabe ist in Megabytes und MUSS gemacht werden.  Der Name
der Datei ist dagegen optional; fehlt er, so wird die Swap-Datei im
aktuellen Verzeichnis unter dem Namen ASX.TMP angelegt.  In jedem
Falle wird die Swap-Datei nach Programmende wieder gelöscht.

+------+
| DPMI |
+------+
Die verlängerte Ladezeit der DPMI-Version läßt sich etwas durch Ver-
wendung des Programmes RTMRES reduzieren.  Es lädt die Steuerprogram-
me resident und startet eine neue Shell, so daß der Ladeoverhead bei
mehrfachen Aufrufen entfällt.  Mit einem EXIT beenden Sie die Shell
und entfernen die Steuerprogramme wieder.

Die Parameter können grob in zwei Klassen eingeteilt werden: Schalter
und Dateispezifikationen.  Parameter dieser beiden Klassen können be-
liebig gemischt in der Kommandozeile auftreten, AS wertet zuerst alle
Parameter aus und assembliert dann die angegebenen Dateien.  Daraus
folgen zwei Dinge:

 - Die angegebenen Schalter wirken auf alle angegebenen Quelldateien.
   Sollen mehrere Quelldateien mit unterschiedlich gesetzten Schaltern
   assembliert werden, so muß dies in getrennten Läufen erfolgen.

 - Es können in einem Durchgang mehrere Dateien assembliert werden.
   Um der Sache die Krone aufzusetzen, dürfen die Dateiangaben Joker-
   zeichen enthalten.

Schalterparameter erkennt AS daran, daß sie durch einen Schrägstrich
(/) oder Bindestrich (-) eingeleitet werden.  Es gibt dabei sowohl
Schalter, die nur aus einem Buchstaben bestehen, als auch Schalter,
die aus einem ganzen Wort bestehen.  Immer wenn AS einen Schalter
nicht als "Wort-Schalter" verstehen kann, so versucht er, die Buch-
staben des Wortes als einzelne Schalter zu interpretieren.  Wenn man
also z.B.

 -queit

anstelle von

 -quiet

geschrieben hätte, würde AS die Buchstaben q, u, e, i und t als ein-
zelne Schalter auffassen.  Mehrbuchstabige Schalter unterscheiden
sich weiterhin von einbuchstabigen dadurch, daß AS bei ihnen belie-
bige Groß-und Kleinschreibungen akzeptiert, während einbuchstabige
Schalter je nach Groß- oder Kleinschreibung unterschiedliche Bedeutung
haben.

Momentan sind folgende Schalter definiert:

 -  l : Assemblerlisting auf Konsole ausgeben.  Falls mehrere Passes
        ausgeführt werden müssen, landen im Gegensatz zur nächsten
	Option die Listings aller Durchgänge auf der Ausgabe!
 -  L : Assemblerlisting auf Datei schreiben.  Die Listdatei erhält
	dabei den gleichen Namen wie die Quelldatei, lediglich die
	Endung wird durch LST ersetzt.

 -  o : Bestimmt einen neuen Namen für die von AS zu erzeugende
        Code-Datei.  Wird diese Option mehrfach verwendet, so werden
        die angegebenen Namen nacheinander den zu assemblierenden
        Quelldateien zugeordnet; Negation (s.u.) dieser Option in
        Verbindung mit einem Namen löscht den Namen aus der Liste;
	Negation ohne Namensangabe löscht die komplette Liste.

 -  c : SHARED-Variablen werden in einem Format abgelegt, das die
	Einbindung in eine C-Quelldatei erlaubt.  Die Endung der
	Datei ist H .
 -  p : SHARED-Variablen werden in einem Format abgelegt, das die
	Einbindung in den CONST-Block eines Pascal- oder Modula-
        Programmes erlaubt.  Die Endung der Datei ist INC .
 -  a : SHARED-Variablen werden in einem Format abgelegt, das die
	Einbindung in eine Assembler-Quelldatei erlaubt.  Die Endung
	der Datei ist INC .

Zu Sinn und Funktion der SHARED-Symbole siehe Kapitel 2.8. bzw. 3.8.1.

 -  g : Mit diesem Schalter erzeugt AS zusätzlich eine Datei, die
        Debug-Informationen für dieses Programm enthält.  Dazu ge-
        hört zum einen die Symboltabelle, zum anderen eine Zuord-
        nung von Quellzeilen zu Maschinenadressen.  Eine genauere
        Beschreibung des benutzten Dateiformates findet sich in
        Abschnitt 5.2 .  Die Endung der Datei ist MAP .

 -  w : Ausgabe von Warnungen unterdrücken

 -  E [Datei] : Die von AS erzeugten Fehlermeldungen und Warnungen in
		eine Datei umleiten.  Anstatt einer Datei können auch
		die 5 Standardhandles (STDIN..STDPRN) als !0 bis !4
		angegeben werden.  Default ist !2, also STDERR.
		Wird die Dateiangabe weggelassen, so ist der Name der
		Fehlerdatei gleich dem der Quelldatei, nur mit der
		Endung LOG.

 -  q : Dieser Schalter unterdrückt alle Meldungen von AS mit Aus-
        nahme von Fehlermeldungen und vom Programm selber erzeugten
        Ausgaben.  Die Assemblierzeit kann dadurch geringfügig
        reduziert werden, und beim Aufruf aus einer Shell heraus kann
        man sich eine Umleitung ersparen.  Der Nachteil ist, daß man
        u.U. einige Minuten "im Dunklen" steht...  Anstelle von 'q'
        darf auch 'quiet' geschrieben werden.

 -  h : Hexadezimalzahlen mit Klein- anstelle von Großbuchstaben aus-
	geben. Diese Option ist in erster Linie eine Frage des per-
	sönlichen Geschmacks.

 -  i <Pfadliste> : gibt eine Liste von Verzeichnissen an, in denen
		    der Assembler automatisch nach Includedateien
		    suchen soll, falls er diese nicht im aktuellen
		    Verzeichnis findet. Die einzelnen Verzeichnisse
                    müssen durch Semikolons getrennt werden.

 -  u : eine Liste der in den Segmenten belegten Bereiche berechnen.
	Diese Option ist nur wirksam, falls ein Listing erzeugt
	wird.  Diese Option benötigt erhebliche zusätzliche Spei-
	cher-und Rechenleistung, im Normalbetrieb sollte sie daher
	abgeschaltet sein.

 -  C : erzeugt eine Liste mit Querverweisen.  Aufgelistet wird,
	welche (globalen) Symbole in welchen Dateien in welchen
	Zeilen benutzt werden.  Auch diese Liste wird nur gene-
	riert, falls ein Listing erzeugt wird und belegt während
        der Assemblierung zusätzlichen Speicherplatz.

 -  s : eine Liste aller Sektionen (s. Abschnitt 3.7) ausgeben.
	Die Verschachtelung wird dabei durch Einrückungen
	angedeutet.

 -  I : Analog zur Sektionsliste eine Liste aller bearbeiteten
        Include-Dateien ausgeben.

 -  t : Mit diesem Schalter lassen sich einzelne Komponenten des
	standardmäßig ausgegebenen Assemblerlistings ein-und aus-
	blenden.  Welcher Teil dabei welchem Bit zugeordnet ist, ist
	im übernächsten Abschnitt, der genauer auf das Format des
	Assemblerlistings eingeht, nachgelesen werden.

 -  D : Symbole definieren.  Die hinter dieser Option angegebenen,
	durch Kommas getrennten Symbole werden in der globalen
	Symboltabelle vor Beginn der Assemblierung abgelegt.
	Defaultmäßig werden diese Symbole als ganze Zahlen mit dem
	Wert TRUE abgelegt, mit einem nachgestellten Gleichheits-
	zeichen kann aber auch eine andere Belegung gewählt werden.
	Der dem Gleichheitszeichen folgende Ausdruck darf dabei auch
	Operatoren oder interne Funktionen beinhalten, jedoch KEINE
	anderen Symbole, selbst wenn diese schon davor in der Liste
	definiert sein sollten!  Zusammen mit den Befehlen zur be-
	dingten  Assemblierung (siehe dort) können so per Kommando-
	zeile aus einer Quelldatei unterschiedliche Programmver-
	sionen erzeugt werden.


 -  A : Die Liste globaler Symbole in einer anderen, kompakteren Form
	ablegen.  Verwenden Sie diese Option, wenn der Assembler bei
	langen Symboltabellen mit einem Stapelüberlauf abstürzt.
	Eventuell kann diese Option die Arbeitsgeschwindigkeit des
	Assemblers erhöhen, dies hängt jedoch von den Quellen ab.

 -  x : So vorhanden, wird bei Fehlern noch eine erweiterte Meldung
	ausgegeben, anhand der die Identifizierung des Fehlers erleich-
	tert werden soll.  Welche Fehlermeldungen welche Zusatzin-
	formationen tragen können, steht im Anhang A mit der Liste aller
	Fehlermeldungen.

 -  n : Wird diese Option angegeben, so werden Fehlermeldungen nicht
	nur mit ihrem Klartext, sondern auch mit ihren in Anhang A
	genannten internen Nummern ausgegeben.  Diese Option ist
	primär für Shells und Entwicklungsumgebungen gedacht, denen
	mit diesen Nummern die Identifizierung von Fehlern erleichtert
	werden soll.

 -  U : Mit dieser Option schaltet man AS in den case-sensitiven
        Modus um, d.h. in Namen von Symbolen, Sektionen, Makros
        und selbstdefinierte Funktionen werden Klein- und Großbuchstaben
        unterschieden, was normalerweise nicht der Fall ist.

 -  P : weist AS an, den von Makroprozessor und bedingter Assemblie-
	rung bearbeiteten Quelltext in einer Datei abzulegen.  Dieser
	Datei fehlen zusätzlich Leer- und reine Kommentarzeilen.  Die
	Endung der Datei ist I.

 -  M : mit diesem Schalter erzeugt AS eine Datei, in der die Defini-
	tionen der Makros aus der Quelldatei abgespeichert werden, die
	nicht die NOEXPORT-Option verwenden.  Diese neue Datei
	hat den gleichen Namen wie die Quelldatei, lediglich die
	Endung wird in MAC geändert.

 -  G : Dieser Schalter bestimmt, ob AS Code erzeugen soll oder nicht.
	Ist er ausgeschaltet, wird die Datei zwar assembliert, aber
        keine Code-Datei geschrieben.  Dieser Schalter ist defaultmäßig
	aktiviert (logisch, sonst bekäme man ja auch gar kein Code-
	file).  

 -  r [n] : Warnungen ausgeben, falls Situationen eintreten, die
            einen weiteren Pass erfordern.  Diese Information kann
	    genutzt werden, um die Anzahl der Durchläufe zu
	    verringern.  Optional kann man die Nummer des Passes
	    angeben, ab dem diese Warnungen erzeugt werden; ohne
	    Angabe kommen die Warnungen ab dem ersten Pass.  Machen
	    Sie sich aber so oder so auf einen ziemlichen Haufen an
	    Meldungen gefaßt!!

 -  Y : Mit diesem Schalter weist man AS an, alle Fehlermeldungen we-
        gen zu langer Sprungdistanzen zu verwerfen, sobald die Notwen-
        digkeit eines neuen Durchlaufs feststeht.  In welchen (selte-
        nen) Situationen dieser Schalter notwendig ist, kann man in
        Abschnitt 2.9. nachlesen.

 - alias <neu>=<alt> :
        definiert den Prozessortyp <neu> als einen Alias für den
	Typen <alt>.  Zu den Sinn und Zweck von Aliassen siehe
	Abschnitt 2.7.

Sofern Schalter keine Argumente benötigen und ihre Zusammenziehung
keinen mehrbuchstabigen Schalter ergibt, können mehrere Schalter
auch auf einen Rutsch angegeben werden, wie z.B im folgenden Bei-
spiel:

 as test*.asm firstprog -cl /i c:\as\8051\include

Es werden alle Dateien TEST*.ASM sowie die Datei FIRSTPROG.ASM assem-
bliert, wobei für alle Dateien Listings auf der Konsole ausgegeben
und Sharefiles im C-Format erzeugt werden.  Nach Includes soll der
Assembler zusätzlich im Verzeichnis C:\AS\8051\INCLUDE suchen.

Dieses Beispiel zeigt, daß AS als Defaultendung für Quelldateien ASM
annimmt.

Neben der Angabe in der Kommandozeile können dauernd benötigte
Optionen in der Environment-Variablen ASCMD abgelegt werden. Wer z.B.
immer Listdateien haben möchte und ein festes Includeverzeichnis hat,
kann sich mit dem Befehl

 set ascmd=-L -i c:\as\8051\include

eine Menge Tipparbeit ersparen.  Da die Environment-Optionen vor der
Kommandozeile abgearbeitet werden, können Optionen in der Kommando-
zeile widersprechende im Environment übersteuern.

Bei sehr langen Pfaden kann es jedoch auch in der ASCMD-Variablen eng
werden.  Für solche Fälle kann auf eine sog. Key-Datei ausgewichen
werden, in der die Optionen genauso wie in der Kommandozeile oder
ASCMD-Variablen abgelegt werden können, nur daß diese Datei mehrere
Zeilen mit jeweils maximal 255 Zeichen enthalten darf.  Wichtig ist
dabei, daß bei Optionen, die ein Argument benötigen, sowohl Schalter
als auch Argument in EINER Zeile stehen müssen.  Der Name der Datei
wird AS dadurch mitgeteilt, daß er mit einem vorangestellten Klammer-
affen in der ASCMD-Variablen abgelegt wird, z.B.

 set ASCMD=@c:\as\as.key

Um Optionen in der ASCMD-Variablen (oder der Key-Datei) wieder aufzu-
heben, kann die Option mit einem vorangestellten Pluszeichen wieder
aufgehoben werden.  Soll in einem Einzelfall z.B. doch kein Listing
erzeugt werden, so kann es mit

 as +L <Datei>

wieder aufgehoben werden.  Natürlich ist es nicht ganz logisch, eine
Option mit einem Pluszeichen zu negieren...UNIX soit qui mal y pense.

Für den Fall, daß Sie AS von einem anderen Programm oder einer Shell
aufrufen wollen und diese Shell nur Klein- oder Großbuchstaben in der
Kommandozeile übergeben will, existiert folgendes Workaround: Wird
vor den Buchstaben der Option eine Tilde gesetzt, so werden die
folgenden Buchstaben immer als Kleinbuchstaben interpretiert.  Analog
erzwingt ein Lattenzaun die Interpretation als Großbuchstaben.  Es
ergeben sich z.B. folgende Transformationen:

 /~I ---> /i
 -#u ---> -U

Abhängig vom Ablauf der Assemblierung endet der Assembler mit fol-
genden Returncodes:

 0 : fehlerfreier Ablauf, höchstens Warnungen aufgetreten
 1 : Der Assembler hat nur die Aufrufparameter ausgegeben und endete
     danach sofort.
 2 : Es sind Fehler bei der Assemblierung aufgetreten, es wurde kein
     Codefile erzeugt.
 3 : Es trat ein fataler Fehler während des Ablaufes auf, der zum
     sofortigen Abbruch geführt hat.
 4 : Bereits während des Starts des Assemblers ist ein Fehler auf-
     getreten.  Dies kann ein Parameterfehler oder eine fehlerhafte
     Overlay-Datei sein.
255: Bei der Initialisierung ist irgendein interner Fehler aufgetre-
     ten, der auf keinen Fall auftreten sollte...neu booten, noch
     einmal probieren, und bei Reproduzierbarkeit mit mir Verbindung
     aufnehmen!

Zusätzlich endet jede Assemblierung einer Datei mit einer kleinen Sta-
tistik, die Fehlerzahlen, Laufzeit, Anzahl der Durchläufe und freien
Speicher ausgibt.  Bei eingeschaltetem Assembler-Listing wird diese
Statistik zusätzlich auch in das Listing geschrieben.

+------+
| OS/2 |
+------+
OS/2 erweitert wie Unix das Datensegment einer Anwendung erst dann,
wenn sie wirklich mehr Speicher anfordert.  Eine Angabe wie 

  511 KByte verfügbarer Restspeicher

bedeutet also nicht einen nahenden Systemabsturz wegen Speichermangel,
sondern stellt nur den Abstand zu der Grenze dar, bei der OS/2 einfach
ein paar mehr Kohlen in den Ofen schaufelt...

+------+
| UNIX |
+------+
Da es unter C auf verschiedenen Betriebssystemen keine kompatible
Möglichkeit gibt, den noch verfügbaren Speicher bzw. Stack zu
ermitteln, fehlen bei der C-Version diese beiden Angaben ganz.


	2.5. Format der Eingabedateien
	------------------------------

Wie die meisten Assembler auch erwartet AS genau einen Befehl pro Zeile
(Leerzeilen sind natürlich auch zugelassen).  Die Zeilen dürfen nicht
länger als 255 Zeichen werden, darüber hinaus gehende Zeichen werden
abgeschnitten.

Eine einzelne Zeile hat folgendes Format:

[Label[:]] <Befehl>[.Attribut] [Parameter[,Parameter..]] [; Kommentar]

Der Doppelpunkt nach dem Label ist optional, falls das Label in der
ersten Spalte beginnt (woraus folgt, daß der Befehl niemals in Spalte
1 beginnen darf).  Man muß ihn aber setzen, falls das Label nicht
in der ersten Spalte beginnt, damit AS es von einem Befehl unter-
scheiden kann.  In letzterem Fall muß übrigens zwischen Doppelpunkt
und dem Befehl mindestens ein Leerzeichen stehen, falls der eingestell-
te Zielprozessor zu denjenigen gehört, bei denen das Attribut auch
eine mit einem Doppelpunkt abgetrennte Formatangabe sein darf.  Dieser
Knopf ist aus Eindeutigkeitsgründen nötig, da sonst keine Unter-
scheidung zwischen Befehl mit Format und Label mit Befehl möglich
wäre.

Bei 680x0, SH7000, TLCS-9000, M16(C), XA, MSP430 sowie H8 dient ein 
dem Befehl mit einem Punkt angehängtes Attribut zur Beschreibung der 
Operandengröße.  Folgende Attributbuchstaben sind definiert:

   Attribut     arithmetisch-logischer Befehl      Sprungbefehl

      B		 Byte (8 Bit)		             -------

      W/H	 Wort (16 Bit)                       -------

      L/D/W      Langwort (32 Bit)              16-Bit-Displacement

      Q          Vierfachwort (64 Bit)               -------

      S          Single Precision (32 Bit)       8-Bit-Displacement

      D          Double Precision (64 Bit)           -------

      X		 Extended Precision (80/96 Bit) 32-Bit-Displacement

      P          Dezimalgleitkomma (80/96 Bit)       -------

Achtung: Nicht alle Befehle erlauben alle Operandengrößen, und manche
Befehle haben gar kein Attribut.  Zum genaueren Studium greife man auf
ein vernünftiges Programmierhandbuch zurück, z.B. in [Williams] für
die 68000er-Familie.

Bei TLCS-9000, H8/500 und M16(C) dient das Attribut sowohl der Angabe 
der Operandengröße, falls diese nicht durch die Operanden klar sein 
sollte, als auch der des zu verwendenden Befehlsformates.  Dieses muß
durch einen Doppelpunkt von der Operandengröße getrennt werden, z.B.
so:

    add.w:g   rw10,rw8

Was dieses Beispiel nicht zeigt, ist, daß die Formatangabe auch ohne
Operandengröße geschrieben werden darf.  Steht demgegenüber eine
Operandengröße ohne Formatangabe, verwendet AS automatisch das kür-
zeste Format.  Die erlaubten Befehlsformate und Operandengrößen sind
vom Maschinenbefehl abhängig und können z.B. [Tosh900], [HitH8_5],
[MitM16] bzw. [MitM16C] entnommen werden.

Die Zahl der Befehlsparameter ist abhängig vom Befehl und kann prin-
zipiell zwischen 0 und 20 liegen.  Die Trennung der Parameter von-
einander erfolgt ausschließlich durch Kommas (Ausnahme: DSP56000,
dessen parallele Datentransfers durch Leerzeichen getrennt werden),
wobei in Klammern oder Hochkommas eingeschlossene Kommas natürlich
nicht beachtet werden.

Anstelle eines Kommentars am Ende kann die Zeile auch nur aus einem
Kommentar bestehen, wenn er in der ersten Spalte beginnt.

Bei den Leerzeichen zur Trennung einzelnen Komponenten darf es sich
genausogut um Tabulatoren handeln.


	2.6. Format des Listings
	------------------------

Das von AS bei Angabe der Kommandozeilenoptionen i oder I erzeugte
Listing läßt sich grob in folgende Teile gliedern:

  1. Wiedergabe des assemblierten Quellcodes;
  2. Symbolliste;
  3. Belegungsliste;
  4. Querverweisliste.

Letztere beide werden nur erzeugt, wenn sie durch zusätzliche Kom-
mandozeilenoptionen angefordert wurden.

Im ersten Teil listet AS den kompletten Inhalt aller Quelldateien
inklusive des erzeugten Codes auf.  Eine Zeile in diesem Listing
hat dabei folgende Form:

   [<n>] <Zeile>/<Adresse> <Code> <Quelle>

Im Feld "n" zeigt AS die Include-Verschachtelungstiefe an.  Die
Hauptdatei (die Datei, mit der die Assemblierung begann), hat dabei
die Tiefe 0, von dort aus eingebundene Dateien haben Tiefe 1 usw.
Die Tiefe 0 wird dabei nicht angezeigt.

Im Feld "Zeile" wird die Zeilennummer bezogen auf die jeweilige
Datei ausgegeben.  Die erste Zeile einer Datei hat dabei Nummer 1.
Die Adresse, an der der für diese Zeile erzeugte Code abgelegt wur-
de, folgt hinter dem Schrägstrich im Feld "Adresse".

Der erzeugte Code selber steht dahinter im Feld "Code" in hexadezima-
ler Schreibweise.  Je nach Prozessortyp und aktuellem Segment können
die Werte entweder als Bytes oder 16/32-Bit-Worte formatiert sein.
Sollte mehr Code erzeugt worden sein, als in das Feld hineinpaßt, so
werden im Anschluß an die Zeile weitere Zeilen erzeugt, in denen nur
dieses Feld belegt ist.

Im Feld "Quelle" schlußendlich wird die Zeile aus der Quelldatei in
ihrer Originalform ausgegeben.

Die Symboltabelle ist so ausgelegt, daß sie nach Möglichkeit immer
in 80 Spalten dargestellt werden kann.  Für Symbole "normaler Länge"
wird eine zweispaltige Ausgabe gewählt.  Sollten einzelne Symbole
mit ihrem Wert die Grenze von 40 Spalten überschreiten, werden sie
in einer einzelnen Zeile ausgegeben.  Die Ausgabe erfolgt in alpha-
betischer Reihenfolge.  Symbole, die zwar definiert, aber nie benutzt
wurden, werden mit einem vorangestellten Stern (*) gekennzeichnet.

Die bisher genannten Teile sowie die Auflistung aller definierten
Makros/Funktionen lassen sich selektiv aus dem Gesamtlisting ein-
undausblenden, und zwar mit dem bereits erwähnten t-Kommandozei-
lenschalter.  Intern existiert in AS ein Byte, dessen Bits reprä-
sentieren, welche Teile ausgegeben werden sollen.  Den einzelnen
Bits sind dabei folgende Teile zugeordnet:

 Bit   Teil

  0   Quelldatei(en)+erzeugter Code
  1   Symboltabelle
  2   Makroliste
  3   Funktionsliste
  4   Zeilennumerierung

Defaultmäßig sind alle Bits auf 1 gesetzt, bei Verwendung des
Schalters

-t <Maske>

werden die in <Maske> gesetzten Bits gelöscht, so daß die entspre-
chenden Listing-Teile unterdrückt werden.  Analog lassen sich mit
einem Pluszeichen einzelne Teile wieder einschalten, falls man es
in der ASCMD-Variablen übertrieben hat...will man z.B. nur die
Symboltabelle haben, so reicht

-t 2  .

In der Belegungsliste werden für jedes Segment einzeln die belegten
Bereiche hexadezimal ausgegeben.  Handelt es sich bei einem Bereich
um eine einzige Adresse, wird nur diese ausgegeben, ansonsten erste
und letzte Adresse.

In der Querverweisliste wird für jedes definierte Symbol in alpha-
betischer Reihenfolge eine Ausgabe folgender Form erzeugt:

 Symbol <Symbolname> (=<Wert>,<Datei>/<Zeile>):
  Datei <Datei 1>:
  <n1>[(m1)]  ..... <nk>[(mk)]
  .
  .
  Datei <Datei l>:
  <n1>[(m1)]  ..... <nk>[(mk)]

Für jedes Symbol wird aufgelistet, in welchen Dateien es in wel-
chen Zeilen angesprochen wurde.  Sollte ein Symbol mehrmals in
der gleichen Zeile benutzt worden sein, so wird dies durch eine
in Klammern gesetzte Anzahl hinter der Zeilennummer angedeutet.
Sollte ein Symbol niemals benutzt worden sein, erscheint es auch
nicht in der Liste; entsprechend erscheint eine Datei auch über-
haupt nicht in der Liste eines Symbols, falls es in der ent-
sprechenden Datei nicht referenziert wurde.

ACHTUNG! AS kann dieses Listing nur dann korrekt aufs Papier bringen,
wenn man ihm vorher die Länge und Breite des Ausgabemediums mit
Hilfe des PAGE-Befehls (siehe dort) mitgeteilt hat!  Der voreinge-
stellte Default sind 60 Zeilen und eine unbegrenzte Zeilenbreite.


        2.7. Symbolkonventionen
        -----------------------

Symbole dürfen zwar (wie in der Einleitung bereits angedeutet) bis zu
255 Zeichen lang werden und werden auch auf der ganzen Länge unter-
schieden, die Symbolnamen müssen aber einigen Konventionen genügen:

Symbolnamen dürfen aus einer beliebigen Kombination von Buchstaben,
Ziffern, Unterstrichen und Punkten bestehen, wobei das erste Zeichen
keine Ziffer sein darf.  Der Punkt wurde nur zugelassen, um der MCS-51-
Notation von Registerbits zu genügen, und sollte möglichst nicht in
eigenen Symbolnamen verwendet werden.  Zur Segmentierung von Symbol-
namen sollte auf jeden Fall der Unterstrich und nicht der Punkt ver-
wendet werden.

Defaultmäßig ist AS nicht case-sensitiv, es ist also egal, ob man
Groß-oder Kleinbuchstaben verwendet.  Mittels des Kommandozeilenschal-
ters U läßt sich AS jedoch in einen Modus umschalten, in dem Groß-
und Kleinschreibung unterschieden wird.  Ob AS umgeschaltet wurde, 
kann mit dem vordefinierten Symbol CASESENSITIVE ermittelt werden:
TRUE bedeutet Unterscheidung, FALSE keine.

Dies sind die wichtigsten, von AS vordefinierten Symbole:

Name            Bedeutung

TRUE            logisch "wahr"
FALSE           logisch "falsch"

CONSTPI         Kreiszahl Pi (3.1415.....)

VERSION         Version von AS in BCD-Kodierung,
		z.B. 1331 hex für Version 1.33p1

DATE            Datum und
TIME            Zeitpunkt der Assemblierung
		(Beginn)

MOMCPU          momentan gesetzte Ziel-CPU
		(siehe Befehl CPU)
MOMCPUNAME      dito, nur als voll ausgeschrie-
                bener String

MOMFILE         augenblickliche Quelldatei
MOMLINE         Zeilennummer in Quelldatei
MOMPASS         Nummer des laufenden Durchgangs
MOMSECTION      Name der aktuellen Sektion oder
		Leerstring
MOMSEGMENT      Name des mit SEGMENT
                eingestellten Adreßraumes
*,$ bzw. PC     mom. Programmzähler

VORSICHT!  Während es im case-insensitiven Modus egal ist, mit welcher
Kombination von Groß- und Kleinbuchstaben man vordefinierte Symbole
anspricht, muß man sich im case-sensitiven Modus exakt an die oben
angegebene Schreibweise (nur Großbuchstaben) halten!

Zusätzlich definieren einige Pseudobefehle noch Symbole, die eine
Abfrage des damit momentan eingestellten Wertes ermöglichen.  De-
ren Beschreibung findet sich bei den zugehörigen Befehlen.

Ein etwas verstecktes (und mit Vorsicht zu nutzendes) Feature ist,
Symbolnamen aus String-Variablen zusammenzubauen, indem man den
Namen des Strings mit geschweiften Klammern in den Symbolnamen
einbaut.  So kann man z.B. den Namen eines Symbols anhand des
Wertes eines anderen Symbols festlegen:

cnt		set	cnt+1
temp		equ	"\{CNT}"
		jnz	skip{temp}
		.
		.
skip{temp}:	nop

ACHTUNG!  Der Programmierer ist selber dafür verantwortlich, daß
sich dabei gültige Symbolnamen ergeben!

Eine vollständige Auflistung aller von AS verwendeten Symbolnamen
findet sich in Anhang E.


	2.8. Formelausdrücke
	--------------------

An den meisten Stellen, an denen der Assembler Zahlenangaben erwartet,
können nicht nur einfache Symbole oder Konstanten angegeben werden,
sondern ganze Formelausdrücke.  Bei den Komponenten der Formelaus-
drücke kann es sich sowohl um ein einzelnes Symbol als auch um eine
Konstante handeln.  Die Schreibweise von Integerkonstanten kann in
verschiedenen Zahlensystemen erfolgen:

		Intel-Modus	  Motorola-Modus        C-Modus
	       (Intel, Zilog,   (Rockwell, Motorola,    (PowerPC,
		Thomson, Texas,  Microchip, Thomson,     AMD 29K,
		Toshiba, NEC,    Hitachi, Atmel)         National)
		Siemens, Philips)

dezimal		  direkt	       direkt            direkt

hexadezimal  nachgestelltes H     vorangestelltes $  vorangestelltes 0x

binär	     nachgestelltes B     vorangestelltes %  vorangestelltes 0b

oktal	     nachgestelltes O	  vorangestelltes @  vorangestellte 0

Damit hexadezimale Konstanten im Intel-Modus nicht als Symbolnamen
fehlinterpretiert werden können, müssen sie immer mit einer Ziffer
beginnen; anstelle z.B. F0H muß also 0F0H geschrieben werden.  Der
Motorola-bzw. C-Modus kennt derartige Probleme nicht (hihihi!).

Mit Hilfe des RELAXED-Befehls (siehe dort) kann die starre Zuordnung
einer Schreibweise zu einem Zielprozessor aufgehoben werden, so daß
man eine beliebige Schreibweise verwenden kann (auf Kosten der Kompa-
tibilität zu Standard-Assemblern).  Defaultmäßig ist diese Option
aber ausgeschaltet.

Integerkonstanten können auch als ASCII-Werte geschrieben werden,
so entsprechen

 'A'    == $41
 'AB'   == $4142
 'ABCD' == $41424344

Wichtig ist, daß hier die Zeichen in Hochkommas geschrieben werden,
um sie von den weiter unten beschriebenen Stringkonstanten zu unter-
scheiden.

Gleitkommakonstanten werden in der üblichen halblogarithmischen
Schreibweise geschrieben, die in der allgemeinsten Form

 [-]<Vorkommastellen>[.Nachkommastellen][E[-]Exponent]

lautet. ACHTUNG! Der Assembler versucht eine Konstante zuerst als
Integerkonstante zu verstehen und macht erst dann einen Versuch mit
Gleitkomma, falls dies gescheitert ist.  Will man aus irgendwelchen
Gründen die Auswertung als Gleitkommazahl erzwingen, so kann man dies
durch Dummy-Nachkommastellen erreichen, z.B.

   2 ---> 2.0

Stringkonstanten müssen in Gänsefüßchen eingeschlossen werden. Um nun
aber auch Gänsefüßchen und Sonderzeichen ohne Verrenkuungen in
Stringkonstanten schreiben zu können, wurde ein "Escape-Mechanismus"
eingebaut, der C-Programmierer(inne)n bekannt vorkommen dürfte:

Schreibt man einen Backslash (\) mit einer maximal dreiziffrigen
Zahl im String, so versteht der Assembler dies als Zeichen mit dem
entsprechenden dezimalen ASCII-Wert.  So kann man mit

\3
+------+
| UNIX |
+------+
ein ETX-Zeichen definieren.  Vorsicht allerdings mit der Definition
von NUL-Zeichen!  Da die C-Version von AS momentan intern zur Spei-
cherung von String-Symbolen C-Strings benutzt (die durch NUL-Zeichen
terminiert werden), sind NUL-Zeichen in Strings momentan nicht 
portabel!

Einige besonders häufig gebrauchte Steuerzeichen kann man auch mit
folgenden Abkürzungen erreichen:

\b : Backspace           \a : Klingel         \e : Escape
\t : Tabulator           \n : Zeilenvorschub  \r : Wagenrücklauf
\\ : Backslash           \' oder \h : Hochkomma
\" oder \i : Gänsefüßchen

Die Kennbuchstaben dürfen sowohl groß als auch klein geschrieben
werden.

Über dieses Escape-Zeichen können sogar Formelausdrücke in den
String eingebaut werden, wenn sie in geschweifte Klammern einge-
faßt werden: z.B. ergibt

    message "Wurzel aus 81 : \{sqrt(81)}"

die Ausgabe

    Wurzel aus 81 : 9

AS wählt anhand des Formelergebnistyps die richtige Ausgabeform, zu
vermeiden sind lediglich weitere Stringkonstanten im Ausdruck, da
der Parser bei der Groß-zu-Kleinbuchstabenumwandlung sonst durchein-
anderkommt.  ACHTUNG!  Integer-Konstanten werden hexadezimal und
"nackt" eingesetzt, d.h. ohne z.B. vorangestelltes Dollarzeichen
oder die bei Intel bisweilen erforderliche Null...

Bis auf den Einbau von Formelausdrücken ist dieser Escape-Mechanismus
auch in als ASCII definierten Integerkonstanten zulässig, z.B. so:

   move.b   #'\n',d0

Jedoch hat alles seine Grenzen, weil der darüberliegende Parser, der
die Zeile in Opcode und Parameter zerlegt, nicht weiß, womit er da
eigentlich arbeitet, z.B. hier:

   move.l   #'\'abc',d0

Nach dem dritten Hochkomma findet er das Komma nicht mehr, weil er
vermutet, daß eine weitere Zeichenkonstante beginnt, und eine
Fehlermeldung über eine falsche Parameterzahl ist die Folge.  Abhilfe
wäre z.B., \i anstelle \' zu schreiben.

Die Berechnung von im Formelausdruck entstehenden Zwischenergebnissen
erfolgt immer mit der höchsten verfügbaren Wortbreite, d.h. 32 Bit für
Ganzzahlen, 80 Bit für Gleitkommazahlen und 255 Zeichen für Strings.
Eine eventuelle Prüfung auf Wertebereichsüberschreitung findet erst am
Endergebnis statt.

+------+
| UNIX |
+------+
Die portable C-Version kann nur mit 64-Bit-Gleitkommazahlen umgehen,
ist daher auf einen Maximalwert von ca. 10^308 beschränkt.  Als
Ausgleich werden auf einigen Plattformen Integers mit 64 Bit Breite
behandelt.

Der Assembler stellt zur Verknüpfung folgende Operanden zur Verfügung:

Operand   Funktion           #Operanden Integer Gleitkomma String Rang

  <>      Ungleichheit            2       ja        ja      ja     14
  >=      größer oder gleich      2       ja        ja      ja     14
  <=      kleiner oder gleich     2       ja        ja      ja     14
  <       echt kleiner            2       ja        ja      ja     14
  >       echt größer             2       ja        ja      ja     14
  =       Gleichheit              2       ja        ja      ja     14

  !!      log. XOR                2       ja        nein    nein   13
  ||      log. OR                 2       ja        nein    nein   12
  &&      log. AND                2       ja        nein    nein   11
  ~~      log. NOT                1       ja        nein    nein    2

  -       Differenz               2       ja        ja      nein   10
  +       Summe                   2       ja        ja      ja     10
  #       Modulodivision          2       ja        nein    nein    9
  /       Quotient                2       ja *)     ja      nein    9
  *       Produkt                 2       ja        ja      nein    9
  ^       Potenz                  2       ja        ja      nein    8

  !       binäres XOR             2       ja        nein    nein    7
  |       binäres OR              2       ja        nein    nein    6
  &       binäres AND             2       ja        nein    nein    5
  ><      Bitspiegelung           2       ja        nein    nein    4
  >>      log. Rechtsschieben     2       ja        nein    nein    3
  <<      log. Linksschieben      2       ja        nein    nein    3
  ~       binäres NOT             2       ja        nein    nein    1

*) Rest wird verworfen


Unter "Rang" ist dabei die Priorität zu verstehen, die dieser Opera-
tor bei der Teilung eines Ausdruckes in Unterausdrücke hat, der
ranghöchste Operator wird also ZULETZT ausgewertet.  Die Reihenfolge
der Evaluierung läßt sich durch Klammerung neu festlegen.

Die Vergleichsoperatoren liefern TRUE, falls die Bedingung zutrifft,
und FALSE falls nicht.  Für die logischen Operatoren ist ein Ausdruck
TRUE, falls er ungleich 0 ist, ansonsten FALSE.

Die Bitspiegelung ist wohl etwas erklärungsbedürftig: Der Operator
spiegelt die untersten Bits im ersten Operanden, läßt die darüberlie-
genden Bits aber unverändert.  Die Zahl der zu spiegelnden Bits ist
der rechte Operand und darf zwischen 1 und 32 liegen.

Zusätzlich zu den Operatoren definiert der Assembler noch eine Reihe
in erster Linie transzendenter Funktionen mit Gleitkommaargument:

Name      Bedeutung           Argument            Ergebnis

SQRT      Quadratwurzel       arg >= 0            Gleitkomma

SIN       Sinus               arg reell           Gleitkomma
COS       Kosinus             arg reell           Gleitkomma
TAN       Tangens             arg <> (2*n+1)*Pi/2 Gleitkomma
COT       Kotangens           arg <> n*Pi         Gleitkomma

ASIN      inverser Sinus      |arg| <= 1          Gleitkomma
ACOS      inverser Kosinus    |arg| <= 1          Gleitkomma
ATAN      inverser Tangens    arg reell           Gleitkomma
ACOT      inverser Kotangens  arg reell           Gleitkomma

EXP       Exponentialfunktion arg reell           Gleitkomma
ALOG      10 hoch Argument    arg reell           Gleitkomma
ALD       2 hoch Argument     arg reell           Gleitkomma
SINH      hyp. Sinus          arg reell           Gleitkomma
COSH      hyp. Kosinus        arg reell           Gleitkomma
TANH      hyp. Tangens        arg reell           Gleitkomma
COTH      hyp. Kotangens      arg <> 0            Gleitkomma

LN        nat. Logarithmus    arg > 0             Gleitkomma
LOG       dek. Logarithmus    arg > 0             Gleitkomma
LD        2er Logarithmus     arg > 0             Gleitkomma
ASINH     inv. hyp. Sinus     arg reell           Gleitkomma
ACOSH     inv. hyp. Kosinus   arg >= 1            Gleitkomma
ATANH     inv. hyp. Tangens   arg < 1             Gleitkomma
ACOTH     inv. hyp. Kotangens arg > 1             Gleitkomma

INT       ganzzahliger Anteil arg reell           Gleitkomma

BITCNT    binäre Quersumme    Integer             Integer
FIRSTBIT  niedrigstes 1-Bit   Integer             Integer
LASTBIT   höchstes 1-Bit      Integer             Integer
BITPOS    einziges 1-Bit      Integer             Integer

SGN       Vorzeichen (0/1/-1)  Gleitkomma oder    Integer
                               Integer
ABS       Betrag               Integer oder       Integer oder
			       Gleitkomma         Gleitkomma
TOUPPER   pass. Großbuchstabe  Integer            Integer
TOLOWER   pass. Kleinbuchstabe Integer            Integer

UPSTRING  wandelt alle Zei-   String              String
          chen in Großbuch-
	  staben

LOWSTRING wandelt alle Zei-   String              String
          chen in Kleinbuch-
	  staben

VAL       evaluiert Stringin- String              abh. von
	  halt als Ausdruck                       Argument

Die Funktionen FIRSTBIT, LASTBIT und BITPOS liefern als Ergebnis
-1, falls überhaupt kein bzw. nicht genau ein Bit gesetzt ist. Zu-
sätzlich gibt BITPOS in einem solchen Fall eine Fehlermeldung aus.

Wenn eine Funktionen auch Gleitkommaargumente erwartet, so soll
dies nicht bedeuten, daß man nicht z.B.

wur2 equ sqrt(2)

schreiben dürfte - in solchen Fällen findet automatisch eine Typ-
konvertierung statt.  Umgekehrt muß allerdings die INT-Funktion an-
gewandt werden, um eine Gleitkommazahl ganz zu bekommen.  Bei der
Benutzung dieser Funktion ist zu beachten, daß sie als Ergebnis
immer einen vorzeichenbehafteten Integer liefert, sie hat also
einen Wertebereich von ca. +/-2.0E9.

Schaltet man AS in den case-sensitiven Modus, so können im Gegen-
satz zu vordefinierten Symbolen die vordefinierten Funktionen
weiterhin in beliebiger Schreibweise angesprochen werden.  Bei
selbstdefinierten Funktionen (siehe Abschnitt 3.4.6) wird allerdings
unterschieden.  Dies hat zur Folge, daß z.B. bei der Definition
einer Funktion 'Sin' man mit 'Sin' diese Funktion auch erreicht,
mit allen anderen Schreibweisen jedoch die eingebaute Funktion.

+----------+
| DOS/DPMI |
+----------+
Für eine korrekte Umwandlung von Klein-zu Großbuchstaben ist eine
DOS-Version >=3.30 erforderlich.


        2.9. Vorwärtsreferenzen und andere Desaster
        -------------------------------------------

Dieser Abschnitt ist das Produkt eines gewissen Grolls auf die (durch-
aus legale) Art und Weise, wie einige Leute programmieren, die in Zu-
sammenhang mit AS bisweilen das eine oder andere Problem verursachen
kann.  Die Rede ist hier von sogenannten "Vorwärtsreferenzen".  Was
unterscheidet eine Vorwärtsreferenz von einer normalen Referenz? 
Dazu sehe man sich folgendes Programmbeispiel an (man sehe mir bitte
meine - auch im Rest dieser Anleitung anzutreffende - 68000-Lastig-
keit nach):

        move.l  d0,#10
loop:   move.l  d1,(a1)
        beq     skip
        neg.l   d1
skip:   move.l  (a1+),d1
        dbra    d0,loop

Denkt man sich den Scheifenrumpf mit dem Sprung weg, so bleibt ein
äußerst angenehm zu assemblierendes Programm übrig: die einzige
Referenz ist der Rücksprung zum Anfang des Rumpfes, und da ein
Assembler ein Programm von vorne nach hinten durcharbeitet, hat er
den Symbolwert bereits ermittelt, bevor er ihn zum erstem Mal benö-
tigt.  Sofern man ein Programm hat, das nur solche Rückwärtsreferen-
zen besitzt, ist man in der angenehmen Lage, nur einmal durch den
Quellcode gehen zu müssen, um den korrekten und optimalen Maschinen-
code zu finden.  Einige Hochsprachen wie Pascal mit ihrer strikten
Regel, daß alles vor der ersten Benutzung definiert sein muß, nutzen
genau diese Eigenschaft aus, um den Übersetzungsvorgang zu beschleu-
nigen.  

Leider ist die Sache im Falle von Assembler nicht so einfach, denn man
will ja bisweilen auch vorwärts im Code springen oder muß aus bestimm-
ten Gründen Variablendefinitionen hinter den Code verlegen.  Dies ist
im Beispiel der Fall für den bedingten Sprung, mit dem ein anderer
Befehl übersprungen wird.  Wenn der Assembler im ersten Durchlauf auf
den Sprungbefehl trifft, so sieht er sich mit der Situation konfron-
tiert, entweder die Teilfelder der Instruktion, die die Sprungadresse
beinhalten, leerzulassen, oder seitens des Formelparsers (der das
Adreßargument ja auswerten muß) anstelle des korrekten, aber unbekann-
ten Wertes einen Wert anzubieten, der "niemandem wehtut".  Bei einem
einfachen Assembler, der nur eine Zielarchitektur kennt und bei dem
sich die betroffenen Befehle an einer Hand abzählen lassen, wird man
sicher die erste Variante wählen, bei AS mit seinen vielen Dutzend
Zielen wäre die Zahl der Sonderabfragen aber extrem hoch geworden, so
daß nur der zweite Weg in Frage kam: Falls im ersten Pass ein unbekan-
ntes Symbol auftaucht, so liefert der Formelparser den momentanen
Stand des Programmzählers als Ergebnis zurück!  Nur dieser Wert ist
geeignet, relativen Sprüngen mit Sprungdistanzen unbekannter Länge ei-
ne Adresse anzubieten, die nicht zu Fehlern führt.  Dies beantwortet
auch die bisweilen gestellte Frage, warum in einem Listing des ersten
Passes (dies bleibt z.B. stehen, wenn AS aufgrund anderer Fehler den
zweiten Pass erst gar nicht beginnt), z.T. falsche Adressen im erzeug-
ten Binärcode gezeigt werden - dies sind noch nicht aufgelöste Vor-
wärtsreferenzen.  

Das obige Beispiel offenbart allerdings noch eine weitere Schwierig-
keit von Vorwärtsreferenzen: Je nach Abstand von Quelle und Ziel im
Code kann der Sprungbefehl entweder lang oder kurz sein.  Diese Ent-
scheidung über die Code-Länge - und damit auch die Adressen folgender
Labels - kann jedoch mangels genauer Kenntnis der Zieladresse im
ersten Pass nicht erfolgen.  Sofern der Programmierer nicht explizit
kenntlich gemacht hat, ob der Sprung lang oder kurz sein soll, behel-
fen sich reine 2-Pass-Assembler wie ältere MASM-Versionen von Micro-
soft damit, im ersten Pass (nach diesem müssen alle Adressen fest-
liegen) Platz für die längste Version zu reservieren und im zweiten
Pass den überschüssigen Platz mit NOPs aufzufüllen.  AS-Versionen bis
1.37 taten dieses ebenfalls, danach bin ich auf das Multipass-Verfah-
ren übergegangen, das die strenge Einteilung in zwei Passes aufhebt
und beliebig viele Durchgänge erlaubt.  Dazu wird im ersten Pass der
optimale Code mit den angenommenen Symbolwerten erzeugt.  Stellt AS
fest, daß im zweiten Pass durch Codelängenveränderungen sich Werte
von Symbolen geändert haben, so wird einfach noch ein dritter Pass
eingelegt, und da durch die neuen Symbolwerte des zweiten Passes auch
im dritten Pass sich der Code wieder verkürzen oder verlängern kann,
ist ein weiterer Pass nicht unmöglich.  Ich habe schon 8086-Programme
erlebt, bei denen erst nach 12 Durchgängen alles stimmte.  Leider
erlaubt dieser Mechanismus nicht die Vorgabe einer Maximalzahl von
Durchläufen, ich kann als Regel nur sagen, daß die Anzahl von Durch-
läufen sinkt, je mehr man davon Gebrauch macht, Sprung- oder Adreß-
längen explizit vorzugeben.

Speziell bei großen Programmen kann es zu einer interessanten Situ-
ation kommen: Die Lage eines vorwärts gerichteten Sprunges hat sich
im zweiten Pass so weit gegenüber dem ersten verschoben, daß der
jetzt noch benutzte Label-Wert aus dem ersten Pass außerhalb der er-
laubten Sprungdistanz liegt.  AS berücksichtigt solche Situationen,
indem er jegliche Fehlermeldungen über zu weite Sprungdistanzen unter-
drückt, sobald er erkannt hat, daß er wegen sich ändernder Symbolwer-
te ohnehin einen weiteren Durchlauf machen muß.  Dies funktioniert
zwar in 99% aller Fälle, es gibt jedoch auch Konstrukte, in denen der
erste, derartig kritische Befehl bereits auftaucht, bevor AS eine
Chance hat, zu erkennen, daß ein neuer Pass erforderlich ist.  Das
folgende Beispiel konstruiert eine solche Situation mit Hilfe einer
Vorwärtsreferenz (und war der Anlaß für die Überschrift dieses Ab-
schnitts...):

        cpu   6811

        org     $8000
        beq     skip
        rept    60
         ldd    Var
        endm
skip:   nop

Var     equ     $10

Aufgrund der Adreßlage nimmt AS im ersten Pass lange Adressen für die
LDD-Befehle an, was eine Code-Länge von 180 Bytes ergibt und im zweiten
Pass (zum Zeitpunkt des BEQ-Befehls ist noch der "falsche" Wert von
'skip' aktuell, d.h. AS weiß zu diesem Zeitpunkt noch nicht, daß der
Code in Wirklichkeit nur 120 Bytes lang ist) gibt es eine Fehlermel-
dung wegen einer überschrittenen Sprungdistanz.  Dieser Fehler läßt 
sich auf drei Arten vermeiden:

 1. Weisen Sie AS explizit darauf hin, daß er für die LDD-Befehle kur-
    ze Adressen verwenden darf (ldd <Var)

 2. Entfernen Sie diese vermaledeite, verfluchte Vorwärtsreferenz und
    setzen Sie die EQU-Anweisung nach vorne, wo sie hingehört (OK, ich
    beruhige mich ja schon wieder...)

 3. Für ganz Unentwegte: Benutzten Sie die '-Y'-Option, so daß AS die
    Fehlermeldung beim Erkennen der Adreßverschiebung nachträglich
    verwirft.  Nicht schön, aber...

Noch ein Hinweis zum EQU-Befehl:  Da AS nicht wissen kann, in welchem
Zusammenhang ein mit EQU definiertes Symbol später verwendet wird,
wird ein EQU mit Vorwärtsreferenzen im ersten Pass überhaupt nicht
durchgeführt.  Wird das mit EQU definierte Symbol also im zweiten
Pass vorwärts referenziert:

        move.l  #sym2,d0
sym2    equ     sym1+5
sym1    equ     0

so handelt man sich im zweiten Pass eine Fehlermeldung wegen eines un-
definerten Symbols ein...aber warum machen Leute eigentlich solche
Dinge ???

Zugegeben, das war ein ziemlich länglicher Ausflug, aber es mußte ein-
fach einmal sein.  Was sollte man als Erkenntnis aus diesem Abschnitt
mitnehmen?

 1. AS versucht immer, den kürzestmöglichen Code zu erzeugen.  Dazu
    benötigt er eine endliche Zahl von Durchläufen.  Wenn man ihn 
    nicht gerade knebelt, kennt AS keine Rücksichten...

 2. Wenn sinnvoll und möglich, Sprung- und Adreßlängen explizit vor-
    geben.  Man kann damit u.U. die Anzahl der Durchläufe deutlich
    reduzieren.

 3. Vorwärtsreferenzen auf das allernötigste beschränken.  Man er-
    leichtert sich und AS das Leben damit erheblich!


	2.10. Sharefile
	---------------

Diese Funktion ist ein Abfallprodukt aus den reinen 68000er-Vorgän-
gern von AS, da sie vielleicht doch der (die?!) eine oder andere ge-
brauchen könnte, habe ich sie dringelassen.  Grundproblem ist es,
an bestimmte beim Assemblieren entstehende Symbole heranzukommen,
weil man evtl. mit diesen Adreßinformationen auf den Speicher des
Zielsystems zugreifen möchte.  Der Assembler erlaubt es, mit Hilfe
des SHARED-Pseudobefehles (siehe dort) Symbolwerte extern zur Ver-
fügung zu stellen.  Zu diesem Zweck erstellt der Assembler im zwei-
ten Pass eine Textdatei mit den gewünschten Symbolen und ihren Wer-
ten, die mittels Include in ein Hochsprachen-oder weiteres Assembler-
programm eingebunden werden können.  Das Format der Textdatei (C, Pas-
cal oder Assembler) wird durch die Kommandozeilenschalter p, c oder a
festgelegt.

ACHTUNG! Ist keiner dieser Schalter angegeben, so wird auch keine Da-
tei erzeugt, egal ob sich SHARED-Befehle im Quelltext finden oder
nicht!

AS prüft beim Anlegen der Share-Datei nicht, ob bereits eine Datei
gleichen Namens existiert, eine solche wird ggfs. einfach über-
schrieben.  Eine Abfrage halte ich nicht für sinnvoll, da AS dann
bei jedem Lauf fragen würde, ob er die alte Version der Share-Datei
überschreiben darf, und das wäre doch sehr lästig...


	2.11. Prozessor-Aliasse
        ------------------------

Mit Varianten gängiger Mikrocontroller-Familien ist es wie mit Kanin-
chen: Sie vermehren sich schneller, als man mit der Versorgung hinter-
herkommen kann.  Im Zuge der Entwicklung von Prozessorkernen als Bau-
steine für ASICs und von Controller-Familien mit vom Kunden wählbarer
Peripherie wird die Zahl von Controller-Varianten, die sich von einem
bekannten Typ nur in einigen Peripherie-Details unterscheiden, immer
größer.  Die Unterscheidung der einzelnen Typen ist aber trotz meist
identischer Prozessorkernes wichtig, um z.B. in den Includefiles den
korrekten Satz von Peripherieregistern einzublenden.  Bisher habe ich
mich zwar immer bemüht, die wichtigsten Vertreter einer Familie in AS
einzubauen (und werde das auch weiter tun), aber manchmal läuft mir
die Entwicklung einfach auf und davon...es mußte also ein Mechanismus
her, mit dem man die Liste der unterscheidbaren Prozessortypen selbst
erweitern kann.

Das Ergebnis davon sind Prozessor-Aliasse: Mit der alias-Kommandozei-
lenoption kann man einen neuen Prozessortyp definieren, der im Be-
fehlssatz einem anderen, in AS fest eingebauten Typ entspricht.  Bei
Benutzung dieses Typs im CPU-Befehl wird sich AS also wie beim "Origi-
nal" verhalten, mit einem Unterschied: Die Variablen MOMCPU bzw.
MOMCPUNAME werden auf den Namen des Alias gesetzt, wodurch der neue
Name zur Unterscheidung z.B. in Includefiles dienen kann.

Die Definition dieser Aliasse wurde aus zwei Gründen mit Kommandozei-
lenoptionen anstatt Pseudobefehlen vorgenommen: zum einen wäre es ohne-
hin nicht möglich gewesen, die Definition der Aliasse zusammen mit den
Registerdefinitionen in eine Include-Datei zu legen, denn in einem
Programm, das so eine Datei benutzen wollte, müßte sie ja sowohl vor
als auch nach dem CPU-Befehl in der Hauptdatei eingebunden werden -
eine Vorstellung, die irgendwo zwischen unelegant und unmöglich liegt.
Zum zweiten ermöglicht diese Implementierung, die Definition der neuen
Typen in eine Datei zu legen, die über die ASCMD-Variable beim Start
automatisch ausgeführt wird, ohne das sich das Programm darum kümmern
müßte.


	3. Pseudobefehle
        ================

Nicht für alle Prozessoren sind alle Pseudobefehle definiert.  Vor
der Beschreibung eines Befehles ist deshalb jeweils vermerkt, für
welche Prozessortypen dieser Befehl erlaubt ist.


	3.1. Definitionen
        -----------------

	3.1.1.  SET und EQU
	- - - - - - - - - -

--> Gültigkeit: alle Prozessoren

SET und EQU erlauben die Definition typenloser Konstanten, d.h. sie
werden keinem Segment zugeordnet und ihre Verwendung erzeugt in kei-
nem Fall eine Warnung wegen Segmentverquickung.  Während EQU Konstan-
ten definiert, die nicht wieder (mit EQU) geändert werden können,
erlaubt SET die Definition von Variablen, die sich während des As-
semblerlaufes verändern lassen.  Dies ist nützlich z.B. bei der
Allokation von Resourcen  la Interruptvektoren, wie im folgenden
Beispiel:

VecCnt		set	0		; irgendwo am Anfang

		.
                .
                .

DefVec		macro	Name		; einen neuen Vektor belegen
Name		equ	VecCnt
VecCnt		set	VecCnt+4
		endm

		.
		.
		.


		DefVec	Vec1		; ergibt Vec1=0
		DefVec	Vec2		; ergibt Vec2=4

Intern werden Konstanten und Variablen identisch gespeichert, der
einzige Unterschied ist, daß sie mit SET umdefiniert werden können
und mit EQU nicht.  Es ist daher möglich, ein Symbol mit EQU zu de-
finieren und es mit SET zu ändern (auch wenn das nicht der Sinn
der Sache ist).  Aus einem weiteren Grund sollte man davon sogar
explizit die Finger lassen: Im Gegensatz zu SET prüft EQU, ob der
neu zugewiesene Wert sich von einem evtl. bisher existierenden
unterscheidet.  Da sich dieser für mit EQU definierte Konstanten
nicht ändern sollte, vermutet AS einen Phasenfehler und legt einen
weiteren Pass ein...würde man in obigem Beispiel z.B. die Initia-
lisierung des Zählers mit EQU durchführen, so würde AS sich zwar
nicht beschweren, da eine einmalige Neuzuweisung pro Pass erlaubt
ist (bei n Durchgängen kommt man nun einmal n-mal an dieser Stelle
vorbei), aber endlos neue Passes anstoßen, da der Initialwert des
Zählers immer vom Endwert verschieden ist.

Mit SET/EQU lassen sich Konstanten aller Typen definieren, z.B.

IntZwei		equ	2
FloatZwei	equ	2.0

Einige Prozessoren besitzen leider bereits selber einen SET-Befehl.
Bei diesen muß EVAL anstelle von SET verwendet werden.

Anstelle von EQU darf auch einfach ein Gleichheitszeichen ge-
schrieben werden, analog kann man anstelle von SET bzw. EVAL
einfach := schreiben.

Defaultmäßig sind mit SET oder EQU definierte Symbole typenlos,
optional kann jedoch als zweites Argument ein Segmentname (CODE,
DATA, IDATA, XDATA, YDATA, BITDATA, IO oder REG) oder MOMSEGMENT für
das aktuell gesetzte Segment angegeben werden, um das Symbol einem
bestimmten Adreßraum zuordnen.


	3.1.2. SFR und SFRB
        - - - - - - - - - -

--> Gültigkeit: diverse, SFRB nur MCS-51

Diese Befehle funktionieren wie EQU, nur sind die damit definierten
Symbole dem direkt adressierbaren Datensegment zugeordnet, d.h. sie
dienen bevorzugt zur Definition von RAM-Zellen und (wie der Name
ahnen läßt) im Datenbereich eingeblendeten Hardwareregistern.  Der
dabei zugelassene Wertebereich ist identisch mit dem bei ORG für das
DATA-Segment zugelassenen (s. Abschnitt 3.2.1).  SFR und SFRB
unterscheiden sich darin, daß SFRB das Register als bitadressierbar
kennzeichnet, weshalb AS zusätzlich 8 Symbole erzeugt, die dem Bit-
segment zugeordnet werden und die Namen xx.0 bis xx.7 tragen, z.B.

PSW		sfr	0d0h	; ergibt PSW = D0H (Datensegment)

PSW		sfrb	0d0h	; ergibt zusätzlich PSW.0 = D0H (Bit)
				;               bis PSW.7 = D7H (Bit)

Da beim 80C251 grundsätzlich alle SFRs ohne zusätzliche Bit-Symbole
bitadressierbar sind, ist der SFRB-Befehl für ihn auch nicht mehr
definiert; die Bits PSW.0 bis PSW.7 sind automatisch vorhanden.

AS überprüft bei der Definition eines bitadressierbaren Registers mit
SFRB, ob die Speicherstelle überhaupt bitadressierbar ist (Bereich
20h..3fh bzw. 80h, 88h, 90h, 98h...0f8h).  Ist sie es nicht, so wird eine
Warnung ausgegeben; die dann erzeugten Bit-Symbole sind undefiniert.


	3.1.3.  XSFR und YSFR
	- - - - - - - - - - -

--> Gültigkeit: DSP56000

Auch der DSP56000 hat einige Peripherieregister memory-mapped im
Speicher liegen, die Sache wird jedoch dadurch komplizierter, daß
es zwei Datenbereiche gibt, den X-und Y-Bereich.  Diese Architektur
erlaubt einerseits zwar einen höheren Parallelitätsgrad, zwingt je-
doch andererseits dazu, den normalen SFR-Befehl in die beiden oben
genannten Varianten aufzuspalten.  Sie verhalten sich identisch zu
SFR, nur daß XSFR ein Symbol im X-Adreßraum definiert und YSFR ent-
sprechend eines im Y-Adreßraum.  Der erlaubte Wertebereich ist
0..$ffff.


	3.1.4.  LABEL
	- - - - - - -

--> Gültigkeit: alle Prozessoren

Die Funktion des LABEL-Befehls ist identisch zu EQU, nur wird das
Symbol nicht typenlos, sondern erhält das Attribut "Code".  LABEL wird
genau für einen Zweck benötigt: Labels in Makros sind normalerweise
lokal, also nicht außerhalb des Makros zugreifbar.  Mit einem EQU-
Befehl kann man sich zwar aus der Affäre ziehen, die Formulierung

<Name>   label    $

erzeugt aber ein Symbol mit korrekten Attributen.


	3.1.5.  BIT
	- - - - - -

--> Gültigkeit: MCS/(2)51, XA, 80C166, 75K0, ST9

BIT dient dazu, ein einzelnes Bit einer Speicherstelle mit einem sym-
bolischen Namen gleichzusetzen.  Da die Art und Weise, wie verschie-
dene Prozessoren Bitverarbeitung und -adressierung betreiben, stark
variiert, verhält sich auch dieser Befehl je nach Zielplattform
anders:

Für die MCS/51-Familie, die einen eigenen Adreßraum für Bitoperanden
besitzt, ist die Funktion von BIT ganz analog zu SFR, d.h. es wird
einfach ein Integer-Symbol mit dem angegebenen Wert und dem Segment
BDATA erzeugt.  Für alle anderen Prozessoren wird die Bitadressierung
dagegen zweidimensional mit Adresse und Bitstelle vorgenommen.  In
diesem Fall verpackt AS beide Teile in einer vom jeweiligen Prozessor
abhängigen Weise in ein Integer-Symbol und dröselt dieses bei der
Benutzung wieder in die beiden Teile auseinander.  Letzterer Fall
trifft auch schon für den 80C251 zu:  Während zum Beispiel der Befehl

Mein_Carry	bit	PSW.7

auf einem 8051 noch dem Symbol Mein_Carry den Wert 0d7h zuweisen
würde, würde auf einem 80C251 dagegen ein Wert von 070000d0h gene-
riert werden, d.h. die Adresse steht in Bit  0..7 sowie die Bitstelle
in Bit 24..26.  Dieses Verfahren entspricht dem, das auch beim DBIT-
Befehl des TMS370 angewendet wird und funktioniert sinngemäß so auch
beim 80C166, nur daß dort Bitstellen von 0 bis 15 reichen dürfen:

MSB     BIT     r5.15

Beim Philips XA findet sich in Bit 0..9 die Bitadresse, wie sie auch
in die Maschinenbefehle eingesetzt wird, für Bits aus den RAM-Speicher
wird in Bit 16..23 die 64K-Bank eingesetzt.

Noch etwas weiter geht der BIT-Befehl bei der 75K0-Familie: Da dort
Bitadressierungen nicht nur absolute Basisadressen verwenden dürfen,
sind sogar Ausdrücke wie

bit1    BIT     @h+5.2

erlaubt.

Beim ST9 ist es hingegen möglich, Bits auch invertiert anzusprechen, 
was beim BIT-Befehl auch berücksichtigt wird:

invbit  BIT     r6.!3

Näheres zum BIT-Befehl beim ST9 findet sich bei den prozessorspezi-
fischen Hinweisen.


	3.1.6. DBIT
	- - - - - -

--> Gültigkeit: TMS 370xxx

Die TMS370-Reihe hat zwar kein explizites Bit-Segment, jedoch können
einzelne Bits als Symbol durch diesen Befehl simuliert werden.  DBIT
benötigt zwei Operanden, nämlich einmal die Adresse der Speicherstel-
le, in der das Bit liegt, sowie die genaue Position des Bits im Byte.
So definiert man z.B. mit

INT3            EQU     P019
INT3_ENABLE     DBIT    0,INT3

das Bit, welches Interrupts von Anschluß INT3 freigibt.  So defi-
nierte Bits können dann von den Befehlen SBIT0, SBIT1, CMPBIT, JBIT0
und JBIT genutzt werden.


	3.1.7. PORT
	- - - - - -

--> Gültigkeit: 8080/8085/8086, XA, Z80, 320xx, TLCS-47, AVR

PORT arbeitet analog zu SFR, nur wird das Symbol dem I/O-Adreßbereich
zugeordnet.  Erlaubte Werte sind 0..7 beim 3201x, 0..15 beim 320C2x,
0..65535 beim 8086, 0..63 beim AVR, und 0..255 beim Rest.

Beispiel: eine PIO 8255 liege auf Adresse 20H:

PIO_Port_A	port	20h
PIO_Port_B	port	PIO_Port_A+1
PIO_Port_C	port	PIO_Port_A+2
PIO_Ctrl	port	PIO_Port_A+3


	3.1.8.  REG
	- - - - - -         

--> Gültigkeit: ST9

REG arbeitet analog zu SFR, nur wird das Symbol dem Register-
Adreßbereich zugeordnet.  Erlaubte Werte sind 0..255.


        3.1.9.  LIV und RIV
        - - - - - - - - - -

--> Gültigkeit: 8X30x

LIV und RIV dienen dazu, sogenannte IV-Bus-Objekte zu definieren. 
Bei diesen handelt es sich um Bitgruppen in peripheren Speicherzellen
mit einer Länge von 1..8 Bit, die fortan symbolisch angesprochen
werden können, so daß man bei den entsprechenden Befehlen nicht mehr
Adresse, Länge und Position separat angeben muß.  Da die
8X30x-Prozessoren zwei periphere Adreßräume besitzen (einen 'linken'
und einen 'rechten', sind auch zwei separate Befehle definiert.  Die
Parameter dieser Befehle sind allerdings identisch: es müssen drei
Parameter sein, die Adresse, Startposition und Länge angeben. 
Weitere Hinweise zur Benutzung von Busobjekten finden sich in
Abschnitt 4.14 .


	3.1.10. CHARSET
	- - - - - - - -

--> Gültigkeit: alle Prozessoren

Einplatinensysteme, zumal wenn sie LCDs ansteuern, benutzen häufig
einen anderen Zeichensatz als ASCII, und daß die Umlautkodierung mit
der im Befehl übereinstimmt, dürfte wohl reiner Zufall sein.  Um nun
aber keine fehlerträchtigen Handumkodierungen vornehmen zu müssen,
enthält der Assembler eine Umsetzungstabelle für Zeichen, die jedem
Quellcode ein Zielzeichen zuordnet.  Zur Modifikation dieser Tabelle
( die initial 1:1 übersetzt ), dient der Befehl CHARSET.  Der Befehl
erwartet eine Bereichsangabe für die zu übersetzenden Zeichen als
ersten bzw. ersten/zweiten Parameter und als letzten Parameter den
Bereich, in den die Zeichen umgemappt werden sollen.  Zur Klarstel-
lung zwei Beispiele:

	CHARSET	'ä',128

bedeutet, daß das Zielsystem das ä mit der Zahl 128 kodiert.
Falls das Zielsystem keine Kleinbuchstaben unterstützt, können mit


	CHARSET 'a','z','A'

alle Kleinbuchstaben auf die passenden Großbuchstaben automatisch um-
gemappt werden.

ACHTUNG! CHARSET beeinflußt nicht nur im Speicher abgelegte String-
konstanten, sondern auch als "ASCII" formulierte Integerkonstanten.
Dies bedeutet, daß eine evtl. bereits modifizierte Umsetzungstabelle
in den obigen Beispielen zu anderen Ergebnissen führen kann!


	3.1.11.  ENUM
	- - - - - - -

--> Gültigkeit: alle Prozessoren

ENUM dient analog zu dem entsprechenden Befehl in C dazu, Aufzäh-
lungstypen zu definieren, d.h. eine Reihe von Integer-Konstanten,
denen fortlaufende Werte (von 0 an beginnend) zugewiesen werden.
Als Parameter werden dabei die Namen der zu definierenden Symbole
angegeben, wie in dem folgenden Beispiel:

	ENUM	SymA,SymB,SymC

Dieser Befehl weist den Symbolen SymA, SymB und SymC die Werte 0,
1 und 2 zu.

ENUM-Befehle sind von Hause aus einzeilig, d.h. bei einem neuen
ENUM-Befehl beginnt die Numerierung wieder bei Null.  Mehrzeilige
Aufzählungen kann man aber mit einem kleinen Trick erreichen, der
die Tatsache ausnutzt, daß man mit einer expliziten Zuweisung den
internen Zähler neu setzen kann, wie in dem folgenden Fall:

	ENUM    Januar=1,Februar,März,April,Mai,Juni

Hier werden den Monatsnamen die Zahlenwerte 1..6 zugewiesen.  Möchte
man die Aufzählung nun fortsetzen, geht das folgendermaßen:

	ENUM	Juli=Juni+1,August,September,Oktober
	ENUM	November=Oktober+1,Dezember

Die Definition von Symbolen mit ENUM gleicht einer Definition
mit EQU, d.h. es ist nicht möglich, einem Symbol einen neuen
Wert zuzuweisen.


	3.1.12.  PUSHV und POPV
        - - - - - - - - - - - -

--> Gültigkeit: alle Prozessoren

Mit PUSHV und POPV ist es möglich, den Wert von (nicht makro-
lokalen) Symbolen temporär zu speichern und zu einem späteren 
Zeitpunkt wiederherzustellen.  Die Speicherung erfolgt auf
Stacks, d.h. Last-In-First-Out-Speichern.  Ein Stack hat einen
Namen, der den allgemeinen Symbolkonventionen genügen muß, und
existiert so lange, wie er mindestens ein Element enthält: Ein
bisher nicht existierender Stack wird bei PUSHV automatisch ange-
legt, ein durch POPV leer werdender Stack wird automatisch wieder
aufgelöst.  Der Name des Stacks, auf den Symbole abgelegt und
von dem sie wieder abgeholt werden sollen, ist der erste Parameter
von PUSHV bzw. POPV, danach folgt eine beliebige Menge von Sym-
bolen als weitere Parameter.  Alle in der Liste aufgeführten
Symbole müssen bereits existieren, es ist also NICHT möglich, mit
einem POPV-Befehl implizit neue Symbole zu definieren.  

Stacks stellen eine globale Ressource dar, d.h. ihre Namen sind
nicht lokal zu Sektionen.

Wichtig ist, daß die Variablenliste IMMER von links nach rechts
abgearbeitet wird.  Wer also mehrere Variablen mit POPV von einem
Stack herunterholen will, muß diese in genau umgekehrter Reihen-
folge zum entsprechenden PUSHV angeben!

Der Name des Stacks kann auch weggelassen werden, etwa so:

        pushv   ,var1,var2,var3
        .
        .
        popv    ,var3,var2,var1

AS verwendet dann einen internen, vordefinierten Default-Stack.

Nach Ende eines Durchlaufes überprüft AS, ob noch Stacks existieren,
die nicht leer sind, und gibt deren Namen sowie "Füllstand" aus.  Mit
diesen Warnungen kann man herausfinden, ob an irgendeiner Stelle die
PUSHV's und POPV's nicht paarig sind.  Es ist jedoch in keinem Fall
möglich, Symbolwerte in einem Stack über mehrere Durchläufe hinwegzu-
retten: Zu Beginn eines Durchlaufes werden alle Stacks geleert!


	3.2. Codebeeinflussung
	----------------------


	3.2.1.  ORG
	- - - - - -

--> Gültigkeit: alle Prozessoren

ORG erlaubt es, den assemblerinternen Adreßzähler mit einem neuen
Wert zu besetzen.  Der Wertebereich ist vom momentan gewählten Seg-
ment und vom Prozessortyp abhängig.  Die untere Grenze ist dabei
immer 0; die obere Grenze der angegebene Wert minus eins:

Prozessor  CODE     DATA    IDATA   XDATA   YDATA   BITDATA IO      REG

68xx0      4G       ------  ------  ------  ------  ------  ------  ------
           Init 0

DSP56000   64K      ------  ------  64K     64K     ------  ------  ------
           Init 0                   Init 0  Init 0

PowerPC    4G       ------  ------  ------  ------  ------  ------  ------
           Init 0

6800,6301, 64K      ------  ------  ------  ------  ------  ------  ------
6811       Init 0

6805/HC08  8K       ------  ------  ------  ------  ------  ------  ------
           Init 0

6809,      64K      ------  ------  ------  ------  ------  ------  ------
6309       Init 0

68HC12     64K      ------  ------  ------  ------  ------  ------  ------
           Init 0

68HC16     1M       ------  ------  ------  ------  ------  ------  ------
           Init 0

H8/300     64K      ------  ------  ------  ------  ------  ------  ------
H8/300H    16M
           Init 0

H8/500     64K      ------  ------  ------  ------  ------  ------  ------
(Min)      Init 0

H8/500     16M      ------  ------  ------  ------  ------  ------  ------
(Max)      Init 0

SH7000/    4G       ------  ------  ------  ------  ------  ------  ------
7600       Init 0

6502,      64K      ------  ------  ------  ------  ------  ------  ------
MELPS740   Init 0

65816,     16M      ------  ------  ------  ------  ------  ------  ------
MELPS7700  Init 0

MELPS4500  8K       416     ------  ------  ------  ------  ------  ------
           Init 0   Init 0

M16        4G       ------  ------  ------  ------  ------  ------  ------
           Init 0

M16C       1M       ------  ------  ------  ------  ------  ------  ------
           Init 0

MCS-48,    4K       ------  256     256     ------  ------  ------  ------
MCS-41     Init 0           Init 0  Init 0

MCS-51     64K      256     256*)   64K     ------  0--255  ------  ------
           Init 0   Init 0  Init 80H Init 0         Init 0

MCS-251    16M      ------  ------  ------  ------  ------  512     ------
           Init 0                                           Init 0

MCS-96/196 64K      ------  ------  ------  ------  ------  ------  ------
196Nx/296  16M
           Init 0

8080,      64K      ------  ------  ------  ------  ------  256     ------
8085       Init 0                                           Init 0

80x86,     64K      64K     ------  64K     ------  ------  64K     ------
V30/35     Init 0   Init 0          Init 0                  Init 0

8X30x      8K       ------  ------  ------  ------  ------  ------  ------
           Init 0

XA         16M      16M     ------  ------  ------  ------  2K      ------
           Init 0   Init 0                                  Init 1K

AVR        8K       64K     ------  ------  ------  ------  64      ------
           Init 0   Init 0                                  Init 0

29xxx      4G       ------  ------  ------  ------  ------  ------  ------
           Init 0

80C166,    256K     ------  ------  ------  ------  ------  ------  ------
80C167     16M
           Init 0

Z80,       64K      ------  ------  ------  ------  ------  256     ------
Z180,      512K **)                                         256
Z380       4G                                               4G
           Init 0                                           Init 0

Z8         64K      256     ------  64K     ------  ------  ------  ------
           Init 0   Init 0          Init 0

TLCS-900,  16M      ------  ------  ------  ------  ------  ------  ------
900L       Init 0

TLCS-90    64K      ------  ------  ------  ------  ------  ------  ------
           Init 0

TLCS-870   64K      ------  ------  ------  ------  ------  ------  ------
           Init 0

TLCS-47    64K      1K      ------  ------  ------  ------  16      ------
           Init 0   Init 0                                  Init 0

TLCS-9000  16M      ------  ------  ------  ------  ------  ------  ------
           Init 0

PIC16C5x   2K       32      ------  ------  ------  ------  ------  ------
           Init 0   Init 0

PIC16C64,  8K       512     ------  ------  ------  ------  ------  ------
PIC16C86   Init 0   Init 0

PIC17C42   64K      256     ------  ------  ------  ------  ------  ------
           Init 0   Init 0

ST62xx     4K       256     ------  ------  ------  ------  ------  ------
           Init 0   Init 0

ST7        64K      ------  ------  ------  ------  ------  ------  ------
           Init 0                                                   

ST9        64K      64K     ------  ------  ------  ------  ------  256
           Init 0   Init 0                                          Init 0

6804       4K       256     ------  ------  ------  ------  ------  ------
           Init 0   Init 0

32010      4K       144     ------  ------  ------  ------  8       ------
32015      4K       256                                     8
           Init 0   Init 0                                  Init 0

320C2x     64K      64K     ------  ------  ------  ------  16      ------
           Init 0   Init 0                                  Init 0

320C3x     16M      ------  ------  ------  ------  ------  ------  ------
           Init 0

320C5x     64K      64K     ------  ------  ------  ------  64K     ------
           Init 0   Init 0                                  Init 0

TMS9900    64K      ------  ------  ------  ------  ------  ------  ------
           Init 0

TMS70Cxx   64K      ------  ------  ------  ------  ------  ------  ------
           Init 0

370xxx     64K      ------  ------  ------  ------  ------  ------  ------
           Init 0

MSP430     64K      ------  ------  ------  ------  ------  ------  ------
           Init 0

SC/MP      64K      ------  ------  ------  ------  ------  ------  ------
           Init 0   

COP8       8K       256     ------  ------  ------  ------  ------  ------
           Init 0   Init 0

µPD78(C)10 64K      ------  ------  ------  ------  ------  ------  ------
           Init 0

75K0       16K      4K      ------  ------  ------  ------  ------  ------
           Init 0   Init 0

78K0       64K      ------  ------  ------  ------  ------  ------  ------
           Init 0   

*) Da der 8051 kein RAM jenseits 80h hat, muß dieser Wert für den 8051
   als Zielprozessor auf jeden Fall mit ORG angepaßt werden!!
**) Da der Z180 weiterhin logisch nur 64K ansprechen kann, ist der
    ganze Adreßraum nur mittels PHASE-Anweisungen erreichbar!

Falls in einer Prozessorfamilie verschiedene Varianten unterschied-
lich große Adreßräume haben, ist jeweils der maximale Raum aufge-
führt.

ORG wird in erster Linie benötigt, um dem Code eine neue Startadres-
se zu geben und damit verschiedene, nicht zusammenhängende Codestücke
in einem Programm unterzubringen.


	3.2.2.  CPU
	- - - - - -

--> Gültigkeit: alle Prozessoren

Mit diesem Befehl wird festgelegt, für welchen Prozessor im weiteren
Code erzeugt werden soll.  Die Befehle der anderen Prozessorfamilien
sind dann nicht greifbar und erzeugen eine Fehlermeldung!

Die Prozessoren können grob in Familien unterschieden werden, in den
Familien dienen unterschiedliche Typen nocheinmal zur Feinunterschei-
dung:

a) 68008 --> 68000 --> 68010 --> 68012 --> 68332 --> 68340 -->
   68360 --> 68020 --> 68030

In dieser Familie liegen die Unterschiede in hinzukommenden Befehlen
und Adressierungsarten (ab 68020).  Eine kleine Ausnahme stellt der
68030 dar, dem 2 Befehle fehlen: CALLM und RTM.  Die drei Vertreter
der 683xx-Famile haben den gleichen Prozessorkern (eine leicht abge-
magerte 68020-CPU), jedoch völlig unterschiedliche Peripherie.

b) 56000

c) PPC403 --> MPC505 --> MPC601 --> RS6000

Der PCC403 ist eine abgespeckte Version der PowerPC-Linie ohne
Gleitkommaeinheit, demzufolge sind sämtliche Gleitkommabefehle
bei ihm gesperrt; dafür sind einige mikrocontrollerspezifische
Befehle enthalten, die er als einziges Mitglied in dieser Familie
kennt.  Der MPC505 (eine Mikrokontroller-Variante mit FPU) unter-
scheidet sich solange vom 601er nur in den Peripherieregistern,
wie ich es nicht besser weiß - [Mot505] hält sich da noch etwas
bedeckt...  Die RS6000-Reihe kennt noch einige Befehle mehr (die
auf vielen 601er-Systemen emuliert werden, um vollständige
Kompatibilität herzustellen), außerdem verwendet IBM z.T. andere
Mnemonics für diese reinen Workstation-Prozessoren, als Remineszenz
an die 370er-Großrechner...

d) 6800 --> 6301 --> 6811

Während der 6301 nur neue Befehle definiert, liefert der 6811 ne-
weiteren Befehlen ein zweites Indexregiser Y zur Adressierung.

e) 6809/6309 und 6805/68HC08

Diese Prozessoren sind zwar teilweise quellcodekompatibel zu den
anderen 68xx-ern, haben aber ein anderes Binärcodeformat und einen
deutlich eingeschränkteren (6805) bzw. erweiterten (6809) Befehls-
satz.  Der 6309 ist eine CMOS-Version des 6809, die zwar offiziell
nur kompatibel zum 6809 ist, inoffiziell aber mehr Register und
deutlich mehr Befehle besitzt (siehe [Kaku]).

f) 68HC12

g) 68HC16

h) HD6413308 --> HD6413309

Diese beiden Namen repräsentieren die 300er und 300H-Varianten der
H8-Familie; die H-Version besitzt dabei einen größeren Adreßraum
(16 Mbyte statt 64 Kbyte), doppelt so breite Register (32 Bit) und
kennt einige zusätzliche Befehle und Adressierungsarten.  Trotzdem
ist sie binär aufwärtskompatibel.

i) HD6475328 --> HD6475348 --> HD6475368 --> HD6475388

Diese Prozessoren besitzen alle den gleichen CPU-Kern; Die unter-
schiedlichen Typen dienen lediglich der Einbindung des korrekten
Registersatzes in der Datei REG53X.INC.

j) SH7000 --> SH7600

Der Prozessorkern des 7600ers bietet eine Handvoll Befehle mehr, die
Lücken im Befehlssatz des 7000ers schließen (verzögerte, bedingte
sowie relative und indirekte Sprünge, Multiplikationen mit 32-Bit-Ope-
randen sowie Multiplizier/Addier-Befehle).

k) 6502 --> 65(S)C02 / MELPS740

Die CMOS-Version definiert einige zusätzliche Befehle, außerdem sind
bei einigen Befehlen Adressierungsarten hinzugekommen, die beim 6502
nicht möglich waren.  Die Mitsubishi-Mikrokontroller dagegen erwei-
tern den 6502-Befehlssatz in erster Linie um Bitoperationen und Mul-
tiplikations-/Divisionsbefehle.  Bis auf den unbedingten Sprung und
Befehle zur Inkrementierung/Dekremetierung des Akkumulatos sind die
Erweiterungen disjunkt.  Dem 65SC02 fehlen die Bitmanipulationsbefehle
des 65C02.

l) MELPS7700, 65816

Neben einer "16-Bit-Version" des 6502-Befehlssatzes bieten diese Pro-
zessoren einige Befehlserweiterungen.  Diese sind aber größerenteils
disjunkt, da sie sich an ihren jeweiligen 8-bittigen Vorbildern (65C02
bzw. MELPS-740) orientieren.  Z.T. werden auch andere Mnemonics für
gleiche Befehle verwendet.

m) MELPS4500

n) M16

o) M16C

p) 8021, 8022, 8039, 80C39, 8048, 80C48, 8041, 8042

Bei den ROM-losen Versionen 8039 und 80C39 sind die Befehle verboten,
die den BUS (Port 0) ansprechen.  Der 8021 und 8022 sind Sonderver-
sionen mit stark abgemagertem Befehlssatz, wofür der 8022 zwei A/D-
Wandler und die dazugehörigen Steuerbefehle enthält.  Die CMOS-Ver-
sionen lassen sich mit dem IDL-Befehl in einen Ruhezustand niedriger
Stromaufnahme überführen.  Der 8041 und 8042 haben einige Zusatz-
befehle zur Steuerung der Busschnittstelle, dafür fehlen aber einige
andere Befehle.  Darüber hinaus ist bei diesen Prozessoren der Pro-
grammadreßraum nicht extern erweiterbar, weshalb AS das Codesegment
bei diesen Prozessoren auf 1 bzw. 2 Kbyte begrenzt.

q) 87C750 --> 8051, 8052, 80C320, 80C501, 80C502, 80C504, 80515 und
   80517--> 80C251

Der 87C750 kann nur max. 2 Kbyte Programmspeicher adressieren, wes-
halb die LCALL- und LJMP-Befehle bei ihm fehlen.  Zwischen den acht
mittleren Prozessoren nimmt AS selber überhaupt keine Unterscheidung
vor, sondern verwaltet den Unterschied lediglich in der Variablen
MOMCPU (s.u.), die man mit IF-Befehlen abfragen kann.  Eine Ausnahme
stellt lediglich der 80C504, der in seiner momentanen Form noch einen
Maskenfehler zeigt, wenn eine AJMP- oder ACALL-Anweisung auf der vor-
letzten Adresse einer 2K-Seite steht.  AS benutzt in einem solchen
Fall automatisch lange Sprungbefehle bzw. gibt eine Fehlermeldung aus.
Der 80C251 hingegen stellt einen drastischen Fortschritt in Richtung
16/32 Bit, größerer Adreßräume und orthogonalerem Befehlssatz dar.

r) 8096 --> 80196 --> 80196N --> 80296

Neben einem anderen Satz von SFRs (die übrigens von Unterversion zu
Unterversion stark differieren) kennt der 80196 eine Reihe von zu-
sätzlichen Befehlen und kennt einen "Windowing"-Mechanismus, um das
größere interne RAM anzusprechen.  Die 80196N-Familie wiederum erwei-
tert den Adreßraum auf 16 Mbyte und führt eine Reihe von Befehlen
ein, mit denen man auf Adressen jenseits 64 Kbyte zugreifen kann.  
Der 80296 erweitert den CPU-Kern um Befehle zur Signalverarbeitung
und ein zweites Windowing-Register, verzichtet jedoch auf den Peri-
pheral Transaction Server (PTS) und verliert damit wieder zwei Ma-
schinenbefehle.

s) 8080 und 8085

Der 8085 kennt zusätzlich die Befehle RIM und SIM zum Steuern der
Interruptmaske und der zwei I/O-Pins.

t) 8086 --> 80186 --> V30 --> V35

Hier kommen nur neue Befehle dazu.  Die entsprechenden 8-Bitter
sind wegen ihrer Befehlskompatibilität nicht aufgeführt, für ein 8088-
System ist also z.B. 8086 anzugeben.

u) 8X300 --> 8X305

Der 8X305 besitzt eine Reihe zusätzlicher Arbeitsregister, die dem
8X300 fehlen und kann mit diesen auch zusätzliche Operationen ausfüh-
ren, wie das direkte Schreiben von 8-Bit-Werten auf Peripherieadres-
sen.

v) XAG1, XAG2, XAG3

Diese Prozessoren unterscheiden sich nur in der Größe des eingebauten
ROMs, die in STDDEFXA.INC definiert ist.

w) AT90S1200 --> AT90S2313 --> AT90S4414 --> AT90S8515

Der erste Vertreter der AVR-Reihe stellt die Minimalkonfiguration dar,
ohne RAM-Speicher und demzufolge auch ohne Load/Store-Befehle.  Die
beiden anderen Prozessoren unterscheiden sich nur im Speicherausbau
und in der eingebauten Peripherie, was in REGAVR.INC differenziert
wird.

x) AM29245 --> AM29243 --> AM29240 --> AM29000

Je weiter man sich in der Liste nach rechts bewegt, desto weniger
Befehle müssen in Software emuliert werden.  Während z.B. der 29245
noch nicht einmal einen Hardware-Multiplizierer besitzt, fehlen den
beiden Vertretern in der Mitte nur die Gleitkommabefehle.  Der 29000
dient dabei als "generischer" Typ, der alle Befehle in Hardware ver-
steht.

y) 80C166 --> 80C167,80C165,80C163

80C167 und 80C165/163 haben anstelle 256 Kbyte max. 16 Mbyte
Adreßraum, außerdem kennen sie einige zusätzliche Befehle für
erweiterte Adres sierungsmodi sowie atomare Befehlssequenzen. 
Untereinander unter- scheiden sich diese Prozessoren der "zweiten
Generation" nur in der eingebauten Peripherie.

z) Z80 --> Z80UNDOC --> Z180 --> Z380

Während für den Z180 nur die zusätzlichen Befehle definiert sind
(d.h. die Z180-MMU findet noch keine Berücksichtigung), besitzt der
Z380 32-Bit-Register, einen linearen 4Gbyte-Adreßraum sowie neben
einer Reihe von Befehlserweiterungen, die den Befehlssatz deutlich
orthogonaler machen, neue Adressierungsmodi (Ansprechen der
Indexregisterhälften, Stack-relativ).  Zu einem kleinen Teil exis-
tieren diese Erweiterungen aber auch schon beim Z80 als undokumen-
tierte Befehle, die mit der Variante Z80UNDOC zugeschaltet werden
können.  Eine Liste mit den zusätzlichen Befehlen findet sich im
Kapitel mit den prozessorspezifischen Hinweisen.

aa) Z8601, Z8604, Z8608, Z8630, Z8631

Diese Prozessoren unterscheiden sich wieder nur in
Speicherausbau und Peripherie, d.h. die Wahl hat auf den
unterstützten Befehlssatz keinen Effekt.

ab) 96C141, 93C141

Diese beiden Prozessoren repräsentieren die beiden Varianten der Pro-
zessorfamilie: TLCS-900 und TLCS-900L.  Die Unterschiede dieser beiden
Varianten werden in Abschnitt 4.6 genauer beleuchtet.

ac) 90C141

ad) 87C00, 87C20, 87C40, 87C70

Die Prozessoren der TLCS-870-Reihe haben zwar den identischen CPU-
Kern, je nach Variante aber eine unteschiedliche Peripherieausstat-
tung.  Zum Teil liegen Register gleichen Namens auf unterschied-
lichen Adressen.  Die Datei STDDEF87.INC benutzt analog zur MCS-51-
Familie die hier mögliche Unterscheidung, um automatisch den korrek-
ten Symbolsatz bereitzustellen.

ae) 47C00 --> 470C00 --> 470AC00

Diese drei Varianten der TLCS-47-Familie haben unterschiedlich große
RAM-und ROM-Adreßbereiche, wodurch jeweils einige Befehle zur Bank-
umschaltung hinzukommen oder wegfallen.

af) 97C241

ag) 16C54 --> 16C55 --> 16C56 --> 16C57

Diese Prozessoren unterscheiden sich durch den verfügbaren Programm-
adreßraum, d.h. durch die Adresse, ab der der AS Überläufe anmeckert.

ah) 16C84, 16C64

Analog zur MCS-51-Familie findet hier keine Unterscheidung im
Codegenerator statt, die unterschiedlichen Nummern dienen lediglich
der Einblendung der korrekten SFRs in STDDEF18.INC.

ai) 17C42

aj) ST6210/ST6215 --> ST6220/ST6225

Die einzige Unterscheidung, die AS zwischen den beiden Paaren vor-
nimmt, ist der bei den ersten beiden kleinere Adreßraum (2K anstel-
le 4K).  Die Feinunterscheidung dient zur automatischen Unterschei-
dung in der Quelldatei, welche Hardware jeweils vorhanden ist (ana-
log zum 8051/52/515).

ak) ST7

al) ST9020, ST9030, ST9040, ST9050

Diese 4 Namen vetreten die vier "Unterfamilien" der ST9-Familie, die
sich durch eine unterschiedliche Ausstattung mit On-Chip-Peripherie
auszeichen.  Im Prozessorkern sind sie identisch, so daß diese Unter-
scheidung wieder nur im Includefile mit den Peripherieadressen zum
Zuge kommt.

am) 6804

an) 32010 --> 32015

Der TMS32010 besitzt nur 144 Byte internes RAM, weshalb AS Adressen im
Datensegment auf eben diesen Bereich begrenzt.  Für den 32015 gilt diese
Beschränkung nicht, es kann der volle Bereich von 0..255 angesprochen
werden.

ao) 320C25 --> 320C26 --> 320C28

Diese Prozessoren unterscheiden sich nur leicht in der On-Chip-Peri-
pherie sowie den Konfigurationsbefehlen.

ap) 320C30, 320C31

Der 320C31 ist eine etwas "abgespeckte" Version mit dem gleichen
Befehlssatz, jedoch weniger Peripherie.  In STDDEF3X.INC wird diese
Unterscheidung ausgenutzt.

aq) 320C50, 320C51, 320C53

Die Unterscheidung zwischen diesen Prozessoren wird von AS momentan
nicht ausgenutzt. 

ar) TMS9900

as) TMS70C00, TMS70C20, TMS70C40,
    TMS70CT20, TMS70CT40,
    TMS70C02, TMS70C42, TMS70C82,
    TMS70C08, TMS70C48

Alle Mitglieder dieser Familie haben den gleichen CPU-Kern, unter-
scheiden sich im Befehlssatz also nicht.  Die Unterschiede finden
sich nur in der Datei REG7000.INC, in der Speicherbereiche und Pe-
ripherieadressen definiert werden.  Die in einer Zeile stehenden 
Typen besitzen jeweils gleiche Peripherie und gleiche interne RAM-
Menge, unterscheiden sich also nur in der Menge eingebauten ROMs.

at) 370C010, 370C020, 370C030, 370C040 und 370C050

Analog zur MCS-51-Familie werden die unterschiedlichen Typen nur
zur Unterscheidung der Peripherie in STDDEF37.INC genutzt, der
Befehlssatz ist identisch.

au) MSP430

av) SC/MP

aw) COP87L84

Dies ist das momentan einzige unterstützte Mitglied der COP8-Familie 
von National Semiconductor.  Mir ist bekannt, daß die Familie wesent-
lich größer ist und auch Vertreter mit unterschiedlich großem Befehls-
satz existieren, die nach Bedarf hinzukommen werden.  Es ist eben ein
Anfang, und die Dokumentation von National ist ziemlich umfangreich...

ax) 7810 --> 78C10

Die NMOS-Version besitzt keinen STOP-Modus; der entspechende Befehl
sowie das ZCM-Register fehlen dementsprechend.  VORSICHT! NMOS- und
CMOS-Version differieren zum Teil in den Reset-Werten einiger Regis-
ter!

ay) 75402,
    75004, 75006, 75008,
    75268,
    75304, 75306, 75308, 75312, 75316,
    75328,
    75104, 75106, 75108, 75112, 75116,
    75206, 75208, 75212, 75216,
    75512, 75516

Dieses "Füllhorn" an Prozessoren unterscheidet sich innerhalb einer
Gruppe nur durch die RAM- und ROM-Größe; die Gruppen unter-
einander unterscheiden sich einmal durch ihre on-chip-Peripherie und
zum anderen durch die Mächtigkeit des Befehlssatzes.

az) 78070

Dies ist das einizige, mir momentan vertraute Mitglied der 78K0-Fa-
milie von NEC.  Es gelten ähnliche Aussagen wie zur COP8-Familie!

Beim CPU-Befehl muß der Prozessortyp als einfache Konstante ange-
geben werden, eine Berechnung  la

	CPU	68010+10

ist also nicht zulässig.  Gültige Aufrufe sind z.B.

	CPU 	8051

oder

	CPU	6800

Egal, welcher Prozessortyp gerade eingestellt ist, in der Integer-
variablen MOMCPU wird der momentane Status als Hexadezimalzahl ab-
gelegt.  Für den 68010 ist z.B. MOMCPU=$68010, für den 80C48
MOMCPU=80C48H.  Da man Buchstaben außer A..F nicht als Hexziffer
interpretieren kann, muß man sich diese bei der Hex-Darstellung
des Prozessors wegdenken. Für den Z80 ist z.B. MOMCPU=80H.

Dieses Feature kann man vorteilhaft einsetzen, um je nach Prozessor-
typ unterschiedlichen Code zu erzeugen.  Der 68000 z.B. kennt noch
keinen Befehl für den Unterprogrammrücksprung mit Stapelkorrektur.
Mit der Variablen MOMCPU kann man ein Makro definieren, das je nach
Prozessortyp den richtigen Befehl benutzt oder ihn emuliert:

myrtd	macro	disp
	if	MOMCPU<$68010   ; für 68008 & 68000 emulieren
	 move.l	(sp),disp(sp)
	 lea	disp(sp),sp
	 rts
	elseif
	 rtd	#disp		; ab 68010 direkt benutzen
	endif
	endm

	cpu 	68010
	myrtd	12              ; ergibt RTD #12

	cpu	68000
	myrtd	12		; ergibt MOVE.. / LEA.. / RTS

Da nicht alle Prozessornamen nur aus Ziffern und Buchstaben zwischen
A und F bestehen, wird zusätzlich der volle Name in der String-Varia-
blen MOMCPUNAME abgelegt.

Implizit schaltet der Assembler mit dem CPU-Befehl das aktuelle Seg-
ment wieder auf Code zurück, da dies das einzige Segment ist, das
alle Prozessoren definieren.

Default für den Prozessortyp ist 68008.



	3.2.3. SUPMODE, FPU, PMMU
	- - - - - - - - - - - - -

--> Gültigkeit: 680x0, FPU auch 8086..V35, SUPMODE auch TLCS-900,
                SH7000, 29K, XA und PowerPC

Mit diesen drei Schaltern kann bestimmt werden, auf
welche Teile des Befehlssatzes verzichtet werden soll, weil die
dafür nötigen Vorbedingungen im folgenden Codestück nicht gegeben
sind.  Als Parameter für diese Befehle darf entweder ON oder OFF
gegeben werden, der momentan gesetzte Zustand kann aus einer Varia-
blen ausgelesen werden, die entweder TRUE oder FALSE ist.

Die Befehle bedeuten im einzelnen folgendes:

SUPMODE: erlaubt bzw. sperrt Befehle, für deren Ausführung der Pro-
	 zessor im Supervisorstatus sein muß.  Die Statusvariable
	 heißt INSUPMODE.

FPU    : erlaubt bzw. sperrt die Befehle des numerischen Koprozes-
	 sors 8087 bzw. 68881/68882.  Die Statusvariable heißt FPUAVAIL.

PMMU   : erlaubt bzw. sperrt die Befehle der Speicherverwaltungs-
	 einheit 68851 bzw. der im 68030 eingebauten MMU.  ACHTUNG!
	 Die 68030-MMU erlaubt nur eine rel. kleine Untermenge der
	 68851-Befehle.  Der Assembler kann hier keine Prüfung
         vornehmen!  Die Statusvariable heißt PMMUAVAIL.

Benutzung von auf diese Weise gesperrten Befehlen erzeugt bei SUPMODE
eine Warnung, bei PMMU und FPU eine echte Fehlermeldung.


        3.2.4. FULLPMMU
        - - - - - - - -

--> Gültigkeit: 680x0

Motorola hat zwar ab dem 68030 die PMMU in den Prozessor integriert,
diese aber nur mit einer Funktionsuntermenge der externen PMMU 68851
ausgestattet.  AS sperrt bei aktiviertem PMMU-Befehlssatz (s.o.) des-
halb alle fehlenden Befehle, wenn als Zielprozessor 68030 oder höher
eingestellt wurde.  Nun kann es aber sein, daß in einem System mit
68030-Prozessor die interne MMU abgeschaltet wurde und der Prozessor
mit einer externen 68851 betrieben wird.  Mit FULLPMMU ON kann man 
AS dann mitteilen, daß der vollständige MMU-Befehlssatz zugelassen 
ist.  Umgekehrt kann man, wenn man portablen Code erzeugen will, alle
zusätzlichen Befehle trotz 68020-Zielplattform mit FULLPMMU OFF ab-
schalten.  Die Umschaltung darf beliebig oft erfolgen, die momentane
Einstellung kann aus einem gleichnamigen Symbol ausgelesen werden.
ACHTUNG!  Der CPU-Befehl besetzt für 680x0-Argumente implizit diese
Einstellung vor!  FULLPMMU muß also auf jeden Fall nach dem CPU-Befehl
kommen!


        3.2.5.  PADDING
	- - - - - - - -

--> Gültigkeit: 680x0, XA, H8, SH7000, MSP430, TMS9900, ST7

Prozessoren der 680x0-Familie stehen ungeraden Adressen ziemlich
kritisch gegenüber: Befehle dürfen nicht auf einer ungeraden Adresse
beginnen, und Datenzugriffe sind mit ungeraden Adressen bis zum
68010 nur byteorientiert erlaubt.  Die H8/300-Familie setzt bei Zu-
griffen auf ungerade Adressen das unterste Adreßbit einfach ganz auf
Null, die 500er "bedanken" sich wiederum mit einer Exception...
AS bemüht sich daher, mit DC oder DS aufgebaute Datenstrukturen
immer mit einer geraden Bytezahl abzulegen.  Das bedeutet bei den Be-
fehlen DS.B und DC.B aber unter Umständen, daß ein Füllbyte eingefügt
werden muß.  Dieses Verhalten kann man mit dem PADDING-Befehl ein- und
ausschalten.  Als Argument ist analog zu den vorherigen Befehlen ON
oder OFF erlaubt, und die augenblickliche Einstellung kann aus dem
gleichnamigen Symbol ausgelesen werden.


        3.2.6.  MAXMODE
	- - - - - - - -

--> Gültigkeit: TLCS-900, H8

Die Prozessoren der TLCS-900-Reihe können in 2 Betriebsarten arbei-
ten, dem Minimum-und Maximum-Modus.  Je nach momentaner Betriebsart
gelten für den Betrieb und den Assembler etwas andere Eckwerte.
Mit diesem Befehl und den Parametern ON oder OFF teilt man AS mit,
daß der folgende Code im Maximum- oder Minimum-Modus abläuft.  Die
momentane Einstellung kann aus der Variablen INMAXMODE ausgelesen
werden.  Voreinstellung ist OFF, d.h. Minimum-Modus.

Analog dazu teilt man im H8-Modus AS mit diesem Befehl mit, ob
mit einem 64K- oder 16Mbyte-Adreßraum gearbeitet wird.
Für den einfachen 300er ist diese Einstellung immer OFF und kann
nicht verändert werden.


	3.2.7.  EXTMODE und LWORDMODE
	- - - - - - - - - - - - - - -

--> Gültigkeit: Z380

Der Z380 kann in insgesamt 4 Betriebsarten arbeiten, die sich
durch die Einstellung von 2 Flags ergeben: Das XM-Flag bestimmt,
ob der Prozessor mit einem 64 Kbyte oder 4 Gbyte großen Adreßraum
arbeiten soll und kann nur gesetzt werden (nach einem Reset steht
es Z80-kompatibel auf 0).  Demgegenüber legt das LW-Flag fest, ob
Wort-Befehle mit einer Wortlänge von 16 oder 32 Bit arbeiten
sollen.  Die Stellung dieser beiden Flags beeinflußt Wertebe-
reichseinschränkungen von Konstanten oder Adressen, weshalb man
AS über diese beiden Befehle deren Stellung mitteilen muß.  Als
Default nimmt AS an, daß beide Flags auf 0 stehen, die momentane
Einstellung (ON oder OFF) kann aus den vordefinierten Variablen
INEXTMODE bzw. INLWORDMODE ausgelesen werden.


	3.2.8.  SRCMODE
        - - - - - - - -

--> Gültigkeit: MCS-251

Intel hat den Befehlssatz der 8051er beim 80C251 deutlich erweitert,
hatte aber leider nur noch einen einzigen freien Opcode für diese
Befehle frei.  Damit der Prozessor nicht auf alle Ewigkeit durch ei-
nen Präfix behindert bleibt, hat Intel zwei Betriebsarten vorgesehen:
Den Binär- und den Quellmodus.  Im Binärmodus ist der Prozessor voll
8051-kompatibel, alle erweiterten Befehle benötigen den noch freien
Opcode als Präfix.  Im Quellmodus tauschen diese neuen Befehle ihre
Position in der Code-Tabelle mit den entsprechenden 8051-Instruktio-
nen, welche dann wiederum mit einem Präfix versehen werden müssen.
Damit AS weiß, wann er Präfixe setzen muß und wann nicht, muß man
ihm mit diesem Befehl mitteilen, ob der Prozessor im Quellmodus (ON)
oder Binärmodus (OFF) betrieben wird.  Die momentane Einstellung kann
man aus der Variablen INSRCMODE auslesen.  Der Default ist OFF.


        3.2.9.  BIGENDIAN
        - - - - - - - - -

--> Gültigkeit: MCS-51/251, PowerPC

Bei den Prozessoren der 8051-Serie ist Intel seinen eigenen
Prinzipien untreu geworden: Der Prozessor verwendet entgegen
jeglicher Tradition eine Big-Endian-Orientierung von Mehrbytewerten!
Während dies bei den MCS-51-Prozessoren noch nicht großartig auffiel,
da der Prozessor ohnehin nur 8-bittig auf Speicherzellen zugreifen
konnte, man sich die Byte-Anordnung bei eigenen Datenstrukturen also
aussuchen konnte, ist dies beim MCS-251 nicht mehr so, er kann auch
ganze (Lang-)Worte aus dem Speicher lesen und erwartet dabei das MSB
zuerst.  Da dies nicht der bisherigen Arbeitsweise von AS bei der
Konstantenablage entspricht, kann man nun mit diesem Befehl umschal-
ten, ob die Befehle DB, DW, DD, DQ und DT mit Big- oder Little-Endian-
Orientierung arbeiten sollen.  Mit BIGENDIAN OFF (Voreinstellung) wird 
wie bei älteren AS-Versionen zuerst das niederwertigste Byte abgelegt, 
mit BIGENDIAN ON wird die MCS-251-kompatible Variante benutzt. Natür- 
lich kann man diese Einstellung beliebig oft im Code ändern; die mo-
mentane Einstellung kann aus dem gleichnamigen Symbol ausgelesen wer-
den.


	3.2.10. SEGMENT
	- - - - - - - -

--> Gültigkeit: alle Prozessoren

Bestimmte Mikrokontroller und Signalprozessoren kennen mehrere
Adreßbereiche, die nicht miteinander mischbar sind und jeweils auch
verschiedene Befehle zur Ansprache benötigen.  Um auch diese verwal-
ten zu können, stellt der Assembler mehrere Programmzähler zur Ver-
fügung, zwischen denen mit dem SEGMENT-Befehl hin-und hergeschaltet
werden kann.  Dies erlaubt es, sowohl in mit INCLUDE eingebundenen
Unterprogrammen als auch im Hauptprogramm benötigte Daten an der
Stelle zu definieren, an denen sie benutzt werden.  Im einzelnen
werden folgende Segmente mit folgenden Namen verwaltet:

CODE    : Programcode;
DATA    : direkt adressierbare Daten (dazu rechnen auch SFRs);
XDATA   : im extern angeschlossenen RAM liegende Daten oder
	  X-Adreßraum beim DSP56000;
YDATA   : Y-Adreßraum beim DSP56000;
IDATA   : indirekt adressierbare (interne) Daten;
BITDATA : der Teil des 8051-internen RAMs, der bitweise adressier-
	  bar ist;
IO      : I/O-Adreßbereich;
REG     : Registerbank des ST9.

Zu Adreßbereich und Initialwerten der Segmente siehe Abschnitt 3.2.1.
(ORG).  Je nach Prozessorfamilie sind auch nicht alle Segmenttypen
erlaubt.

Das Bitsegment wird so verwaltet, als ob es ein Bytesegment wäre,
d.h. die Adressen inkrementieren um 1 pro Bit.

Labels, die in einem Segment eines bestimmten Typs definiert werden,
erhalten diesen Typ als Attribut.  Damit hat der Assembler eine be-
grenzte Prüfmöglichkeit, ob mit den falschen Befehlen auf Symbole
in einem Segment zugegriffen wird.  In solchen Fällen wird der As-
sembler eine Warnung ausgeben.

Beispiel:

	CPU	8051		; MCS-51-Code

	segment	code		; Testcodestück

	setb	flag		; keine Warnung
	setb	var		; Warnung : falsches Segment

	segment	data

var	db	?

	segment	bitdata

flag	db	?



	3.2.11. PHASE und DEPHASE
	- - - - - - - - - - - - -

--> Gültigkeit: alle Prozessoren

In manchen Anwendungen (speziell Z80-Systeme) muß Code vor der
Benutzung in einen anderen Adreßbereich verschoben werden.  Da der
Assembler davon aber nichts weiß, würde er alle Labels in dem zu
verschiebenden Teil auf die Ladeadressen ausrichten.  Der Program-
mierer müßte Sprünge innerhalb dieses Bereiches entweder lageunab-
hängig kodieren oder die Verschiebung bei jedem Symbol "zu Fuß"
addieren.  Ersteres ist bei manchen Prozessoren gar nicht möglich,
letzteres sehr fehleranfällig.
Mit dem Befehlen PHASE und DEPHASE ist es möglich, dem Assembler
mitzuteilen, auf welcher Adresse der Code im Zielsystem effektiv
ablaufen wird:

	phase	<Adresse>

informiert den Assembler davon, daß der folgende Code auf der spe-
zifizierten Adresse ablaufen soll.  Der Assembler berechnet darauf-
hindie Differenz zum echten Programmzähler und addiert diese Dif-
ferenz bei folgenden Operationen dazu:

 - Adreßangabe im Listing
 - Ablage von Labelwerten
 - Programmzählerreferenzen in relativen Sprüngen und Adreßaus-
   drücken
 - Abfrage des Programmzählers mit den Symbolen * bzw. $

Diese "Verschiebung" wird mit dem Befehl

	dephase

wieder aufgehoben.

Obwohl dieses Befehlspaar vornehmlich in Codesegmenten Sinn macht,
verwaltet der Assembler für alle definerten Segmente Phasenwerte.


	3.2.12.  SAVE und RESTORE
	- - - - - - - - - - - - -

--> Gültigkeit: alle Prozessoren

Mit dem Befehl SAVE legt der Assembler den Inhalt folgender
Variablen auf einen internen Stapel:

 - momentan gewählter Prozessortyp (mit CPU gesetzt);
 - momentan aktiver Speicherbereich (mit SEGMENT gesetzt);
 - Flag, ob Listing ein- oder ausgeschaltet ist (mit LISTING
   gesetzt);
 - Flag, ob Expansionen folgender Makros im Listing ausgegeben
   werden sollen (mit MACEXP gesetzt).

Mit dem Gegenstück RESTORE wird entsprechend der zuletzt gesicherte
Zustand von diesem Stapel wieder heruntergeladen.  Diese beiden
Befehle sind in erster Linie für Includefiles definiert worden, um
in diesen Dateien die obigen Variablen beliebig verändern zu können,
ohne ihren originalen Inhalt zu verlieren.  So kann es z.B. sinnvoll
sein, in Includefiles mit eigenen, ausgetesteten Unterprogrammen die
Listingerzeugung auszuschalten:

      SAVE           ; alten Zustand retten

      LISTING  OFF   ; Papier sparen

      .              ; der eigentliche Code
      .

      RESTORE        ; wiederherstellen

Gegenüber einem einfachen LISTING OFF .. ON-Pärchen wird hier auch
dann der korrekte Zustand wieder hergestellt, wenn die Listingerzeu-
gung bereits vorher ausgeschaltet war.

Der Assembler überprüft, ob die Zahl von SAVE-und RESTORE-Befehlen
übereinstimmt und liefert in folgenden Fällen Fehlermeldungen:

 - RESTORE und der interne Stapel ist leer;
 - nach Ende eines Passes ist der Stapel nicht leer.


	3.2.13.  ASSUME
	- - - - - - - -

--> Gültigkeit: diverse

Mit diesem Befehl kann man AS den aktuellen Stand bestimmter Register
mitteilen, deren Inhalt sich nicht mit einem einfachen ON oder OFF
beschreiben läßt.  Typischerweise sind dies Register, die die
Adressierungseinheiten beeinflussen und deren Werte AS wissen muß, um
korrekte Adressierungen zu erzeugen.  Wichtig ist, daß man AS mit
ASSUME diese Werte nur mitteilt, es wird KEIN Maschinencode erzeugt,
der diese Werte in die entsprechenden Register lädt!

        6809
        ....

Im Gegensatz zu seinen "Vorgängern" wie 6800 und 6502 kann beim 6809
die Lage der direct page, d.h. des Adressbereiches, der mit ein Byte
langen Adressen erreichbar ist, frei bestimmt werden.  Dazu dient
das sog. "Direct Page Register" (DPR), das die Seitennummer festlegt.
Ihm muß man mittels ASSUME einen passenden Wert zuweisen, wenn man
einen anderen Wert als die Vorgabe von 0 in DPR schreibt, sonst
werden Adressen falscher Länge erzeugt...

        68HC16
        ......

Um mit seinen nur 16 Bit breiten Adreßoperanden einen 1 Mbyte großen 
Adreßraum ansprechen zu können, bedient sich der 68HC16 einer Reihe
von Bank-Registern, die die fehlenden oberen vier Adreßbits nachlie-
fern.  Davon ist das EK-Register für absolute Datenzugriffe (nicht
Sprünge!) zuständig.  AS überprüft bei jeder absoluten Adressierung,
ob die oberen vier Bits der Adresse mit dem über ASSUME spezifizier-
ten Wert übereinstimmen.  Differieren die Werte, gibt AS eine War-
nung aus.  Der Vorgabewert für EK ist 0.

	H8/500
        ......

Im Maximum-Modus wird der erweiterte Adreßraum dieser Prozessorreihe
durch eine Reihe von Bank-Registern adressiert.  Diese tragen die
Namen DP (Register 0..3, absolute Adressen), EP (Register 4/5) und
TP (Stack).  Den momentanen Wert von DP benötigt AS, um zu überprü-
fen, ob absolute Adressen in der momentan adressierbaren Bank liegen;
die beiden anderen Register werden nur für indirekte Adressierungen
benutzt und entziehen sich daher der Kontrolle; ob man ihre Werte
angibt oder nicht, ist daher Geschmackssache.  Wichtig ist dagegen
wieder das BR-Register, das angibt, auf welchen 256-Byte-Bereich
mit kurzen Adressen zugegriffen werden kann.  Allen Registern ist
gemeinsam, daß AS KEINE Initialwerte für sie annimmt, da sie nach
einem Prozessor-Reset undefiniert sind; wer absolut adressieren
will, muß daher auf jeden Fall DR und DP belegen!

	MELPS740
	........

Die Mikrokontroller dieser Reihe kennen für den JSR-Befehl eine
besondere Adressierungsart "special page", mit deren Hilfe man Sprünge
in die oberste Seite des internen ROMs kürzer kodieren kann.  Diese
ist natürlich vom jeweiligen Chip abhängig, und es gibt mehr Chips,
als es mit dem CPU-Befehl sinnvoll wäre, zu kodieren...also muß ASSUME
herhalten, um die Lage dieser Seite vorzugeben, z.B.

	ASSUME SP:$1f ,

falls das interne ROM 8K groß ist.

	MELPS7700/65816
        ...............

Diese Prozessoren beinhalten eine Reihe von Registern, deren Inhalt AS
kennen muß, um den korrekten Code zu erzeugen.  Es handelt sich um
folgende Register:

Name   Bedeutung            Wertebereich  Default

DT     Datenbank            0-$ff           0
PG     Code-Bank            0-$ff           0
DPR    direkt adr. Seite    0-$ffff         0
X      Indexregisterbreite  0 oder 1        0
M      Akkumulatorbreite    0 oder 1        0

Um mich nicht in endlose Wiederholungen zu ergehen, verweise ich für
die Benutzung dieser Werte auf Kapitel 4.8. .  Die Handhabung erfolgt
ansonsten genauso wie beim 8086, d.h. es können auch hier mehrere
Werte auf einmal gesetzt werden und es wird kein Code erzeugt, der
die Register mit den Werten besetzt.  Dies bleibt wieder einzig und
allein dem Programmierer überlassen!


        MCS-196/296
        ...........

Alle Prozessoren der MCS-96-Familie besitzen ab dem 80196 ein Regis-
ter WSR, mit dessen Hilfe Speicherbereiche aus dem erweiterten inter-
nen RAM oder dem SFR-Bereich in Bereiche des Registerfiles eingeblen-
det werden und so mit kurzen Adressen angesprochen werden können.
Teilt man AS mit Hilfe des ASSUME-Befehls mit, welchen Wert das WSR-
Register hat, so stellt er bei absoluten Adressen automatisch fest,
ob sie durch das Windowing mit 1-Byte-Adressen erreicht werden können;
umgekehrt werden auch für durch das Windowing überdeckte Register
automatisch lange Adressen erzeugt.  Der 80296 besitzt ein zusätzli-
ches, zweites Register WSR1, um zwei unterschiedliche Speicherberei-
che gleichzeitig in das Registerfile einblenden zu können.  Sollte
es möglich sein, eine Speicherzelle über beide Bereiche zu adressie-
ren, so wählt AS immer den Weg über WSR!


	8086
	....

Der 8086 kann Daten aus allen Segmenten in einem Befehl adressieren,
benötigt jedoch sog. "Segment-Präfixe", wenn ein anderes Segment-
register als DS verwendet werden soll.  Zusätzlich kann es sein, daß
das DS-Register auf ein anderes Segment verstellt ist, um z.B. über
längere Strecken nur Daten im Codesegment zu adressieren.  Da AS
aber keine Sinnanalyse des Codes vornimmt, muß ihm über diesen Befehl
mitgeteilt werden, auf welche Segmente die Segmentregister momentan
zeigen, z.B.

   ASSUME  CS:CODE, DS:DATA    .

Allen vier Segmenten des 8086 (SS,DS,CS,ES) können auf diese Weise
Annahmen zugewiesen werden.  Dieser Befehl erzeugt jedoch KEINEN Code,
um die Werte auch wirklich in die Segmentregister zu laden, dies muß
vom Programm getan werden.

Die Benutzung diese Befehls hat zum einen die Folge, daß AS bei spo-
radischen Zugriffen ins Codesegment automatisch Präfixe voranstellen
kann, andererseits man AS mitteilen kann, daß das DS-Register ver-
stellt wurde und man sich im folgenden explizite CS:-Anweisungen
sparen kann.

Gültige Argumente hinter dem Doppelpunkt sind CODE, DATA und NOTHING.
Letzterer Wert dient dazu, AS mitzuteilen, daß das Segmentregister
keinen für AS verwendbaren Wert enthält.
Vorinitialisiert sind folgende ASSUMEs:

  CS:CODE, DS:DATA, ES:NOTHING, SS:NOTHING

        XA
        ..

Die XA-Familie besitzt einen Datenadreßraum von 16 Mbyte, ein Prozeß
kann jedoch nur immer innerhalb einer 64K-Seite adressieren, die 
durch das DS-Register vorgegeben wird.  AS muß man den momentanen
Wert dieses Registers vorgeben, damit er Zugriffe auf absolute 
Adressen überprüfen kann.

        29K
        ...

Die Prozessoren der 29K-Familie besitzen ein Register RBP, mit dessen
Hilfe Bänke von 16 Registern vor der Benutzung im User-Modus geschützt
werden können.  Dazu kann man ein entsprechendes Bit in diesem Regis-
ter setzen.  Mit ASSUME kann man AS nun mitteilen, welchen Wert RBP
gerade hat.  Auf diese Weise kann AS warnen, falls versucht wird, im
User-Modus auf geschützte Register zuzugreifen.


	80C166/167
	..........

Obwohl keines der Register im 80C166/167 breiter als 16 Bit ist,
besitzt dieser Prozessor 18/24 Adreßleitungen, kann also bis zu 256
Kbyte/16 Mbyte adressieren.  Um diesen Widerspruch unter einen Hut
zu bekommen, verwendet er nicht die von Intel her bekannte (...und
berüchtigte) Segmentierung oder hat unflexible Bankregister...nein,
er macht Paging!  Dazu wird der "logische" Adreßraum von 64 Kbyte in
4 Seiten zu 16 Kbyte eingeteilt, und für jede Seite existiert ein
Seitenregister (bezeichnet als DPP0...DPP3), das bestimmt, welche der
physikalischen 16/1024 Seiten dort eingeblendet wird.  AS versucht
nun, den Adreßraum grundsätzlich mit 256 Kbyte/16 Mbyte aus der Sicht
des Programmierers zu verwalten, d.h. bei absoluten Zugriffen ermit-
telt AS die physikalische Seite und schaut in der mit ASSUME einge-
stellten Seitenverteilung nach, wie die Bits 14 und 15 der logischen
Adresse gesetzt werden müssen.  Paßt kein Seitenregister, so wird eine
Warnung ausgegeben.  Defaultmäßig nimmt AS an, daß die vier Register
linear die ersten 64 Kbyte abbilden, etwa in der folgenden Form:

	ASSUME	DPP0:0,DPP1:1,DPP2:2,DPP3:3

Der 80C167 kennt noch einige Befehle, die die Seitenregister in ihrer
Funktion übersteuern können.  Wie diese Befehle die Adreßgenerierung
beeinflussen, ist im Kapitel mit den prozessorspezifischen Hinweisen
beschrieben.


	TLCS-47
	.......

Der direkte Datenadreßraum dieser Prozessoren (egal ob man direkt
oder über das HL-Register adressiert) beträgt lediglich 256
Nibbles.  Da die "besseren" Familienmitglieder aber bis zu 1024
Nibbles RAM on chip haben, war Toshiba gezwungen, einen Banking-
mechanismus über das DMB-Register einzuführen.  AS verwaltet das
Datensegment als einen durchgehenden Adreßraum und prüft bei jeder
direkten Adressierung, ob die Adresse in der momentan aktiven
Bank liegt.  Die von AS momentan angenommene Bank kann mittels

   ASSUME  DMB:<0..3>

festgelegt werden.  Der Default ist 0.


	ST62xx
	......

Die Mikrokontroller der ST62-Reihe sind in der Lage, einen Teil (64
Byte) des Codebereiches in den Datenbereich einzublenden, z.B. um
Konstanten aus dem ROM zu laden.  Dies bedeutet aber auch, daß zu
einem Zeitpunkt immer nur ein Teil des ROMs adressiert werden kann.
Welcher Teil dies ist, wird durch ein bestimmtes Register bestimmt.
Dem Inhalt dieses Registers kann AS zwar nicht direkt kontrollieren,
man kann ihm aber mit diesem Befehl mitteilen, wenn man dem Register
einen neuen Wert zugewiesen hat.  AS kann dann prüfen und ggfs. war-
nen, falls auf Adressen im Codesegment zugegriffen wird, die nicht
im "angekündigten" Fenster liegt.  Hat die Variable VARI z.B. den
Wert 456h, so setzt

    ASSUME ROMBASE:VARI>>6

die AS-interne Variable auf 11h, und ein Zugriff auf VARI erzeugt
einen Zugriff auf die Adresse 56h im Datensegment.

Anstelle eines Symbols kann auch schlicht NOTHING angegeben werden,
z.B. wenn das Bank-Register temporär als Speicherzelle benutzt wird.
Dieser Wert ist auch die Voreinstellung.


        ST9
        ...

Die ST9-Familie verwendet zur Adressierung von Code- und Datenbereich
exakt die gleichen Befehle.  Welcher Adreßraum dabei jeweils ange-
sprochen wird, hängt vom Stand des DP-Flags im Flag-Register ab.  Da-
mit AS bei absoluten Zugriffen überprüfen kann, ob man mit Symbolen 
aus dem korrekten Adreßraum arbeitet (das funktioniert natürlich NUR
bei absoluten Zugriffen!), muß man ihm per ASSUME mitteilen, ob das
DP-Flag momentan auf 0 (Code) oder 1 (Daten) steht.  Der Initialwert
dieser Annahme ist 0.

	320C3x
	......

Da alle Instruktionsworte dieser Prozessorfamilie nur 32 Bit lang
sind, und von diesen 32 Bit nur 16 Bit für absolute Adressen vorge-
sehen wurden, müssen die fehlenden oberen 8 Bit aus dem DP-Register
ergänzt werden.  Bei Adressierungen kann man aber trotzdem die volle
24-Bit-Adresse angeben, AS prüft dann, ob die oberen 8 Bit mit dem
angenommenen Inhalt von DP übereinstimmen.  Gegenüber dem LDP-Befehl
weicht ASSUME darin ab, daß man hier nicht eine beliebige Adresse
aus der Speicherbank angeben kann, das Herausziehen der oberen Bits
muß man also "zu Fuß" machen, z.B. so:

	ldp	@adr
	assume	dp:adr>>16
	.
	.
	ldi	@adr,r2


	µPD78(C)10
	..........

Diese Prozessoren besitzen ein Register (V), mit dessen Hilfe die
,,Zeropage'', d.h. die Lage der mit nur einem Byte adressierbaren
Speicherzellen sich in Seitengrenzen im Speicher frei verschieben
läßt.  Da man aber aus Bequemlichkeitsgründen nicht mit Ausdrücken
wie

	inrw    Lo(Zaehler)

arbeiten will, übernimmt AS diese Arbeit, allerdings nur unter der
Voraussetzung, daß man ihm über einen ASSUME-Befehl den Inhalt
des V-Registers mitteilt.  Wird ein Befehl mit Kurzadressierung
benutzt, so wird überprüft, ob die obere Hälfte des Adreßausdrucks
mit dem angenommenen Inhalt übereinstimmt.  Stimmt sie nicht, so
erfolgt eine Warnung.


        75K0
        ....

Da selbst mit Hilfe von Doppelregistern (8 Bit) nicht der komplette
Adreßraum von 12 Bit zu erreichen ist, mußte NEC (wie andere auch...)
auf Banking zurückgreifen: Die oberen 4 Adreßbits werden aus dem
MBS-Register geholt (welchem demzufolge mit ASSUME Werte zwischen 0
und 15 zugeordnet werden können), das aber nur beachtet wird, falls
das MBE-Flag auf 1 gesetzt wurde.  Steht es (wie die Vorgabe ist)
auf 0, so kann man die obersten und untersten 128 Nibbles des
Adreßraumes ohne Bankumschaltung erreichen.  Da der 75402 weder MBE-
Flag noch MBS-Register kennt, ist für ihn der ASSUME-Befehl nicht
definiert; Die Initialwerte von MBE und MBS lassen sich daher nicht
ändern.


	3.2.14.  EMULATED
        - - - - - - - - -

--> Gültigkeit: 29k

AMD hat die Ausnahmebehandlung für undefinierte Befehle bei der
29000-Serie so definiert, daß für jeden einzelnen Befehl ein Excep-
tionvektor zur Verfügung steht.  Dies legt es nahe, durch gezielte
Software-Emulationen den Befehlssatz eines kleineren Mitgliedes
dieser Familie zu erweitern.  Damit nun aber AS diese zusätzlichen
Befehle nicht als Fehler anmeckert, erlaubt es der EMULATED-Befehl,
AS mitzuteilen, daß bestimmte Befehle doch erlaubt sind.  Die Prü-
fung, ob der momentan gesetzte Prozessor diesen Befehl beherrscht,
wird dann übergangen.  Hat man z.B. für einen Prozessor ohne
Gleitkommaeinheit ein Modul geschrieben, das aber nur mit 32-Bit-
IEEE-Zahlen umgehen kann, so schreibt man

        EMULATED FADD,FSUB,FMUL,FDIV
        EMULATED FEQ,FGE,FGT,SQRT,CLASS


	3.3. Datendefinitionen
	----------------------

Die hier beschriebenen Befehle überschneiden sich teilweise in ihrer
Funktionalität, jedoch definiert jede Prozessorfamilie andere Namen
für die gleiche Funktion.  Um mit den Standardassemblern konform zu
bleiben, wurde diese Form der Implementierung gewählt.


	3.3.1.  DC[.size]
        - - - - - - - - -

--> Gültigkeit: 680x0, H8, SH7x00, DSP56000, XA, ST7

Dieser Befehl legt eine oder mehrere Konstanten des durch das Attribut
bestimmten Typs im Speicher ab.  Die Attribute entsprechen den in
Abschnitt 2.2 definierten, zusätzlich ist für Byte-Konstanten die Mög-
lichkeit vorhanden, Stringausdrücke im Speicher abzulegen, wie
z.b.

String		dc.b	"Hello world!\0"

Die Parameterzahl darf zwischen 1 und 20 liegen, zusätzlich darf jedem
Parameter ein in eckigen Klammern eingeschlossener Wiederholungsfaktor
vorausgehen, z.B. kann man mit

		dc.b	[(*+255)&$ffffff00-*]0

den Bereich bis zur nächsten Seitengrenze mit Nullen füllen.  Vorsicht!
Mit dieser Funktion kann man sehr leicht die Grenze von 1 Kbyte erzeug-
ten Codes pro Zeile Quellcode überschreiten!

Sollte die Byte-Summe ungerade sein, so wird vom Assembler automatisch
ein weiteres Byte angefügt, um die Wortausrichtung von Daten zu erhal-
ten.  Dieses Verhalten kann mit dem PADDING-Befehl ein- und
ausgeschaltet werden.

Mit diesem Befehl abgelegte Dezimalgleitkommazahlen ( DC.P ...) können
zwar den ganzen Bereich der extended precision überstreichen, zu be-
achten ist dabei allerdings, daß die von Motorola verfügbaren Koprozes-
soren 68881/68882 beim Einlesen solcher Konstanten die Tausenderstelle
des Exponenten ignorieren!

Defaultattribut ist W, also 16-Bit-Integerzahlen.

Beim DSP56000 ist der Datentyp auf Integerzahlen festgelegt (ein
Attribut ist deshalb weder nötig noch erlaubt), die im Bereich
-8M..16M-1 liegen dürfen.   Stringkonstanten sind ebenfalls erlaubt,
wobei jeweils drei Zeichen in ein Wort gepackt werden.


	3.3.2.  DS[.size]
	- - - - - - - - -

--> Gültigkeit: 680x0, H8, SH7x00, DSP56000, XA,, ST7

Mit diesem Befehl läßt sich zum einen Speicherplatz für die angegebene
Zahl im Attribut beschriebener Zahlen reservieren.  So reserviert

	DS.B	20

z.B. 20 Bytes Speicher,

	DS.X    20

aber 240 Byte!

Die andere Bedeutung ist die Ausrichtung des Programmzählers, die
mit der Wertangabe 0 erreicht wird.  So wird mit

	DS.W	0

der Programmzähler auf die nächste gerade Adresse aufgerundet, mit

	DS.D	0

dagegen auf die nächste Langwortgrenze.  Eventuell dabei freiblei-
bende Speicherzellen sind nicht etwa mit Nullen oder NOPs gefüllt,
sondern undefiniert.

Vorgabe für die Operandengröße ist - wie üblich - W, also 16 Bit.

Beim 56000 ist die Operandengröße auf Worte (a 24 Bit) festgelegt,
Attribute gibt es deswegen wie bei DC auch hier nicht.


	3.3.3. DB,DW,DD,DQ und DT
	- - - - - - - - - - - - -

--> Gültigkeit: Intel, Zilog, Toshiba, NEC, TMS370, Siemens, AMD,
                MELPS7700/65816, M16(C), National, ST9, TMS70Cxx

Diese Befehle stellen sozusagen das Intel-Gegenstück zu DS und DC
dar, und wie nicht anders zu erwarten ist die Logik etwas anders:
Zum einen wird die Kennung der Operandengröße in das Mnemonic ver-
legt:

 DB: Byte oder ASCII-String wie bei DC.B
 DW: 16-Bit-Integer
 DD: 32-Bit-Integer oder single precision
 DQ: double precision   ( 64 Bit )
 DT: extended precision ( 80 Bit )

Zum anderen erfolgt die Unterscheidung, ob Konstantendefinition oder
Speicherreservierung, im Operanden.  Eine Reservierung von Speicher
wird durch ein ? gekennzeichnet:

	db	?	; reserviert ein Byte
        dw	?,?	; reserviert Speicher für 2 Wörter (=4 Byte)
        dd	-1	; legt die Konstante -1 (FFFFFFFFH) ab !

Speicherreservierung und Konstantendefinition dürfen NICHT IN EINER
Anweisung gemischt werden:

	db	"Hallo",?	; --> Fehlermeldung

Zusätzlich ist noch der DUP-Operator erlaubt, der die mehrfache Abla-
ge von Konstantenfolgen oder die Reservierung ganzer Speicherblök-
ke erlaubt:

	db	3 dup (1,2)	; --> 1 2 1 2 1 2
	dw	20 dup (?)	; reserviert 40 Byte Speicher.

Wie man sehen kann, muß das DUP-Argument geklammert werden, darf da-
für aber auch wieder aus mehreren Teilen bestehen, die selber auch
wieder DUPs sein können...das ganze funktioniert also rekursiv.
DUP ist aber auch eine Stelle, an der man mit einer anderen Grenze des
Assemblers in Berührung kommen kann: maximal können 1024 Byte Code
oder Daten in einer Zeile erzeugt werden.  Dies bezieht sich NICHT
auf die Reservierung von Speicher, nur auf die Definition von Kon-
stantenfeldern!

Um mit dem M80 verträglich zu sein, darf im Z80-Modus anstelle von
DB / DW auch DEFB / DEFW geschrieben werden.

Analog stellen BYTE/ADDR bzw. WORD/ADDRW beim COP8 einen Alias für 
DB bzw. DW dar, wobei die beiden Paare sich jedoch in der Byte-Order 
unterscheiden: Die Befehle, die von National zur Adreßablage vorge-
sehen waren, benutzen Big-Endian, BYTE bzw. WORD jedoch Little-Endian.


	3.3.4. DS
        - - - - -

--> Gültigkeit: Intel, Zilog, Toshiba, NEC, TMS370, Siemens, AMD,
                M16(C), National, ST9, TMS7000

Dieser Befehl stellt eine Kurzschreibweise dar, um Speicherbereiche
zu reservieren:

        DS       <Anzahl>

ist eine Kurzschreibweise für

        DB       <Anzahl> DUP (?)

dar, ließe sich also prinzipiell auch einfach über ein Makro reali-
sieren, nur scheint dieser Befehl in den Köpfen einiger mit Motoro-
la-CPUs groß gewordener Leute (gell, Michael?) so fest verdrahtet
zu sein, daß sie ihn als eingebauten Befehl erwarten...hoffentlich
sind selbige jetzt zufrieden ;-)


	3.3.5. BYT oder FCB
        - - - - - - - - - - 

--> Gültigkeit: 6502, 68xx

Mit diesem Befehl werden im 65xx/68xx-Modus Byte-Konstanten oder
ASCII-Strings abgelegt, er entspricht also DC.B beim 68000 oder
DB bei Intel.


	3.3.6. BYTE
	- - - - - -

--> Gültigkeit: ST62xx, 320C2x, 320C5x, MSP, TMS9900

Dito.  Ein im 320C2x/5x-Modus vor dem Befehl stehendes Label wird
als untypisiert gespeichert, d.h. keinem Adreßraum zugeordnet.
Der Sinn dieses Verhaltens wird bei den prozessorspezifischen
Hinweisen erläutert.
Ob beim MSP bzw. TMS9900 ungerade Mengen von Bytes automatisch um 
ein Null-Byte ergänzt werden sollen, kann mit dem PADDING-Befehl ein-
gestellt werden.


	3.3.7. ADR oder FDB
	- - - - - - - - - - 

--> Gültigkeit: 6502, 68xx

Mit diesem Befehl werden im 65xx/68xx-Modus Wortkonstanten abge-
legt, er entspricht also DC.W beim 68000 oder DW bei Intel.


	3.3.8. WORD
	- - - - - -

--> Gültigkeit: ST62xx, 320C2x, 320C3x, 320C5x, MSP

Für den 320C3x werden hiermit 32-Bit-Worte abgelegt, für die
beiden anderen Familien 16-Bit-Worte.  Ein im 320C2x/5x-Modus vor
dem Befehl stehendes Label wird als untypisiert gespeichert, d.h.
keinem Adreßraum zugeordnet.  Der Sinn dieses Verhaltens wird bei
den prozessorspezifischen Hinweisen erläutert.


	3.3.9. LONG
	- - - - - -

--> Gültigkeit: 320C2x, 320C5x

Hiermit werden 32-Bit-Integer im Speicher abgelegt, und zwar in
der Reihenfolge LoWord-HiWord.  Ein eventuell vor dem Befehl
stehendes Label wird dabei wieder als untypisiert abgelegt
(der Sinn dieser Maßnahme ist in den prozessorspezifischen
Hinweisen erläutert).


	3.3.10. SINGLE und EXTENDED
	- - - - - - - - - - - - - -

--> Gültigkeit: 320C3x

Mit diesen Befehlen werden Gleitkomma-Konstanten im Speicher
abgelegt, jedoch nicht im IEEE-Format, sondern in den vom Prozessor
verwendeten 32- und 40-Bit-Formaten.  Da 40 Bit nicht mehr in eine
Speicherzelle hineinpassen, werden im Falle von EXTENDED immer derer
2 pro Wert belegt.  Im ersten Wort finden sich die oberen 8 Bit (der
Exponent), der Rest (Vorzeichen und Mantisse) in zweiten Wort.


	3.3.11.  FLOAT und DOUBLE
	- - - - - - - - - - - - -

--> Gültigkeit: 320C2x, 320C5x

Mit diesen Befehlen können 32- bzw. 64-Bit-Gleitkommazahlen
im IEEE-Format im Speicher abgelegt werden.  Dabei wird das
niederwertigste Byte jeweils auf der ersten Speicherstelle
abgelegt.  Ein eventuell vor dem Befehl stehendes Label wird
wieder als untypisiert gespeichert (der Sinn dieser Maßnahme
ist in den prozessorspezifischen Hinweisen erläutert).


	3.3.12. EFLOAT, BFLOAT und TFLOAT
	- - - - - - - - - - - - - - - - -

--> Gültigkeit: 320C2x, 320C5x

Auch diese Befehle legen Gleitkommazahlen im Speicher ab,
jedoch in einem nicht-IEEE-Format, das evtl. leichter von
Signalprozessoren zu verarbeiten ist:

EFLOAT: Mantisse mit 16 Bit, Exponent mit 16 Bit
BFLOAT: Mantisse mit 32 Bit, Exponent mit 16 Bit
DFLOAT: Mantisse mit 64 Bit, Exponent mit 32 Bit

Gemeinsam ist den Befehlen, daß die Mantisse vor dem
Exponenten abgelegt wird (Lo-Word jeweils zuerst) und
beide im Zweierkomplement dargestellt werden.  Ein eventuell
vor dem Befehl stehendes Label wird wieder als untypisiert
gespeichert (der Sinn dieser Maßnahme ist in den prozessor-
spezifischen Hinweisen erläutert).


	3.3.13.  Qxx und LQxx
	- - - - - - - - - - -

--> Gültigkeit: 320C2x, 320C5x

Mit diesen Befehlen können Gleitkommazahlen in einem
Festkommaformat abgelegt werden.  xx ist dabei eine zwei-
stellige Zahl, mit deren Zweierpotenz der Gleitkommawert vor
der Umwandlung in eine ganze Zahl multipliziert werden soll.
Er bestimmt also praktisch, wieviele Bits für die Nachkomma-
stellen reserviert werden sollen.  Während aber Qxx nur ein
Wort (16 Bit) ablegt, wird das Ergebnis bei LQxx in 2
Worten (loWord zuerst) abgelegt.  Das sieht dann z.B. so
aus:

     q05   2.5       	; --> 0050h
     lq20  ConstPI	; --> 43F7h 0032h

Mich möge niemand steinigen, wenn ich mich auf meinem HP28
verrechnet haben sollte...


	3.3.14.  DATA
	- - - - - - -

--> Gültigkeit: PIC, 320xx, AVR, MELPS-4500

Mit diesem Befehl werden Daten im aktuellen Segment abgelegt, wobei
sowohl Integer- als auch Stringwerte zulässig sind.  Bei Strings be-
legt beim 16C5x/16C8x, 17C4x im Datensegment und 4500er ein Zeichen
ein Wort, bei AVR, 17C4x im Codesegment und 3201x/3202x passen zwei
Zeichen in ein Wort (LSB zuerst belegt), beim 320C3x sogar derer 4
(MSB zuerst).  Im Gegensatz dazu muß im Datensegment des 4500ers ein
Zeichen auf zwei Speicherstellen verteilt werden.  Der Wertebereich
für Integers entspricht der Wortbreite des jeweiligen Prozessors im
jeweiligen Segment.  Das bedeutet, daß DATA beim 320C3x die Funktion
von WORD mit einschließt (die von SINGLE übrigens auch, wenn AS das
Argument als Gleitkommazahl erkennt).


	3.3.15.  ZERO
	- - - - - - -

--> Gültigkeit: PIC

Dieser Befehl legt einen durch den Parameter spezifizierte Zahl von
Nullworten (=NOPs) im Speicher ab. Es können maximal 512 Nullen mit
einem Befehl abgelegt werden.


        3.3.16. FB und FW
        - - - - - - - - -

--> Gültigkeit: COP8

Mit diesen Befehlen kann ein größerer Block von Speicher (dessen
Länge in Bytes bzw. Worten der erste Parameter angibt) mit einer
Byte-bzw. Wortkonstanten gefüllt werden, die durch den zweiten
Parameter angegeben wird.  Die Maximalgröße des Blocks beträgt 1024
Elemente für FB bzw. 512 Elemente für FW.


	3.3.17. ASCII und ASCIZ
	- - - - - - - - - - - -

--> Gültigkeit: ST62xx

Mit diesen beiden Befehlen können Stringkonstanten im Speicher ab-
gelegt werden.  Während ASCII nur die reinen Daten im Speicher ab-
legt, versieht ASCIZ automatisch JEDEN angegebenen String mit einem
NUL-Zeichen am Ende.


	3.3.18.  STRING und RSTRING
	- - - - - - - - - - - - - -

--> Gültigkeit: 320C2x, 320C5x

Diese Befehle funktionieren analog zu DATA, jedoch werden hier
Integer-Ausdrücke grundsätzlich als Bytes mit einem entsprechend
eingeschränkten Wertebereich betrachtet, wodurch es möglich wird,
die Zahlen zusammen mit anderen Zahlen oder Zeichen paarweise in
Worte zu verpacken.
Die beiden Befehle unterscheiden sich lediglich in der Reihenfol-
ge der Bytes in einem Wort: Bei STRING wird zuerst das obere und
danach das untere gefüllt, bei RSTRING ist es genau umgekehrt.

Ein eventuell vor dem Befehl stehendes Label wird wieder als
untypisiert gespeichert.  Der Sinn dieser Maßnahme ist im
entsprechenden Kapitel mit den prozessorspezifischen Befehlen
erläutert.


        3.3.19. FCC
        - - - - - -

--> Gültigkeit: 6502, 68xx

Mit diesem Befehl werden im 65xx/68xx-Modus String-Konstanten 
abgelegt.  Beachten Sie jedoch, daß im Gegensatz zum Original-
assembler AS11 von Motorola (dessentwegen dieser Befehl existiert, 
bei AS ist diese Funktion im BYT-Befehl enthalten), String-Argu-
mente nur in Gänsefüßchen und nicht in Hochkommas oder Schräg-
strichen eingeschlossen werden dürfen!


	3.3.20.  DFS oder RMB
	- - - - - - - - - - -

--> Gültigkeit: 6502, 68xx

Dieser Befehl dient im 65xx/68xx-Modus zur Reservierung von Spei-
cher, er entspricht DS.B beim 68000 oder DB ? bei Intel.


	3.3.21. BLOCK
	- - - - - - -

--> Gültigkeit: ST62xx

Dito.


	3.3.22. RES
	- - - - - -

--> Gültigkeit: PIC, MELPS-4500, 3201x, 320C2x, 320C5x, AVR

Dieser Befehl dient zur Reservierung von Speicher.  Er reserviert
im Codesegment immer Wörter (10/12/14/16 Bit), im Datensegment bei
den PICs Bytes, beim 4500er Nibbles sowie bei Texas ebenfalls Wörter.


	3.3.23. BSS
	- - - - - -

--> Gültigkeit: 320C2x, 320C3x, 320C5x, MSP

BSS arbeitet analog zu RES, lediglich ein eventuell vor dem
Befehl stehendes Symbol wird beim 320C2x/5x als untypisiert ge-
speichert.  Der Sinn dieser Maßnahme kann im Kapitel mit den 
prozessorspezifischen Hinweisen nachgelesen werden.


        3.3.24. DSB und DSW
        - - - - - - - - - -

--> Gültigkeit: COP8

Diese beiden Befehle stellen im COP8-Modus die zum ASMCOP von 
National kompatible Methode dar, Speicher zu reservieren.  
Während DSB nur einzelne Bytes freihält, reserviert DSW Wörter 
und damit effektiv doppelt soviel Bytes wie DSB.


	3.3.25. ALIGN
	- - - - - - -

--> Gültigkeit: alle Prozessoren

ALIGN mit einem dahinterstehenden Integerausdruck erlaubt es, den
Programmzähler auf eine bestimmte Adresse auszurichten.  Die Aus-
richtung erfolgt dergestalt, daß der Programmzähler so weit er-
höht wird, daß er ein ganzzahliges mehrfaches des Argumentes
wird.  In seiner Funktion entspricht ALIGN also DS.x 0 beim den
680x0ern, nur ist die Ausrichtung noch flexibler.

Beispiel:

	align 2

macht den Programmzähler gerade.  Wie auch bei DS.x 0 ist der
freibleibende Speicherraum undefiniert.


	3.3.26. LTORG
	- - - - - - -

--> Gültigkeit: SH7000

Da der SH7000-Prozessor seine Register immediate nur mit 8-Bit-
Werten laden kann, AS dem Programmierer jedoch vorgaukelt, daß
es eine solche Einschränkung nicht gäbe, muß er die dabei ent-
stehenden Konstanten irgendwo im Speicher ablegen.  Da es nicht
sinnvoll wäre, dies einzeln zu tun (wobei jedes Mal Sprungbe-
fehle anfallen würden...), werden die Literale gesammelt und
können vom Programmierer mit diesem Befehl gezielt blockweise
(z.B. am Ende eines Unterprogrammes) abgelegt werden.  Zu den
zu beachtenden Details und Fallen sei auf das Kapitel mit den
SH7000-spezifischen Dingen hingewiesen.


	3.4. Makrobefehle
	-----------------

--> Gültigkeit: alle Prozessoren

Kommen wir nun zu dem, was einen Makroassembler vom normalen As-
sembler unterscheidet: der Möglichkeit, Makros zu definieren (ach
was ?!).

Unter Makros verstehe ich hier erst einmal einen Block von Anwei-
sungen (normal oder Pseudo), die mit bestimmten Befehlen zu einem
Block zusammengefaßt werden und dann auf bestimmte Weise bearbei-
tet werden können.  Zur Bearbeitung solcher Blöcke kennt der As-
sembler folgende Befehle:

	3.4.1.  MACRO
        - - - - - - -

ist der wohl wichtigste Befehl zur Makroprogrammierung.  Mit der
Befehlsfolge

<Name>	MACRO	[Parameterliste]
	<Befehle>
	ENDM

wird das Makro <Name> als die eingeschlossene Befehlsfolge defi-
niert.  Diese Definition alleine erzeugt noch keinen Code!  Dafür
kann fortan die Befehlsfolge einfach durch den Namen abgerufen
werden, das Ganze stellt also eine Schreiberleichterung dar.  Um
die ganze Sache etwas nützlicher zu machen, kann man bei der Ma-
krodefinition eine Parameterliste mitgeben.  Die Parameternamen
werden wie üblich durch Kommas getrennt und müssen - wie der Makro-
name selber - den Konventionen für Symbolnamen (2.6.) genügen.

Sowohl Makronamen als auch -parameter sind von einer Umschaltung
von AS in den case-sensitiven Modus betroffen.

Makros sind ähnlich wie Symbole lokal, d.h. bei Definition in
einer Sektion sind sie nur in dieser Sektion und ihren Unter-
sektionen bekannt.  Dieses Verhalten läßt sich aber durch die
weiter unten beschriebenen Optionen PUBLIC und GLOBAL in weiten
Grenzen steuern.

Neben den eigentlichen Makroparametern können in der Parameterliste
auch Steuerparameter enthalten sein, die die Abarbeitung des be-
troffenen Makros beeinflussen; diese Parameter werden von normalen
Parametern dadurch unterschieden, daß sie in geschweifte Klammern
eingeschlossen sind.  Es sind folgende Steuerparameter definiert:

- EXPAND / NOEXPAND : legen fest, ob bei der späteren Verwendung
  diese Makros der expandierte Code mit angezeigt werden soll.
  Default ist der durch den Pseudobefehl MACEXP festgelegte Wert.

- PUBLIC[:Sektionsname] : ordnet das Makro nicht der aktuellen,
  sondern einer ihr übergeordneten Sektion zu.  Auf diese Weise
  kann eine Sektion Makros für die "Außenwelt" zur Verfügung
  stellen.  Fehlt eine Sektionsangabe, so wird das Makro völlig
  global, d.h. ist überall benutzbar.

- GLOBAL[:Sektionsname] : legt fest, daß neben diesem Makro noch ein
  weiteres Makro abgelegt werden soll, das zwar den gleichen Inhalt
  hat, dessen Name aber zusätzlich mit dem Namen der Sektion ver-
  sehen ist, in der es definiert wurde und das der spezifizierten
  Sektion zugeordnet werden soll.  Bei dieser muß es sich um eine
  Obersektion zu der aktuellen Sektion handeln; fehlt die Angabe,
  so wird das zusätzliche Makro global sichtbar.  Wird z.B. ein
  Makro A in der Sektion B definiert, die wiederum eine Untersektion
  der Sektion C ist, so würde neben z.B. dem Makro A ein weiteres
  globales mit dem Namen C_B_A erzeugt.  Würde dagegen C als Ziel-
  sektion angegeben, so würde das Makro B_A heißen und der Sektion
  C zugeordnet.  Diese Option ist defaultmäßig ausgeschaltet und hat
  auch nur einen Effekt, falls sie innerhalb einer Sektion benutzt
  wird.  Das lokal bekannte Originalmakro wird von ihr nicht beein-
  flußt.

- EXPORT / NOEXPORT : legen fest, ob die Definition dieses Makros
  in einer getrennten Datei abgelegt werden soll, falls die
  Kommandozeilenoption -M gegeben wurde.  Auf diese Weise können
  einzelne Definitionen "privater" Makros selektiv ausgeblendet
  werden.  Der Default ist FALSE, d.h. die Definition wird nicht in
  der Datei abgelegt.  Ist zusätzlich die GLOBAL-Option gegeben
  worden, so wird das Makro mit dem modifizierten Namen abgelegt.

Diese eben beschriebenen Steuerparameter werden von AS aus der
Parameterliste ausgefiltert, haben also keine weitere Wirkung in
der folgenden Verarbeitung und Benutzung.

Beim Aufruf eines Makros werden die beim Aufruf angegebenen Para-
meternamen überall textuell im Befehlsblock eingesetzt und der
sich so ergebene Assemblercode wird normal assembliert.  Sollten
beim Aufruf zu wenige Parameter angegeben werden, werden Null-
strings eingefügt.  Wichtig ist zu wissen, daß bei der Makroex-
pansion keine Rücksicht auf eventuell in der Zeile enthaltene
Stringkonstanten genommen wird.  Zu diesem Detail gilt die alte
IBM-Regel:

 It's not a bug, it's a feature!

Diese Lücke kann man bewußt ausnutzen, um Parameter mittels String-
vergleichen abzuprüfen.  So kann man auf folgende Weise z.B. prüfen,
wie eine Makroparameter aussieht:

mul     MACRO   para,parb
	IF      UpString("PARA")<>"A"
         MOV    a,para
	ENDIF
        IF      UpString("PARB")<>"B"
         MOV    b,parb
        ENDIF
	mul     ab
	ENDM

Wichtig ist bei obigem Beispiel, daß der Assembler alle Parameter-
namen im case-insensitiven Modus in Großbuchstaben umsetzt,
in Strings aber nie eine Umwandlung in Großbuchstaben erfolgt.
Die Makroparameternamen müssen in den Stringkonstanten daher groß
geschrieben werden.

Für die Makroparameter gelten die gleichen Konventionen wie bei
normalen Symbolen, mit der Ausnahme, daß hier nur Buchstaben und
Ziffern zugelassen sind, also weder Punkte noch Unterstriche.
Diese Einschränkung hat ihren Grund in einem verstecktem Feature:
Der Unterstrich erlaubt es, einzelne Makroparameternamen zu einem
Symbol zusammenzuketten, z.B. in folgendem Beispiel:

concat	macro	part1,part2
	call	part1_part2
        endm

Der Aufruf

	concat	Modul,Funktion

ergibt also

	call	Modul_Funktion

Um alle Klarheiten auszuräumen, ein einfaches Beispiel:

Ein Intelverblödeter Programmierer möchte die Befehle PUSH/POP
unbedingt auch auf dem 68000 haben.  Er löst das Problem folgen-
dermaßen:

push	macro	op
	move    op,-(sp)
	endm

pop	macro	op
	move	(sp)+,op
	endm

Schreibt man nun im Code

	push	d0
	pop	a2     ,

so wird daraus

	move.w	d0,-(sp)
	move.w	(sp)+,a2

Eine Makrodefinition darf nicht über Includefilegrenzen hinausgehen.

In Makrorümpfen definierte Labels werden immer als lokal betrachtet,
ein expliziter LOCAL-Befehl ist also nicht erforderlich ( und ist
auch nicht definiert ).  Ist es aus irgendwelchen Gründen erforder-
lich, so kann man es mit LABEL definieren, dessen Anwendung (wie bei
BIT, SFR...) immer globale Symbole ergibt :

<Name>	label	$

Da der Assembler beim Parsing einer Zeile zuerst die Makroliste und
danach die Prozessorbefehle abklappert, lassen sich auch Prozessor-
befehle neu definieren.  Die Definition sollte dann aber vor der er-
sten Benutzung des Befehles durchgeführt werden, um Phasenfehler wie
im folgenden Beispiel zu vermeiden:

	bsr	ziel

bsr	macro	target
	jsr	ziel
	endm

	bsr	ziel

Im ersten Pass ist bei der Assemblierung des BSR-Befehles das Makro
noch nicht bekannt, es wird ein 4 Byte langer Befehl erzeugt.  Im
zweiten Pass jedoch steht die Makrodefinition sofort (aus dem er-
sten Pass) zur Verfügung, es wird also ein 6 Byte langer JSR kodiert.
Infolgedessen sind alle darauffolgenden Labels um zwei zu niedrig,
bei allen weitern Labels sind Phasenfehler die Folge, und ein weiterer
Pass ist erforderlich.

Da durch die Definition eines Makros ein gleichnamiger Maschinen- oder
Pseudobefehl nicht mehr zugreifbar ist, gibt es eine Hintertür, die
Originalbedeutung zu erreichen: Stellt man dem Mnemonic ein ! voran,
so wird das Durchsuchen der Makroliste unterdrückt.  Das kann bei-
spielsweise nützlich sein, um Befehle in ihrer Mächtigkeit zu erwei-
tern, z.B. die Schiebebefehle beim TLCS-90:

srl	macro	op,n		; Schieben um n Stellen
	rept	n		; n einfache Befehle
	 !srl	op
	endm
	endm

Fortan hat der SRL-Befehl einen weiteren Parameter...


	3.4.2.  IRP
	- - - - - -

ist die eine vereinfachte Form von Makrodefinitionen für den Fall,
daß eine Befehlsfolge einmal auf mehrere Operanden angewendet werden
soll und danach nicht mehr gebraucht wird.  IRP benötigt als ersten
Parameter ein Symbol für den Operanden, und danach eine (fast) be-
liebige Menge von Parametern, die nacheinander in den Befehlsblock
eingesetzt werden.  Um eine Menge von Registern auf den Stack zu
schieben, kann man z.B. schreiben

	irp	op, acc,b,dpl,dph
	push	op
	endm

was in folgendem resultiert:

	push	acc
        push	b
        push	dpl
        push	dph

Benutzte Labels sind wieder für jeden Durchgang automatisch lokal.


	3.4.3. REPT
        - - - - - -

ist die einfachste Form der Makrobenutzung.  Der im Rumpf angegebene
Code wird einfach sooft assembliert, wie der Integerparameter von
REPT angibt.  Dieser Befehl wird häufig in kleinen Schleifen anstelle
einer programmierten Schleife verwendet, um den Schleifenoverhead zu
sparen.

Der Vollständigkeit halber ein Beispiel:

	rept	3
        rr	a
        endm

rotiert den Akku um 3 Stellen nach rechts.

Symbole sind wiederum für jede einzelne Repetition lokal.

Ist das Argument von REPT kleiner oder gleich Null, so wird überhaupt
keine Expansion durchgeführt.  Dies ist ein Unterschied zu früheren
Versionen von AS, die hier etwas "schlampig" waren und immer mindes-
tens eine Expansion ausführten.


	3.4.4.  WHILE
	- - - - - - -

WHILE arbeitet analog zu REPT, allerdings tritt an die Stelle einer
festen Anzahl als Argument ein boolescher Ausdruck, und der zwischen
WHILE und ENDM eingeschlossene Code wird sooft assenbliert, bis der
Ausdruck logisch falsch wird.  Im Extremfall kann dies bedeuten, daß
der Code überhaupt nicht assembliert wird, falls die Bedingung bereits
beim Eintritt in das Konstrukt falsch ist.  Andererseits kann es na-
türlich auch passieren, daß die Bedingung immer wahr bleibt, und AS
läuft bis an das Ende aller Tage...hier sollte man also etwas Umsicht
walten lassen, d.h. im Rumpf muß eine Anweisung stehen, die die Be-
dingung auch beeinflußt, z.B. so:

cnt     set     1
sq      set     cnt*cnt
        while   sq<=1000
	 dc.l    sq
cnt      set     cnt+1
sq       set     cnt*cnt
        endm

Dieses Beispiel legt alle Quadratzahlen bis 1000 im Speicher ab.

Ein unschönes Detail bei WHILE ist im Augenblick leider noch, daß
am Ende der Expansion eine zusätzliche Leerzeile, die im Quellrumpf
nicht vorhanden war, eingefügt wird.  Dies ist ein "Dreckeffekt", der
auf einer Schwäche des Makroprozessors beruht und leider nicht so
einfach zu beheben ist.  Hoffentlich stört es nicht allzusehr....


	3.4.5.  EXITM
        - - - - - - -

EXITM stellt einen Weg dar, um eine Makroexpansion oder einen der
Befehle REPT, IRP oder WHILE vorzeitig abzubrechen.  Eine solche
Möglichkeit hilft zum Beispiel, umfangreichere Klammerungen mit
IF-ENDIF-Sequenzen in Makros übersichtlicher zu gestalten.  Sinn-
vollerweise ist ein EXITM aber selber auch immer bedingt, was zu
einem wichtigen Detail führt: Der Stack, der über momentan offene
IF- oder SWITCH-Konstrukte Buch führt, wird auf den Stand vor
Beginn der Makroexpansion zurückgesetzt.  Dies ist für bedingte
EXITM's zwingend notwendig, da das den EXITM-Befehl in irgendeiner
Form einschließende ENDIF oder ENDCASE nicht mehr erreicht wird
und AS ohne einen solchen Trick eine Fehlermeldung erzeugen 
würde.  Weiterhin ist es für verschachtelte Makrokonstruktionen 
wichtig, zu beachten, daß EXITM immer nur das momentan innerste
Konstrukt abbricht!  Wer aus seiner geschachtelten Konstruktion
vollständig "ausbrechen" will, muß auf den höheren Ebenen eben-
falls EXITM's vorsehen!


	3.4.6. FUNCTION
	- - - - - - - -

FUNCTION ist zwar kein Makrobefehl im engeren Sinne, da hierbei aber
ähnliche Mechanismen wie bei Makroersetzungen angewendet werden,
soll er hier beschrieben werden.
Dieser Befehl dient dazu, neue Funktionen zu definieren, die in For-
melausdrücken wie die vordefinierten Funktionen verwendet werden
können.  Die Definition muß in folgender Form erfolgen:

<Name>  FUNCTION <Arg>,..,<Arg>,<Ausdruck>

Die Argumente sind die Werte, die sozusagen in die Funktion "hineinge-
steckt" werden.  In der Definition werden für die Argumente symboli-
sche Namen gebraucht, damit der Assembler bei der Benutzung der Funk-
tion weiß, an welchen Stellen die aktuellen Werte einzusetzen ist.
Dies kann man an folgendem Beispiel sehen:

isdigit FUNCTION ch,(ch>='0')&&(ch<='9')

Diese Funktion überprüft, ob es sich bei dem Argument (wenn man es
als Zeichen interpretiert) um eine Ziffer im momentan gültigen Zei-
chencode handelt (der momentane Zeichencode ist mittels CHARSET ver-
änderbar, daher die vorsichtige Formulierung).

Die Argumentnamen (in diesem Falle CH) muß den gleichen härteren
Symbolkonventionen genügen wie Parameter bei einer Makrodefinition,
d.h. die Sonderzeichen . und _ sind nicht erlaubt.

Selbstdefinierte Funktionen werden genauso benutzt wie eingebaute,
d.h. mit einer durch Kommas getrennten, geklammerten Argumentliste:

        IF isdigit(Zeichen)
         message "\{Zeichen} ist eine Ziffer"
        ELSEIF
         message "\{Zeichen} ist keine Ziffer"
	ENDIF

Bei dem Aufruf der Funktion werden die Argumente nur einmal berechnet
und danach an allen Stellen der Formel eingesetzt, um den Rechenauf-
wand zu reduzieren und Seiteneffekte zu vermeiden.  Bei Funktionen
mit mehreren Argumenten müssen die einzelnen Argumente durch Kommata
getrennt werden.

ACHTUNG! Analog wie bei Makros kann man mit der Definition von Funk-
tionen bestehende Funktionen umdefinieren.  Damit lassen sich auch
wieder Phasenfehler provozieren.  Solche Definitionen sollten daher
auf jeden Fall vor der ersten Benutzung erfolgen!

Da die Berechnung des Funktionsergebnisses anhand des Formelaus-
druckes auf textueller Ebene erfolgt, kann der Ergebnistyp von
dem Typ des Eingangsargumentes abhängen.  So kann bei folgender
Funktion

double function x,x+x

das Ergebnis ein Integer, eine Gleitkommazahl oder sogar ein String
sein, je nach Typ des Arguments!

Bei der Definition und Ansprache von Funktionen wird im case-sensitiven
Modus zwischen Groß- und Kleinschreibung unterschieden, im Gegensatz
zu eingebauten Funktionen!


	3.5. bedingte Assemblierung
	---------------------------

--> Gültigkeit: alle Prozessoren

Der Assembler unterstützt die bedingte Assemblierung mit Hilfe der
Befehle IF... sowie SWITCH... .  Diese Befehle wirken zur Assemblier-
zeit, indem entsprechend der Bedingung Teile übersetzt oder über-
sprungen werden.  Diese Befehle sind also nicht mit den IF-State-
ments höherer Programmiersprachen zu vergleichen ( obwohl es sehr
verlockend wäre, Assembler um die Strukturierungsbefehle höherer
Sprachen zu erweitern...).

Die folgenden Konstrukte dürfen beliebig (bis zum Speicherüberlauf)
geschachtelt werden.


        3.5.1.  IF / ELSEIF / ENDIF
        - - - - - - - - - - - - - -

IF ist das gebräuchlichere und allgemeiner verwendbare Konstrukt.
Die allgemeine Form eines IF-Befehles lautet folgendermaßen:

	IF      <Ausdruck 1>
	.
        .
        <Block 1>
        .
        .
	ELSEIF  <Ausdruck 2>
        .
        .
	<Block 2>
        .
        .
        (mögliche weitere ELSEIFs)

        .
        .
        ELSEIF
	.
	.
        <Block n>
        .
	.
        ENDIF

IF dient als Einleitung und wertet den ersten Ausdruck aus und assem-
bliert Block 1, falls der Ausdruck wahr (d.h. ungleich 0) ist.  Alle
weiteren ELSEIF-Teile werden dann ignoriert.  Falls der Ausdruck aber
nicht wahr ist, wird Block 1 übersprungen und Ausdruck 2 ausgewertet.
Sollte dieser nun wahr sein, wird Block 2 assembliert.  Die Zahl der
ELSEIF-Teile ist variabel und ergibt eine IF-THEN-ELSE-Leiter belie-
biger Länge.  Der dem letzten ELSEIF (ohne Parameter) zugeordnete
Block wird nur assembliert, falls alle vorigen Ausdrücke falsch erga-
ben und bildet sozusagen einen "Default-Zweig".  Wichtig ist, daß von
den Blöcken immer nur EINER assembliert wird, und zwar der erste,
dessen zugeordnetes IF/ELSEIF einen wahren Ausdruck hatte.

Die ELSEIF-Teile sind optional, d.h. auf IF darf auch direkt ENDIF
folgen, ein parameterloses ELSEIF bildet aber immer den letzten
Zweig.

Ein ELSEIF bezieht sich immer auf das letzte, noch nicht abgeschlos-
sene IF.

Neben IF sind noch folgende weitere bedingte Befehle definiert:

IFDEF <Symbol>   : wahr, falls das angegebene Symbol definiert wurde.
		   Die Definition muß vor IFDEF erfolgt sein.
IFNDEF <Symbol>  : Umkehrung zu IFDEF.
IFUSED <Symbol>  : wahr, falls das Symbol bisher mindestens einmal
		   benutzt wurde.
IFNUSED <Symbol> : Umkehrung zu IFUSED.
IFEXIST <Name>   : wahr, falls die angegebene Datei existiert.
		   Für Schreibweise und Suchpfade gelten gleiche
		   Regeln wie beim INCLUDE-Befehl (siehe Abschnitt
		   3.8.2.).
IFNEXIST <Name>  : Umkehrung zu IFEXIST.
IFB <Arg-Liste>  : wahr, falls alle Argumente der Parameterliste leer 
                   sind.
IFNB <Arg-Liste> : Umkehrung zu IFB.


	3.5.2  SWITCH / CASE / ELSECASE / ENDCASE
        - - - - - - - - - - - - - - - - - - - - -

SWITCH ist ein Spezialfall von IF und für den Fall gedacht, daß ein
Ausdruck mit einer Reihe von Werten verglichen werden soll.  Dies
ist natürlich auch mit IF und einer Reihe von ELSEIFs machbar, die
folgende Form

            SWITCH  <Ausdruck>
            .
	    .
            CASE    <Wert 1>
	    .
            <Block 1>
            .
            CASE    <Wert 2>
	    .
            <Block 2>
            .
            (weitere CASE-Blöcke)
	    .
            CASE    <Wert n-1>
            .
            <Block n-1>
            .
            ELSECASE
            .
            <Block n>
	    .
            ENDCASE

bietet den Vorteil, daß der zu prüfende Ausdruck nur einmal hinge-
schrieben und berechnet werden muß, er ist also weniger fehleranfäl-
lig und etwas schneller als eine IF-Kette, dafür natürlich auch
nicht so flexibel.

Es ist möglich, bei den CASE-Anweisungen mehrere, durch Kommata
getrennte Werte anzugeben, um den entsprechenden Block in mehreren
Fällen assemblieren zu lassen.  Der ELSECASE-Zweig dient wiederum
als "Auffangstelle" für den Fall, daß keine der CASE-Bedingungen
greift.  Fehlt er und fallen alle Prüfungen negativ aus, so gibt AS
eine Warnung aus.

Auch wenn die Wertelisten der CASE-Teile sich überlappen, so wird
immer nur EIN Zweig ausgeführt, und zwar bei Mehrdeutigkeiten der
erste.

SWITCH dient nur der Einleitung des ganzen Konstruktes; zwischen ihm
und dem ersten CASE darf beliebiger Code stehen (andere IFs dürfen
aber nicht offen bleiben!), im Sinne eines durchschaubaren Codes
sollte davon aber kein Gebrauch gemacht werden.


	3.6. Listing-Steuerung
	----------------------

--> Gültigkeit: alle Prozessoren

	3.6.1. PAGE
        - - - - - -

Mit PAGE kann man AS die Dimensionen des Papiers, auf dem das Listing
ausgedruckt werden soll, mitteilen.  Als erster Parameter wird dabei
die Anzahl von Zeilen angegeben, nach der AS automatisch einen Zeilen-
vorschub ausgeben soll.  Zu berücksichtigen ist allerdings, daß bei
dieser Angabe die Kopfzeilen inklusive einer evtl. mit TITLE spezi-
fizierten Zeile nicht mitgerechnet werden.  Der Minimalwert für die
Zeilenzahl ist 5, der Maximalwert 255.  Eine Angabe von 0 führt dazu,
daß AS überhaupt keine automatischen Seitenvorschübe ausführt, sondern
nur noch solche, die explizit durch NEWPAGE-Befehle oder implizit am
Ende des Listings (z.B. vor der Symboltabelle) von AS ausgelöst wur-
den.
Die Angabe der Breite des Listings in Zeichen kann als optionaler
zweiter Parameter erfolgen und erfüllt zwei Zwecke: Zum einen läuft
der Zeilenzähler von AS korrekt weiter, wenn eine Quell-Zeile über
mehrere Listing-Zeilen geht, zum anderen gibt es Drucker (wie z.B.
Laserdrucker), die beim Überschreiten des rechten Randes nicht automa-
tisch in eine neue Zeile umbrechen, sondern den Rest einfach "ver-
schlucken".  Aus diesem Grund führt AS auch den Zeilenumbruch selbst-
ständig durch, d.h. zu lange Zeilen werden in Bruchstücke zerlegt, die
eine Länge kleiner oder gleich der eingestellten Länge haben.  In Zu-
sammenhang mit Druckern, die einen automatischen Zeilenumbruch besit-
zen, kann das aber zu doppelten Zeilenvorschüben führen, wenn man als
Breite exakt die Zeilenbreite des Druckers angibt.  Die Lösung in einem
solchen Fall ist, als Zeilenbreite ein Zeichen weniger anzugeben.
Die eingestellte Zeilenbreite darf zwischen 5 und 255 Zeichen liegen;
analog zur Seitenlänge bedeutet ein Wert von 0, daß AS keine Splittung
der Listing-Zeilen vornehmen soll; eine Berücksichtigung von zu langen
Zeilen im Listing beim Seitenumbruch kann dann natürlich auch nicht
mehr erfolgen.

Die Defaulteinstellung für die Seitenlänge ist 60 Zeilen, für die
Zeilenbreite 0; letztere Wert wird auch angenommen, wenn PAGE nur mit
einem Argument aufgerufen wird.

ACHTUNG! AS hat keine Möglichkeit, zu überprüfen, ob die eingestellte
Listing-Länge und Breite mit der Wirklichkeit übereinstimmen!


	3.6.2.  NEWPAGE
	- - - - - - - -

NEWPAGE kann dazu benutzt werden, einen Seitenvorschub zu erzwingen,
obwohl die Seite noch gar nicht voll ist.  Dies kann z.B. sinnvoll
sein, um logisch voneinander getrennte Teile im Assemblerprogramm
auch seitenmäßig zu trennen.  Der programminterne Zeilenzähler wird
zurückgesetzt, der Seitenzähler um Eins heraufgezählt.  Der optio-
nale Parameter steht in Zusammenhang mit einer hierarchischen Seiten-
numerierung, die AS bis zu einer Kapiteltiefe von 4 unterstützt.
0 bedeutet dabei immer die tiefste Kapitelebene, der Maximalwert kann
sich während des Laufes verändern, wenn das auch verwirrend wirken
kann, wie folgendes Beispiel zeigt:

Seite 1,   Angabe NEWPAGE 0  ---> Seite 2
Seite 2,   Angabe NEWPAGE 1  ---> Seite 2.1
Seite 2.1, Angabe NEWPAGE 1  ---> Seite 3.1
Seite 3.1, Angabe NEWPAGE 0  ---> Seite 3.2
Seite 3.2, Angabe NEWPAGE 2  ---> Seite 4.1.1

Je nach momentan vorhandener Kapiteltiefe kann NEWPAGE <Nummer> also
an verschiedenen Stellen eine Erhöhung bedeuten.  Ein automatischer
Seitenvorschub wegen Zeilenüberlauf oder ein fehlender Parameter ist
gleichbedeutend mit NEWPAGE 0.  Am Ende des Listings wird vor Ausgabe
der Symboltabelle ein implizites NEWPAGE <bish. Maximum> durchge-
führt, um sozusagen ein neues Hauptkapitel zu beginnen.


	3.6.3. MACEXP
        - - - - - - -

Mit dem Befehl

     macexp off

kann man erreichen, daß bei Makroexpansionen nur noch der Makroauf-
ruf und nicht der expandierte Text ausgegeben wird.  Die ist bei
makrointensivem Code sinnvoll, um das Listing nicht ins Uferlose
wachsen zu lassen.  Mit

     macexp on

wird die vollständige Listingform wieder eingeschaltet, dies ist auch
die Defaultvorgabe.

Zwischen der Bedeutung von MACEXP für Makros und der für alle anderen
makroartigen Konstrukte (z.B. REPT) besteht ein subtiler Unterschied:
Während Makros intern ein Flag besitzen, das anzeigt, ob Expansionen
dieses Makros ausgegeben werden sollen oder nicht, wirkt MACEXP direkt
auf alle anderen Konstrukte, die "vor Ort" aufgelöst werden.  Der Sinn
dieser Differenzierung besteht darin, daß es Makros geben kann, die
ausgetestet sind und die man nicht mehr sehen will, andere aber sehr
wohl noch.  MACEXP dient hier als Default für das bei der Definition
des Makros zu setzende Flag, der mit den Steuerparametern NOEXPAND/
EXPAND übersteuert werden kann.

Die momentane Einstellung läßt sich aus dem Symbol MACEXP auslesen.


	3.6.4.  LISTING
	- - - - - - - -

funktioniert wie MACEXP und akzeptiert die gleichen Parameter, 
arbeitet aber wesentlich radikaler: Mit

     listing off

wird überhaupt nichts mehr im Listing ausgegeben.  Diese Anweisung
macht Sinn für erprobte Codeteile oder Includefiles, um den Papier-
verbrauch nicht ins Unermeßliche zu steigern.  ACHTUNG! Wer später
das Gegenstück vergißt, bekommt auch keine Symboltabelle mehr zu
sehen!  Zusätzlich zu ON und OFF akzeptiert LISTING auch NOSKIPPED
und PURECODE als Argument.  Mit der NOSKIPPED-Einstellung werden
aufgrund bedingter Assemblierung nicht assemblierte Teile nicht im
Listing aufgeführt, während PURECODE - wie der Name schon erahnen
läßt - auch die IF-Konstrukte selber nicht mehr im Listing aufführt.
Diese Einstellungen sind nützlich, wenn man Makros, die anhand von
Parametern verschiedene Aktionen ausführen, benutzt, und im Listing
nur noch die jeweils benutzten Teile sehen möchte.

Die momentane Einstellung läßt sich aus dem Symbol LISTING (0=OFF,
1=ON, 2=NOSKIPPED, 3=PURECODE) auslesen.


	3.6.5.  PRTINIT und PRTEXIT
	- - - - - - - - - - - - - -

Bei der Listingausgabe auf Druckern ist es oftmals sinnvoll, den
Drucker in eine andere Betriebsart (z.B. Schmalschrift) umzuschal-
ten und am Ende des Listings diese Betriebsart zu deaktivieren. Mit
diesen Befehlen kann die Ausgabe dieser Steuerfolgen automatisiert
werden, indem man mit PRTINIT <String> die Zeichenfolge angibt, die
vor Listingbeginn an das Ausgabegerät geschickt werden soll und mit
PRTEXIT <String> analog den Deinitialisierungsstring.  In beiden
Fällen muß <String> ein Stringausdruck sein.  Die Schreibungsregeln
für Stringkonstanten ermöglichen es, ohne Verrenkungen Steuerzeichen
in den String einzubauen.

Bei der Ausgabe dieser Strings unterscheidet der Assembler NICHT,
wohin das Listing geschickt wird, d.h. Druckersteuerzeichen wer-
den rücksichtslos auch auf den Bildschirm geschickt!

Beispiel :

Bei Epson-Druckern ist es sinnvoll, sie für die breiten Listings
in den Kompreßdruck zu schalten.  Die beiden Zeilen

	prtinit "\15"
	prtexit "\18"

sorgen dafür, daß der Kompreßdruck ein- und nach dem Druck wieder
ausgeschaltet wird.


	3.6.6.  TITLE
	- - - - - - -

Normalerweise versieht der Assembler bereits jede Listingseite mit
einer Titelzeile, die Quelldatei, Datum und Uhrzeit enthält.  Mit
diesem Befehl kann man den Seitenkopf um eine beliebige zusätzliche
Zeile erweitern.  Der anzugebende String ist dabei ein beliebiger
Stringausdruck.

Beispiel:

Bei dem bereits oben angesprochenenen Epson-Drucker soll eine Titel-
zeile im Breitdruck ausgegeben werden, wozu vorher der Kompreßmodus
abgeschaltet werden muß:

	title	"\18\14Breiter Titel\15"

(Epson-Drucker schalten den Breitdruck automatisch am Zeilenende
aus.)


	3.7. lokale Symbole
        -------------------

--> Gültigkeit: alle Prozessoren

Bei den lokalen Labels und den dazu eingeführten Sektionen handelt
es sich um eine grundlegend neue Funktion, die mit Version 1.39
eingeführt wird.  Da dieser Teil sozusagen "1.0" ist, ist er
sicherlich noch nicht der Weisheit letzter Schluß.  Anregungen und
(konstruktive) Kritik sind daher besonders erwünscht.  Insbesondere
habe ich die Verwendung von Sektionen hier so dargestellt, wie ich
sie mir vorstelle.  Es kann dadurch passiert sein, daß die Realität
nicht ganz meinem Modell im Kopf entspricht.  Für den Fall von Dis-
krepanzen verspreche ich, daß die Realität der Dokumentation ange-
paßt wird, und nicht umgekehrt, wie es bei größeren Firmen schon
einmal vorgekommen sein soll...

AS erzeugt keinen linkfähigen Code (und wird es wohl auch nicht in
näherer Zukunft tun :-( ).  Diese Tatsache zwingt dazu, ein Programm
immer im ganzen zu übersetzen.  Dieser Technik gegenüber hätte eine
Aufteilung in Linker-Module einige Vorteile:

 - kürzere Übersetzungszeiten, da lediglich die geänderten Module
   neu übersetzt werden müssen;
 - die Möglichkeit, durch Definition öffentlicher und privater Symbole
   definierte Schnittstellen zwischen den Modulen festzulegen;
 - Durch die geringere Länge der einzelnen Module reduziert sich die
   Anzahl der Symbole im einzelnen Modul, so daß kürzere und trotzdem
   eindeutige Symbolnamen benutzt werden können.

Insbesondere der letzte Punkt hat mich persönlich immer etwas gestört:
War ein Label-Name einmal am Anfang eines 2000 Zeilen langen Programmes
benutzt, so durfte er nirgendwo wieder verwendet werden --- auch nicht am
anderen Ende des Quelltextes, wo Routinen mit ganz anderem Kontext
standen.  Ich war dadurch gezwungen, zusammengesetzte Namen der Form

   <Unterprogrammname>_<Symbolname>

zu verwenden, die dann Längen zwischen 15 und 25 Zeichen hatten und
das Programm unübersichlich machten.  Das im folgenden eingehender
beschriebene Sektionen-Konzept sollte zumindest den beiden letzten
genannten Punkten abhelfen.  Es ist vollständig optional: Wollen Sie
keine Sektionen verwenden, so lassen Sie es einfach bleiben und ar-
beiten weiter wie unter den älteren AS-Versionen.


	3.7.1. Grunddefinition (SECTION/ENDSECTION)
	- - - - - - - - - - - - - - - - - - - - - -

Eine Sektion stellt einen durch spezielle Befehle eingerahmten Teil des
Assembler-Programmes dar und hat einen vom Programmierer festlegbaren,
eindeutigen Namen:

        .
        .
        <anderer Code>
        .
        .
	SECTION <Sektionsname>
        .
        .
        <Code in der Sektion>
        .
        .
	ENDSECTION [Sektionsname]
        .
	.
        <anderer Code>
        .
        .

Der Name für eine Sektion muß den Konventionen für einen Symbolnamen
entsprechen; da AS Sektions-und Symbolnamen in getrennten Tabellen
speichert, darf ein Name sowohl für ein Symbol als auch eine Sektion
verwendet werden.  Sektionsnamen müssen in dem Sinne eindeutig sein,
daß auf einer Ebene nicht zwei Sektionen den gleichen Namen haben
dürfen (was es mit den "Ebenen" auf sich hat, erläutere ich im
nächsten Abschnitt).  Das Argument zu ENDSECTION ist optional, es darf
auch weggelassen werden; Falls es weggelassen wird, zeigt AS den Namen
der Sektion an, der er das ENDSECTION zugeordnet hat.  Code in einer
Sektion wird von AS genauso behandelt wie außerhalb, lediglich mit
drei entscheidenden Unterschieden:

 - Innerhalb der Sektion definierte Symbole (z.B. Labels, EQUs...)
   werden mit einer von AS intern vergebenen, der Sektion zugeordneten
   Nummer versehen.  Diese Symbole sind von Code außerhalb der Sektion
   nicht ansprechbar (das läßt sich natürlich durch Pseudobefehle va-
   riieren, aber dazu später mehr).
 - Durch das zusätzliche Attribut kann ein Symbolname sowohl außerhalb
   der Sektion als auch innerhalb definiert werden, das Attribut er-
   laubt also, Symbolnamen mehrfach zu benutzen, ohne daß AS Protest
   anmeldet.
 - Falls ein Symbol sowohl außerhalb als auch innerhalb definiert ist,
   wird innerhalb der Sektion das "lokale" verwendet, d.h. AS sucht in
   der Symboltabelle zuerst nach einem Symbol des gewünschten Namens,
   das auch gleichzeitig der Sektion zugeordnet wurde.  Erst danach
   wird nach einem globalen Symbol dieses Namens gefahndet.

Mit diesem Mechanismus kann man z.B. den Code in Module aufteilen, wie
man es mit einem Linker getan hätte.  Eine feinere Aufteilung wäre da-
gegen, alle Routinen in getrennte Sektionen zu verpacken.  Je nach
Länge der Routinen können die nur intern benötigten Symbole dann sehr
kurze Namen haben.

Defaultmäßig unterscheidet AS Groß-und Kleinschreibung in Sektions-
namen nicht; schaltet man jedoch in den case-sensitiven Modus um, so
wird die Schreibweise genauso wie bei Symbolnamen berücksichtigt.

Die bisher beschriebene Aufteilung würde in etwa der Sprache C ent-
sprechen, in der alle Funktionen auf gleicher Ebene nebeneinander ste-
hen.  Da mein "hochsprachliches" Vorbild aber Pascal ist, bin ich noch
einen Schritt weiter gegangen:


        3.7.2.  Verschachtelung und Sichtbarkeitsregeln
        - - - - - - - - - - - - - - - - - - - - - - - -

Es ist erlaubt, in einer Sektion weitere Sektionen zu definieren,
analog zu der Möglichkeit in Pascal, in einer Prozedur/Funktion wei-
tere Prozeduren zu definieren.  Dies zeigt folgendes Beispiel:

sym     EQU        0

        SECTION    ModulA

         SECTION    ProcA1

sym       EQU        5

	 ENDSECTION ProcA1

         SECTION    ProcA2

sym       EQU        10

	 ENDSECTION ProcA2

	ENDSECTION ModulA


	SECTION    ModulB

sym      EQU        15

	 SECTION    ProcB

	 ENDSECTION ProcB

	ENDSECTION ModulB

Bei der Suche nach einem Symbol sucht AS zuerst ein Symbol, das der
aktuellen Sektion zugeordnet ist, und geht danach die ganze "Liste"
der Vatersektionen durch, bis er bei den globalen Symbolen angekommen
ist.  Im Beispiel sehen die Sektionen folgende Werte für das Symbol
sym:

    Sektion      Wert     aus Sektion...

    Global         0         Global
    ModulA         0         Global
    ProcA1         5         ProcA1
    ProcA2        10         ProcA2
    ModulB        15         ModulB
    ProcB         15         ModulB

Diese Regel kann man durchbrechen, indem man explizit an den Symbol-
namen die Sektion anhängt, aus der man das Symbol holen will, und
zwar in eckigen Klammern am Ende des Symbolnamens:

	move.l  #sym[ModulB],d0

Es dürfen dabei nur Sektionsnamen verwendet werden, die eine Obersek-
tion zur aktuellen Sektion darstellen.  Als Sonderwert sind die Namen
PARENT0..PARENT9 erlaubt, mit denen man die n-ten "Vatersektionen"
relativ zur momentanen Sektion ansprechen kann; PARENT0 entspricht
also der momentanen Sektion selber, PARENT1 der direkt übergeordneten
usw.  Anstelle PARENT1 kann man auch kurz nur PARENT schreiben.
Läßt man dagegen den Platz zwischen den Klammern komplett frei, also
etwa so

	move.l  #sym[],d0 ,

so erreicht man das globale Symbol.  ACHTUNG! Wenn man explizit ein
Symbol aus einer Sektion anspricht, so wird auch nur noch bei den
Symbolen dieser Sektion gesucht, der Sektionsbaum wird nicht mehr
bis nach oben durchgegangen!

Analog zu Pascal ist es erlaubt, daß verschiedene Sektionen Untersek-
tionen gleichen Namens haben dürfen, das Prinzip der Lokalität ver-
hindert hier Irritationen.  M.E. sollte man davon aber trotzdem spar-
samen Gebrauch machen, da in Symbol-und Querverweisliste Symbole zwar
mit der Sektion, in der sie definiert wurden, gekennzeichnet werden,
aber nicht mit der über dieser Sektion evtl. liegenden "Sektions-
hierarchie" (das hätte einfach den Platz in der Zeile gesprengt);
Unterscheidungen sind dadurch nicht erkennbar.

Da ein SECTION-Befehl von selber kein Label definiert, besteht hier
ein wichtiger Unterschied zu Pascal: Eine Pascal-Prozedur kann ihre
Unterprozeduren/funktionen automatisch "sehen", unter AS muß man noch
einen Einsprungpunkt extra definieren.  Das kann man z.B. mit folgen-
dem Makro-Pärchen tun:

proc    MACRO   name
        SECTION name
name    LABEL   $
	ENDM

endp    MACRO   name
        ENDSECTION name
        ENDM

Diese Beispiel zeigt gleichzeitig, daß die Lokalität von Labels in
Makros nicht von den Sektionen beeinflußt wird, deshalb der Trick mit
dem LABEL-Befehl.

Natürlich ist mit dieser Definition das Problen noch nicht ganz ge-
löst, bisher ist das Einsprung-Label ja noch lokal und von außen
nicht zu erreichen.  Wer nun meint, man hätte das Label einfach nur
vor der SECTION-Anweisung plazieren müssen, sei jetzt bitte ruhig,
denn er verdirbt mir den Übergang auf das nächste Thema:


	3.7.3.  PUBLIC und GLOBAL
	- - - - - - - - - - - - -

Die PUBLIC-Anweisung erlaubt es, die Zugehörigkeit eines Symbols zu
einer bestimmten Sektion zu verändern.  Es ist möglich, mit einem
PUBLIC-Befehl mehrere Symbole zu bearbeiten, ohne Beschränkung der
Allgemeinheit will ich aber ein Beispiel mit nur einer Variable ver-
wenden: Im einfachsten Falle erklärt man ein Symbol als vollständig
global, d.h. es ist von allen Stellen des Programmes ansprechbar:

	PUBLIC  <Name>

Da ein Symbol bei seiner Definition endgültig in der Symboltabelle
einsortiert wird, muß diese Anweisung VOR der Definition des Symbols
erfolgen.  Alle PUBLICs werden von AS in einer Liste vermerkt und bei
ihrer Definition aus dieser Liste wieder entfernt.  Bei Beendigung
einer Sektion gibt AS Fehlermeldungen für alle nicht aufgelösten
"Vorwärtsreferenzen" aus.

Angesichts des hierarchischen Sektionenkonzepts erscheint die Methode,
ein Symbol als vollständig global zu definieren, reichlich brachial.
Es geht aber auch etwas differenzierter, indem man zusätzlich einen
Sektionsnamen angibt:

	PUBLIC  <Name>:<Sektion>

Damit wird das Symbol der genannten Sektion zugeordnet und damit auch
allen ihren Untersektionen zugänglich (es sei denn, diese definieren
wiederum ein Symbol gleichen Namens, das dann das "globalere" über-
steuert).  Naturgemäß protestiert AS, falls mehrere Untersektionen
ein Symbol gleichen Namens auf die gleiche Ebene exportieren wollen.
Als Spezialwert für <Sektion> sind die im vorigen Abschnitt genannten
PARENTn-Namen zugelassen, um das Symbol genau n Ebenen hinaufzuexpor-
tieren.  Es sind als Sektionen nur der momentanen Sektion übergeordne-
te Sektionen zugelassen, also keine, die im Baum aller Sektionen in
einem anderen Zweig stehen.  Sollten dabei mehrere Sektionen den glei-
chen Namen haben (dies ist legal), so wird die tiefste gewählt.

Mit diesem Werkzeug kann das obige Prozedurmakro nun Sinn ergeben:

proc    MACRO   name
        SECTION name
	PUBLIC  name:PARENT
name    LABEL   $
        ENDM

Diese Einstellung entspricht dem Modell von Pascal, in der eine Un-
terprozedur auch nur von ihrem "Vater" gesehen werden kann, jedoch
nicht vom "Großvater".

Falls mehrere Untersektionen versuchen, ein Symbol gleichen Namens
in die gleiche Obersektion zu exportieren, meckert AS über doppelt
definierte Symbole, was an sich ja korrekt ist.  War das gewollt,
so muß man die Symbole in irgendeiner Weise "qualifizieren", damit
sie voneinander unterschieden werden können.  Dies ist mit der
GLOBAL-Anweisung möglich.  Die Syntax von GLOBAL ist der von PUBLIC
identisch, das Symbol bleibt aber lokal, anstatt einer höheren
Sektion zugeordnet zu werden.  Stattdessen wird ein weiteres Symbol
gleichen Werts erzeugt, dem jedoch der Untersektionsname mit einem
Unterstrich vorangestellt wird, und nur dieses Symbol wird der
Sektionsangabe entsprechend öffentlich gemacht.  Definieren z.B.
zwei Sektionen A und B ein Symbol SYM und exportieren es mit GLOBAL
zu ihrer Vatersektion, so werden dort die Symbole unter den Namen
A_SYM und B_SYM eingeordnet.

Falls zwischen Quell- und Zielsektion mehrere Stufen stehen sollten,
so wird entsprechend der komplette Namenszweig an den Symbolnamen
angehängt.


	3.7.4.  FORWARD
	- - - - - - - -

So schön das bisher besprochene Modell ist, ein bei Pascal nicht
auftauchendes Detail macht Ärger: die bei Assembler möglichen Vor-
wärtsreferenzen.  Bei Vorwärtsreferenzen kann es sein, daß AS im
ersten Pass auf ein Symbol einer höheren Sektion zugreift.  Dies
ist an sich nicht weiter tragisch, solange im zweiten Pass das rich-
tige Symbol genommen wird, es können aber Unfälle der folgenden Art
passieren:

loop:   .
        <Code>
	.
	.
	SECTION sub
	.               ; ***
	.
	bra.s   loop
	.
	.
loop:   .
	.
	ENDSECTION
	.
	.
	jmp     loop    ; Hauptschleife

AS wird im ersten Pass das globale Label loop verwenden, sofern das
Programmstück bei <Code> hinreichend lang ist, wird er sich über eine
zu große Sprungdistanz beklagen und den zweiten Pass erst gar nicht
versuchen.  Um die Uneindeutigkeit zu vermeiden, kann man natürlich
explizit angeben, woher das Symbol kommen soll:

	bra.s   loop[sub]

Falls ein lokales Symbol häufig referenziert wird, können die vielen
Klammern mit dem FORWARD-Befehl eingespart werden.  Das Symbol
wird damit explizit als lokal angekündigt.  AS wird dann bei Zugriffen
auf dieses Symbol automatisch nur im lokalen Symbolbereich suchen.  In
diesem Falle müßte an der mit *** gekennzeichneten Stelle dafür der
Befehl

	FORWARD loop

stehen.

Damit FORWARD Sinn macht, muß es nicht nur vor der Definition des
Symbols, sondern vor seiner ersten Benutzung in der Sektion gegeben
werden.  Ein Symbol gleichzeitig privat und öffentlich zu definieren,
ergibt keinen Sinn und wird von AS auch angemahnt.


	3.7.5.  Geschwindigkeitsaspekte
        - - - - - - - - - - - - - - - -

Die mehrstufige Suche in der Symboltabelle und die Entscheidung, mit
welchem Attribut ein Symbol eingetragen werden soll, kosten naturgemäß
etwas Rechenzeit.  Ein 1800 Zeilen langes 8086-Programm z.B. wurde nach
der Umstellung auf Sektionen statt in 33 in 34,5 Sekunden assembliert
(80386 SX, 16MHz, 3 Durchgänge).  Der Overhead hält sich also in Gren-
zen: Ob man ihn in Kauf nehmen will, ist (wie am Anfang erwähnt) eine
Frage des Geschmacks;  man kann AS genauso gut ohne Sektionen verwen-
den.


        3.8. Diverses
	-------------


        3.8.1. SHARED
	- - - - - - -

--> Gültigkeit: alle Prozessoren

Mit diesem Befehl weist man den AS an, die in der Parameterliste 
angegebenen Symbole (egal ob Integer, Gleitkomma oder String) im
Sharefile mit ihren Werten abzulegen.  Ob eine solche Datei über-
haupt und in welchem Format erzeugt wird, hängt von den in 2.1. be-
schriebenen Kommandozeilenschaltern ab.  Findet AS diesen Befehl und 
es wird keine Datei erzeugt, führt das zu einer Warnung.

VORSICHT! Ein eventuell der Befehlszeile anhängender Kommentar wird 
in die erste, ausgegebene Zeile mit übertragen (sofern die Argument-
liste von SHARED leer ist, wird nur der Kommentar ausgegeben).  Falls
die Share-Datei für C oder Pascal erzeugt wird, sind einen C/Pascal-
Kommentar schließende Zeichenfolgen ("*/" bzw. "*)") im Kommentar zu
vermeiden.  AS prüft dies nicht!


        3.8.2.  INCLUDE
	- - - - - - - -

--> Gültigkeit: alle Prozessoren

Dieser Befehl fügt die im Parameter angegebene Datei (die optional in
Gänsefüßchen eingeschlossen sein darf) so im Text ein, als ob sie dort
stehen würde.  Dieser Befehl ist sinnvoll, um Quelldateien aufzuspal-
ten, die alleine nicht in den Speicher passen würden oder um sich
"Toolboxen" zu erzeugen.

Falls der angegebene Dateiname keine Endung hat, wird er automatisch
um die Endung "INC" erweitert.

Mit der Kommandozeilenoption -i <Pfadliste> läßt sich eine Liste von
Verzeichnissen angeben, in denen automatisch zusätzlich nach der In-
cludedatei gesucht werden soll.  Wird die Datei nicht gefunden, so
ist dies ein FATALER Fehler, d.h. der Assembler bricht sofort ab.

Aus Kompatibilitätsgründen ist es erlaubt, den Dateinamen in Gänse-
füßchen zu schreiben,

	include	stddef51
und
	include	"stddef51.inc"

sind also äquivalent.  ACHTUNG! Wegen dieser Wahlfreiheit ist hier
nur eine Stringkonstante, aber kein Stringausdruck zulässig!

Sollte der Dateiname eine Pfadangabe enthalten, so wird die Suchliste
ignoriert.


	3.8.3.   BINCLUDE
        - - - - - - - - -

--> Gültigkeit: alle Prozessoren

BINCLUDE dient dazu, in den von AS erzeugten Code Binärdaten einzu-
betten, die von einem anderen Programm erzeugt wurden (das kann 
natürlich theoretisch auch von AS selber erzeugter Code sein...).
BINCLUDE hat drei Formen:

   BINCLUDE <Datei>

In dieser Form wird die Datei komplett eingebunden.

   BINCLUDE <Datei>,<Offset>

In dieser Form wird der Inhalt der Datei ab <Offset> bis zum Ende
der Datei eingebunden.

   BINCLUDE <Datei>,<Offset>,<Länge>

In dieser Form werden <Länge> Bytes ab Offset <Offset> eingebunden.

Es gelten die gleichen Regeln bezüglich Suchpfaden wie bei INCLUDE.


	3.8.4.  MESSAGE, WARNING, ERROR und FATAL
	- - - - - - - - - - - - - - - - - - - - -

--> Gültigkeit: alle Prozessoren

Der Assembler prüft zwar die Quelltexte so streng wie möglich und
liefert diffenzierte Fehlermeldungen, je nach Anwendung kann es
aber sinnvoll sein, unter bestimmten Bedingungen zusätzliche Fehler-
meldungen auszulösen, mit denen sich logische Fehler automatisch
prüfen lassen.  Der Assembler unterscheidet drei Typen von Fehler-
meldungen, die über die drei Befehle auch dem Programmierer zugäng-
lich sind:

- WARNING : Fehler, die auf möglicherweise falschen oder ineffi-
	    zienten Code hinweisen.  Die Assemblierung läuft weiter,
	    eine Codedatei wird erzeugt.

- ERROR   : echte Fehler im Programm.  Die Assemblierung läuft wei-
	    ter, um mögliche weitere Fehler in einem Durchgang ent-
	    decken und korrigieren zu können.  Eine Codedatei wird
	    nicht erzeugt.

- FATAL   : schwerwiegende Fehler, die einen sofortigen Abbruch des
	    Assemblers bedingen.  Eine Codedatei kann möglicherweise
	    entstehen, ist aber unvollständig.

Allen drei Befehlen ist das Format gemeinsam, in dem die Fehlermel-
dung angegeben werden muß: Ein beliebig (berechneter?!) Stringaus-
druck, der damit sowohl eine Konstante als auch variabel sein darf.

Diese Anweisungen ergeben nur in Zusammenhang mit bedingter Assem-
blierung Sinn.  Ist für ein Programm z.B. nur ein begrenzter Adreß-
raum vorhanden, so kann man den Überlauf folgendermaßen testen:

ROMSize		equ	8000h		; 27256-EPROM

ProgStart:
		.
		.
		<das eigentliche Programm>
		.
		.
ProgEnd:

		if 	ProgEnd-ProgStart>ROMSize
		 error	"\aDas Programm ist zu lang!"
		endif

Neben diesen fehlererzeugenden Befehlen gibt es noch den Befehl
MESSAGE, der einfach nur eine Meldung auf der Konsole bzw. im
Listing erzeugt.  Seine Benutzung ist den anderen drei Befehlen
gleich.


	3.8.5. READ
	- - - - - -

--> Gültigkeit: alle Prozessoren

READ ist sozusagen das Gegenstück zu der vorigen Befehlsgruppe: mit
ihm ist es möglich, während der Assemblierung Werte von der Tastatur
einzulesen.  Wozu das gut sein soll?  Um das darzulegen, soll hier
ausnahmsweise einmal das Beispiel vor die genauere Erläuterung gezo-
gen werden:

Ein Programm benötigt zum Datentransfer einen Puffer mit einer zur
Übersetzungszeit festzulegenden Größe.  Um die Größe des Puffers
festzulegen, könnte man sie einmal mit EQU in einem Symbol ablegen,
es geht aber auch interaktiv mit READ:

      IF     MomPass=1
       READ  "Puffergröße",BufferSize
      ENDIF

Auf diese Weise können Programme sich während der Übersetzung inter-
aktiv konfigurieren, man kann sein Programm z.B. jemandem geben, der
es mit seinen Parametern übersetzen kann, ohne im Quellcode "herum-
stochern" zu müssen.  Die im Beispiel gezeigte IF-Abfrage sollte
übrigens immer verwendet werden, damit der Anwender nur einmal mit
der Abfrage belästigt wird.

READ ähnelt sehr stark dem SET-Befehl, nur daß der dem Symbol zuzu-
weisende Wert nicht rechts vom Schlüsselwort steht, sondern von der
Tastatur eingelesen wird.  Dies bedeutet z.B. auch, daß AS anhand
der Eingabe automatisch festlegt, ob es sich um eine Integer- oder
Gleitkommazahl oder einen String handelt und anstelle einzelner
Konstanten auch ganze Formelausdrücke eingegeben werden können.

READ darf entweder nur einen Parameter oder zwei Parameter haben,
denn die Meldung zur Eingabeaufforderung ist optional.  Fehlt sie,
so gibt AS eine aus dem Symbolnamen konstruierte Meldung aus.


	3.8.6.  RELAXED
	- - - - - - - -

--> Gültigkeit: alle Prozessoren

Defaultmäßig ist einer Prozessorfamilie eine bestimmte Schreibweise
von Integer-Konstanten zugeordnet (die i.a. der Herstellervorgabe
entspricht, solange der nicht eine allzu abgefahrene Syntax be-
nutzt...).  Nun hat aber jeder seine persönlichen Vorlieben für die
eine oder andere Schreibweise und kann gut damit leben, daß sich sei-
ne Programme nicht mehr mit dem Standard-Assembler übersetzen lassen.
Setzt man ein

      RELAXED ON

an den Programmanfang, so kann man fortan alle Schreibweisen beliebig
gemischt und durcheinander verwenden; bei jedem Ausdruck versucht AS
automatisch zu ermitteln, welche Schreibweise verwendet wurde.  Daß
diese Automatik nicht immer das Ergebnis liefert, das man sich vorge-
stellt hat, ist auch der Grund, weshalb diese Option explizit einge-
schaltet werden muß (und man sich davor hüten sollte, sie einfach in
einem existierenden Programm dazuzusetzen): Ist nicht durch vor- oder
nachgestellte Zeichen zu erkennen, daß es sich um Intel- oder Motoro-
la-Konstanten handelt, wird im C-Modus gearbeitet.  Eventuell voran-
gestellte, eigentlich überflüssige Nullen haben in diesem Modus durch-
aus eine Bedeutung:

      move.b  #08,d0

Diese Konstante würde als Oktalkonstante verstanden werden, und weil
Oktalzahlen nur Ziffern von 0..7 enthalten können, führt das zu einem
Fehler.  Dabei hätte man in diesem Fall noch Glück gehabt, bei der
Zahl 077 z.B. hätte man ohne Meldung Probleme bekommen.  Ohne
RELAXED-Modus wäre in beiden Fällen klar gewesen, daß es sich um dezi-
male Konstanten handelt.

Die momentane Einstellung kann aus dem gleichnamigen Symbol ausgelesen
werden.

	3.8.7.  END
	- - - - - -

--> Gültigkeit: alle Prozessoren

END kennzeichnet das Ende des Assemblerprogrammes.  Danach noch in
der Quelldatei stehende Zeilen werden ignoriert.  WICHTIG: END
darf zwar aus einem Makro heraus aufgerufen werden, der Stapel der
bedingten Assemblierung wird aber nicht automatisch abgeräumt.  Das
folgende Konstrukt führt daher zu einer Fehlermeldung:

	IF KeineLustMehr
	 END
	ENDIF

Optional darf END auch einen Integer-Ausdruck als Argument haben, der
den Startpunkt des Programmes vermerkt.  Dieser wird von AS in einem
speziellen Record der Datei gespeichert und kann z.B. von P2HEX wei-
terverarbeitet werden.

END war eigentlich schon immer in AS definiert, nur war es bei
früheren Versionen von AS aus Kompatibilität zu anderen Assemblern
vorhanden und hatte keine Wirkung.


	4. Prozessorspezifische Hinweise
	================================

Ich habe mich bemüht, die einzelnen Codegeneratoren möglichst
kompatibel zu den Originalassemblern zu halten, jedoch nur soweit,
wie es keinen unvertretbaren Mehraufwand bedeutete.  Wichtige Unter-
schiede, Details und Fallstricke habe ich im folgenden aufgelistet.

	4.1. 6811
	---------

"Wo gibt es denn das zu kaufen, den HC11 in NMOS?", fragt jetzt
vielleicht der eine oder andere.  Gibt es natürlich nicht, aber ein H
läßt sich nun einmal nicht in einer Hexzahl darstellen (ältere
Versionen von AS hätten solche Namen deswegen nicht akzeptiert), und
dann habe ich die Buchstaben gleich ganz weggelassen...

"Jemand, der sagt, etwas sei unmöglich,sollte wenigstens so koope-
rativ sein, denjenigen, der es gerade tut, nicht am Arbeiten zu
hindern."

Ab und zu ist man gezwungen, seine Meinung zu revidieren.  Vor
einigen Versionen hatte ich an dieser Stelle noch behauptet, ich
könne es im Parser von AS nicht realisieren, daß man die Argumente
von BSET/BCLR bzw. BRSET/BRCLR auch mit Leerzeichen trennen kann.
Offensichtlich kann selbiger aber mehr, als ich vermutet habe...nach
der soundsovielten Anfrage habe ich mich noch einmal drangesetzt,
und jetzt scheint es zu laufen.  Man darf sowohl Leerzeichen als
auch Kommas verwenden, aber nicht in allen Varianten, um es nicht
uneindeutig zu machen:  Es gibt zu jeder Befehlsvariante zwei Mög-
lichkeiten; eine, die nur Kommas verwendet, sowie eine, wie sie
von Motorola wohl definiert wurde (leider sind die Datenbücher
nicht immer so gut wie die zugehörige Hardware...):

   Bxxx  abs8 #mask         entspricht    Bxxx  abs8,#mask
   Bxxx  disp8,X #mask      entspricht    Bxxx  disp8,X,#mask
   BRxxx abs8 #mask adr     entspricht    BRxxx abs8,#mask,adr
   BRxxx disp8,X #mask adr  entspricht    BRxxx disp8,X,#mask,adr

Dabei steht xxx entweder für SET oder CLR und #mask für die zu
verwendende Bitmaske; der Lattenzaun ist dabei optional.
Anstelle des X-Registers darf natürlich auch Y verwendet werden.


	4.2. PowerPC
	------------

Sicher hat es ein bißchen den Anflug einer Schnapsidee, einen Pro-
zessor, der eher für den Einsatz in Workstations konzipiert wurde,
in AS einzubauen, der sich ja eher an Programmierer von Einplatinen-
computern wendet.  Aber was heute noch das Heißeste vom Heißen ist,
ist es morgen schon nicht mehr, und sowohl der Z80 als auch der
8088 haben ja inzwischen die Mutation von der Personal Computer-CPU
zum sog. "Mikrocontroller" vollzogen.  Mit dem Erscheinen von
MPC505 und PPC403 hat sich die Vermutung dann auch bestätigt, daß
IBM und Motorola diese Prozessorserie auf allen Ebenen durchdrücken
wollen.

Die Unterstützung ist momentan noch nicht vollständig: Als
Pseudobefehle zur Datenablage werden momentan provisorisch die
Intel-Mnemonics unterstützt und es fehlen die etwas ungewöhnlicheren,
in [Mot601] genannten RS6000-Befehle (die aber hoffentlich keiner
vermißt...).  Das wird aber nachgeholt, sobald Informationen
verfügbar sind!


	4.3. DSP56000
	-------------

Motorola, was ist nur in Dich gefahren!  Wer bei Dir ist nur auf das
schmale Brett gekommen, die einzelnen parallelen Datentransfers
ausgerechnet durch Leerzeichen zu trennen!  Wer immer nun seine Codes
etwas übersichtlicher formatieren will, z.B. so:

    move    x:var9 ,r0
    move    y:var10,r3   ,

der ist gekniffen, weil das Leerzeichen als Trennung paralleler Daten-
transfers erkannt wird!

Sei's drum; Motorola hat es so definiert, und ich kann es nicht
ändern.  Als Trennung der Operationen sind statt Leerzeichen auch Ta-
bulatoren zugelassen, und die einzelnen Teile sind ja wieder ganz
normal mit Kommas getrennt.

In [Mot56] steht, daß bei den Befehlen MOVEC, MOVEM, ANDI und ORI auch
die allgemeineren Mnemonics MOVE, AND und OR verwendet werden können.
Bei AS geht das (noch) nicht.


        4.4. H8/300
        -----------

Bei der Assemblersyntax dieser Prozessoren hat Hitachi reichlich
bei Motorola abgekupfert (was so verkehrt ja nun auch nicht war...),
nur leider wollte die Firma unbedingt ihr eigenes Format für Hexa-
dezimalzahlen einführen, und dazu noch eines, das ähnlich wie bei
Microchip Hochkommas verwendet.  Das konnte (und wollte) ich bei AS
nicht nachvollziehen, bei dem Hochkommas zur Einrahmung von
ASCII-Sequenzen benutzt werden.  Anstelle dessen werden Zahlen in der
üblichen Motorola-Syntax geschrieben, d.h. mit einem Dollarzeichen.


	4.5. SH7000/7600
	----------------

Leider hat Hitachi auch hier wieder das Extrawurst-Format für Hexa-
dezimalzahlen verwendet, und wieder habe ich in AS das nicht nach-
vollzogen...bitte Motorola-Syntax benutzen!

Bei der Verwendung von Literalen und dem LTORG-Befehl sind einige
Details zu beachten, wenn man nicht auf einmal mit eigenartigen
Fehlermeldungen konfrontiert werden will:

Literale existieren, weil der Prozessor nicht in der Lage ist,
Konstanten außerhalb des Bereiches von -128 bis 127 mit
immediate-Adressierung zu laden.  AS (und der Hitachi-Assembler)
verstecken diese Unzulänglichkeit, indem sie automatisch entspre-
chende Konstanten im Speicher ablegen, die dann mittels PC-rela-
tiver Adressierung angesprochen werden.  Die Frage, die sich nun
erhebt, ist die, wo diese Konstanten im Speicher abgelegt werden
sollen.  AS legt sie nicht sofort ab, sondern sammelt sie so lange
auf, bis im Programm eine LTORG-Anweisung auftritt.  Dort werden
alle Konstanten abgelegt, wobei deren Adressen mit ganz normalen
Labels versehen werden, die man auch in der Symboltabelle sehen
kann.  Ein Label hat die Form

   LITERAL_s_xxxx_n   .

Dabei repräsentiert s den Typ des Literals.  Unterschieden werden
Literale, die 16-Bit-Konstanten (s=W), 32-Bit-Konstanten (s=L)
oder Vorwärtsreferenzen, bei denen AS die Operandengröße nicht
im voraus erkennen kann (s=F), enthalten.  Für W oder L bedeutet
xxxx den hexadezimal geschriebenen Wert der Konstante, bei Vorwärts-
referenzen, bei denen man den Literalwert ja noch nicht kennt,
bezeichnet xxxx eine einfache Durchnumerierung. n kennzeichnet das
wievielte Auftreten dieses Literals in dieser Sektion.  Literale
machen ganz normal die Lokalisierung durch Sektionen mit, es ist
daher zwingend erforderlich, in einer Sektion entstandene Literale
mit LTORG auch dort abzulegen!

Die Durchnumerierung mit n ist erforderlich, weil ein Literal in
einer Sektion mehrfach auftreten kann.  Dies ist einmal bedingt da-
durch, daß die PC-relative Adressierung nur positive Displacements
erlaubt, einmal mit LTORG abgelegte Literale also im folgenden
Code nicht mitbenutzt werden können, andererseits auch, weil die
Reichweite der Displacements beschränkt ist (512 bzw. 1024 Byte).
Ein automatisches LTORG am Ende des Programmes oder beim Umschalten
zu einer anderen CPU erfolgt nicht; findet AS in einer solchen Si-
tuation noch abzulegende Literale, so wird eine Fehlermeldung aus-
gegeben.

Da bei der PC-relativen Adressierung der zur Adressierung heran-
gezogene PC-Wert der Instruktionsadresse+4 entspricht, ist es nicht
möglich, ein Literal zu benutzen, welches direkt hinter dem betrof-
fenen Befehl abgelegt wird, also z.B. so:

        mov     #$1234,r6
        ltorg

Da der Prozessor dann aber sowieso versuchen würde, Daten als Code
auszuführen, sollte diese Situation in realen Programmen nicht auf-
treten.  Wesentlich realer ist aber ein anderer Fallstrick:  Wird
hinter einem verzögerten Sprung PC-relativ zugegriffen, so ist der
Programmzähler bereits auf die Sprungzieladresse gesetzt, und das
Displacement wird relativ zum Sprungziel+2 berechnet.  Im folgenden
Beispiel kann daher das Literal nicht erreicht werden:

        bra     Target
        mov	#$12345678,r4        ; wird noch ausgeführt
        .
        .
        ltorg                        ; hier liegt das Literal
        .
        .
Target: mov     r4,r7                ; hier geht es weiter

Da Target+2 hinter dem Literal liegt, würde sich ein negatives
Displacement ergeben.  Besonders haarig wird es, wenn mit den
Befehlen JMP, JSR, BRAF oder BSRF verzweigt wird:  Da AS die
Zieladresse hier nicht ermitteln kann (sie ergibt sich erst zur
Laufzeit aus dem Registerinhalt), nimmt AS hier eine Adresse an,
die nach Möglichkeit nie paßt, so daß PC-relative Adressierung
gänzlich unmöglich wird.

Es ist nicht direkt möglich, aus der Zahl und Größe der Literale
auf den belegten Speicher zu schließen.  U.u. muß AS ein Füllwort
einbauen, um einen Langwort-Wert auf eine durch 4 teilbare Adresse
auszurichten, andererseits kann er möglicherweise Teile eines
32-bittigen Literals für 16-Bit-Literale mitbenutzten.  Mehrfach
auftretende Literale erzeugen natürlich nur einen Eintrag.  Solche
Optimierungen werden für Vorwärtsreferenzen allerdings ganz unter-
drückt, da AS den Wert dieser Literale noch nicht kennt.

Da Literale die PC-relative Adressierung ausnutzen, die nur beim
MOV-Befehl erlaubt sind, beschränken sich Literale ebenfalls auf
die Verwendung in MOV.  Etwas trickreich ist hier die Art und Weise,
in der AS die Operandengröße auswertet.  Eine Angabe von Byte oder
Wort bedeutet, daß AS einen möglichst kurzen MOV-Befehl erzeugt,
der den angegebenen Wert in den unteren 8 oder 16 Bit des Registers
erzeugt, d.h. die oberen 24 oder 16 Bit werden als don't care
behandelt.  Gibt man dagegen Langwort oder gar nichts an, so sagt
dies aus, daß das komplette 32-Bit-Register den angegebenen Wert
enthalten soll.  Das hat z.B. den Effekt, daß in folgendem Beispiel

        mov.b   #$c0,r0
        mov.w   #$c0,r0
        mov.l   #$c0,r0

der erste Befehl echte immediate-Adressierung erzeugt, der zweite und
dritte jedoch ein Wort-Literal benutzen: Da das Bit 7 in der Zahl ge-
setzt ist, erzeugt der Byte-Befehl effektiv $FFFFFFC0 im Register,
was nach der Konvention nicht das wäre, was man im zweiten und
dritten Fall haben möchte.  Im dritten Fall reicht auch ein Wort-Li-
teral, weil das gelöschte Bit 15 des Operanden vom Prozessor in Bit
16..31 fortgesetzt wird.

Wie man sieht, ist dieses ganze Literal-Konzept reichlich kom-
pliziert; einfacher ging's aber wirklich nicht.  Es liegt leider in
der Natur der Sache, daß man manchmal Fehlermeldungen über nicht
gefundene Literale bekommt, die eigentlich logisch nicht auftreten
könnten, weil AS die Literale ja komplett in eigener Regie verwaltet.
Treten aber bei der Assemblierung Fehler erst im zweiten Pass auf, so
verschieben sich z.B. hinter der Fehlerstelle liegende Labels gegen-
über dem ersten Pass, weil AS für die jetzt als fehlerhaft erkannten
Befehle keinen Code mehr erzeugt.  Da aber Literalnamen u.a. aus
den Werten von Symbolen erzeugt werden, werden als Folgefehler davon
eventuell andere Literalnamen nachgefragt, als im ersten Pass abgelegt
wurden und AS beschwert sich über nicht gefundene Symbole...sollten
also neben anderen Fehlern solche Literal-Fehler auftreten, beseitigen
Sie erst die anderen Fehler, bevor Sie mich und alle Literale ver-
fluchen...

Wer aus der Motorola-Ecke kommt und PC-relative Adressierung explizit
benutzen will (z.B. um Variablen lageunabhängig zu erreichen), sollte
wissen, daß beim Ausschreiben der Adressierung nach Programmierhand-
buch, also z.B. so:

        mov.l   @(Var,PC),r8

KEINE implizite Umrechnung der Adresse auf ein Displacement erfolgt,
d.h. der Operand wird so eingesetzt, wie er ist (und würde in diesen
Beispiel wohl mit hoher Wahrscheinlichkeit eine Fehlermeldung hervor-
rufen...).  Will man beim SH7x00 PC-relativ adressieren, so tut man
das einfach mit "absoluter" Adressierung, die auf Maschinenebene ja
gar nicht existiert:

        mov.l   Var,r8

Hier wird das Displacement korrekt berechnet (es gelten natürlich die
gleichen Einschränkungen für das Displacement wie bei Literalen).


	4.6. MELPS-4500
	---------------

Der Programmspeicher dieser Mikrokontroller ist in Seiten zu 128
Worten eingeteilt.  Diese Einteilung existiert eigentlich nur deswe-
gen, weil es Sprungbefehle gibt, deren Ziel innerhalb der gleichen
Seite liegen darf, und andererseits "lange" Exemplare, die den ganzen
Adreßbereich erreichen können.  Die Standard-Syntax von Mitsubishi
verlangt eigentlich, daß Seite und Offset als getrennte Argument ge-
schrieben werden müssen.  Da das aber reichlich unpraktisch ist (an-
sonsten hat man als Programmierer keine Veranlassung, sich um Seiten
zu kümmern, mit der Ausnahme von indirekten Sprüngen), erlaubt es AS
auch wahlweise, die Zieladresse linear zu schreiben, also z.B.

      bl     $1234

anstelle

      bl     $24,$34 .


	4.7. MELPS-740
	--------------

Die Mikrokontroller dieser Reihe haben ein sehr nettes, verstecktes
Feature: Setzt man mit dem Befehl SET das Bit 5 des Statusregisters,
so wird bei allen arithmetischen Operationen (und Ladebefehlen) der
Akkumulator durch die durch das X-Register adressierte Speicherzelle
ersetzt.  Dieses Feature syntaxmäßig sauber zu integrieren, ist
bisher nicht geschehen, d.h. es kann bisher nur im "Handbetrieb"
(SET...Befehle mit Akkuadressierung...CLT) genutzt werden.

Nicht alle MELPS-740-Prozessoren implementieren alle Befehle.  An
dieser Stelle muß der Programmierer aufpassen, daß er nur die Befehle
benutzt, die auch wirklich vorhanden sind, da AS die Prozessoren
dieser Familie nicht näher unterscheidet.  Die Besonderheiten der
Special-Page-Adressierung werden bei der Erklärung von ASSUME näher
erläutert.


	4.8. MELPS-7700/65816
	---------------------

Offensichtlich haben diese beiden Prozessorfamilien ausgehend vom
6502 (über ihre 8-bittigen Vorgänger) etwas disjunkte Entwicklungs-
wege hinter sich.  Kurz aufgelistet, ergeben sich folgende Unter-
schiede:

- Der 65816 hat keinen B-Akkumulator.
- Beim 65816 fehlen Multiplikations- sowie Divisionsbefehle.
- Die Befehle SEB, CLB, BBC, BBS, CLM, SEM, PSH, PUL und LDM fehlen
  beim 65816.  An deren Stelle in der Code-Tabelle finden sich TSB,
  TRB, BIT, CLD, SED, XBA, XCE und STZ.

Identische Funktion, jedoch andere Namen haben folgende Befehle:

   65816     MELPS-7700       65816    MELPS-7700

    REP        CLP             PHK        PHG
    TCS        TAS             TSC        TSA
    TCD        TAD             TDC        TDA
    PHB        PHT             PLB        PLT
    WAI        WIT

Besonders tückisch sind die Befehle PHB, PLB und TSB: diese Befehle
haben jeweils eine völlig andere Funktion und Kodierung!

Leider tun diese Prozessoren mit ihrem Speicher etwas, was für mich
auf der nach oben offenen Perversitätsskala noch vor der Intel-
mäßigen Segmentierung rangiert: sie banken ihn!  Nunja, dies ist
wohl der Preis für die 6502-Aufwärtskompatibilität; wie dem auch sei,
damit AS den gewünschten Code erzeugen kann, muß man ihn über den
ASSUME-Befehl über den Inhalt einiger Register in Kenntnis setzen:

Das M-Flag bestimmt, ob die Akkumulatoren A und B 8 Bit (1) oder 16
Bit (0) breit sein sollen.  Analog entscheidet das Flag X über die
Breite der Indexregister X und Y.  AS benötigt die Information über
die Registerbreite bei unmittelbarer Adressierung (#<Konstante>),
ob das Argument 8 oder 16 Bit breit sein soll.

Der Speicher ist in 256 Bänke zu 64 Kbyte geteilt.  Da alle Register
im Prozessor nur maximal 16 Bit breit sind, kommen die obersten 8
Adreßbits aus 2 speziellen Bank-Registern: DT liefert die oberen 8
Bits bei Datenzugriffen, PG erweitert den 16-bittigen Programmzähler
auf 24 Bit.  Die vom 6502 her bekannte "Zero-Page" ist mittels des
16 Bit breiten Registers DPR frei innerhalb der ersten Bank ver-
schiebbar.  Trifft AS nun im Code auf eine Adresse (egal ob in einem
absoluten, indizierten oder indirekten Ausdruck), so versucht er der
Reihe nach folgende Adressierungsvarianten:

  1. Liegt die Adresse im Bereich von DPR..DPR+$ff?  Falls ja,
     Verwendung von direkter Adressierung mit 8-Bit-Adresse.
  2. Liegt die Adresse innerhalb der durch DT (bzw. PG für Sprungbe-
     fehle) festgelegten Seite?  Falls ja, Verwendung von absoluter
     Adressierung mit 16-Bit-Adresse.
  3. Falls nichts anderes hilft, Verwendung von langer Adressierung
     mit 24-Bit-Adresse.

Aus dieser Aufzählung folgt, daß das Wissen über die momentanen Werte
von DT,PG und DPR für die Funktion von AS essentiell ist; sind die
Angaben fehlerhaft, adressiert das Programm "in die Wüste".  Diese
Aufzählung geht übrigens davon aus, daß alle drei Adreßlängen ver-
fügbar sind; sollte dies einmal nicht der Fall sein, so wird die
Entscheidungskette entsprechen kürzer.

Die oben geschilderte, automatische Festlegung der Adreßlänge läßt
sich auch durch die Verwendung von Präfixen übersteuern.  Stellt
man der Adresse ein <, > oder >> ohne trennendes Leerzeichen voran,
so wird eine Adresse mit 1, 2 oder 3 Bytes benutzt, unabhängig davon,
ob dies die optimale Länge ist.  Benutzt man eine für diesen Befehl
nicht erlaubte oder für die Adresse zu kurze Länge, gibt es eine Feh-
lermeldung. 

Um die Portierung von 6502-Programmen zu erleichtern, verwendet AS
für Hexadezimalkonstanten die Motorola-Syntax und nicht die von
Mitsubishi übrigens für die 740er favorisierte Intel/IEEE-
Schreibweise.  Ich halte erstere auch für die bessere Schreibweise,
und die Entwickler des 65816 werden dies vermutlich ähnlich gesehen
haben (da man mittels der RELAXED-Anweisung auch Intel-Notation be-
nutzen kann, wird durch diese Entscheidung auch niemand festgelegt).
Ein für die Portierung ähnlich wichtiges Detail ist, daß der Akku-
mulator A als Ziel von Operationen auch weggelassen werden darf,
anstelle von LDA A,#0 darf also z.B. auch einfach LDA #0 geschrieben
werden.

Ein echtes Bonbon in dem Befehlssatz sind dagegen die Blocktransfer-
befehle MVN und MVP.  Etwas eigenartig ist nur die Adreßangabe: Bit
0..15 im Indexregister, Bit 16..23 im Befehl.  Bei AS gibt  man als
Argument für beide Speicherblöcke einfach die vollen Adressen an, AS
fischt sich dann die passenden Bits automatisch heraus.  Dies ist ein
feiner, aber wichtiger Unterschied zum Mitsubishi-Assembler, bei dem
man die oberen 8 Bit selber herausziehen muß.  Richtig bequem wird es
aber erst mit einem Makro im folgendem Stil:

mvpos   macro   src,dest,len
	if      MomCPU=$7700
	 lda    #len
	elseif
	 lda    #(len-1)
	endif
	ldx     #(src&$ffff)
	ldy     #(dest&$ffff)
	mvp     dest,src
	endm

Vorsicht, Falle: Steht im Akkumulator die Zahl n, so transferiert
der Mitsubishi n Bytes, der 65816 jedoch n+1 Bytes!

Sehr nett sind auch die Befehle PSH und PUL, mit deren Hilfe es
möglich ist, mit einem Befehl einen frei wählbaren Satz von Registern
auf dem Stack zu sichern oder von ihm zu laden.  Nach dem Mitsubishi-
Datenbuch[Mit16] muß die Angabe der Bitmasken immediate erfolgen, der
Programmierer soll also entweder alle Register<-->Bitstellen-Zuord-
nungen im Kopf behalten oder sich passende Symbole definieren. Hier
habe ich die Syntax eigenmächtig erweitert, um die Sache etwas ange-
nehmer zu machen: Es darf eine Liste angegeben werden, die sowohl
immediate-Ausdrücke als auch Registernamen enthalten darf.  Damit
sind z.B. die Anweisungen

	psh     #$0f

und

	psh     a,b,#$0c

und

	psh     a,b,x,y

äquivalent.  Da die immediate-Version weiterhin erlaubt ist, bleibt
AS hier "aufwärtskompatibel" zu den Mitsubishi-Assemblern.

Nicht ganz habe ich beim Mitsubishi-Assembler die Behandlung des PER-
Befehles verstanden: Mit diesem Befehl kann man eine 16-Bit-Variable
auf den Stack legen, deren Adresse relativ zum Programmzähler angege-
ben wird.  Es ist aus der Sicht des Programmierers also eine absolute
Adressierung einer Speicherzelle.  Nichtsdestotrotz verlangt Mitsu-
bishi eine immediate-Adressierung, und das Argument wird so in den
Code eingesetzt, wie es im Quelltext steht.  Die Differenz muß man sel-
ber ausrechnen, was mit der Einführung von symbolischen Assemblern ja
abgeschafft werden sollte...da ich aber auch ein bißchen "kompatibel"
denken muß, enthält AS eine Kompromißlösung: Wählt man immediate-
Adressierung (also mit Gartenzaun), so verhält sich AS wie das Origi-
nal von Mitsubishi.  Läßt man ihn jedoch weg, so berechnet AS die
Differenz vom Argument zum momentanen Programmzähler und setzt diese
ein.

Ähnlich sieht es beim PEI-Befehl aus, der den Inhalt einer 16-Bit-
Variablen auf der Zeropage auf den Stack legt:  Obwohl der Operand
eine Adresse ist, wird wieder immediate-Adressierung verlangt.  Hier
läßt AS schlicht beide Versionen zu (d.h. mit oder ohne Gartenzaun).


	4.9. M16
        --------

Die M16-Familie ist eine Familie äußerst komplexer CISC-Prozessoren
mit einem entsprechend komplizierten Befehlssatz.  Zu den Eigenschaf-
ten dieses Befehlssatzes gehört es unter anderem, daß bei Operationen
mit zwei Operanden beide Operanden verschiedene Längen haben dürfen.
Die bei Motorola übliche und von Mitsubishi übernommene Methode, die
Operandengröße als Attribut an den Befehl anzuhängen, mußte daher er-
weitert werden: Es ist erlaubt, auch an die Operanden selber Attri-
bute anzuhängen.  So wird im folgenden Beispiel

        mov     r0.b,r6.w

Register 0 8-bittig gelesen, auf 32 Bit vorzeichenerweitert und das
Ergebnis in Register 6 kopiert.  Da man in 9 von 10 Fällen aber von
diesen Möglichkeiten doch keinen Gebrauch macht, kann man weiterhin
die Operandengröße an den Befehl selber schreiben, z.B. so:

        mov.w   r0,r6

Beide Varianten dürfen auch gemischt verwendet werden, eine Größen-
angabe am Operanden übersteuert dann den "Default" am Befehl.  Eine
Ausnahme stellen Befehle mit zwei Operanden dar.   Bei diesen ist
der Default für den Quelloperanden die Größe des Zieloperanden. In
folgendem Beispiel

        mov.h   r0,r6.w

wird also auf Register 0 32-bittig zugegriffen, die Größenangabe
am Befehl wird überhaupt nicht mehr benutzt.  Finden sich überhaupt
keine Angaben zur Operandengröße, so wird Wort(w) verwendet.  Merke:
im Gegensatz zu den 68000ern bedeutet dies 32 und nicht 16 Bit!

Reichlich kompliziert sind auch die verketteten Adressierungsmodi;
dadurch, daß AS die Verteilung auf Kettenelemente automatisch vor-
nimmt, bleibt die Sache aber einigermaßen übersichtlich.  Die einzige
Eingriffsmöglichkeit, die bei AS gegeben ist (der Originalassembler
von Mitsubishi/Green Hills kann da noch etwas mehr), ist die expli-
zite Festlegung von Displacement-Längen mittels der Anhängsel :4,
:16 und :32.


	4.10. MCS-48
	------------

Der maximale Adreßraum dieser Prozessoren beträgt 4 Kbyte.  Dieser
Raum ist jedoch nicht linear organisiert (wie könnte das bei Intel
auch anders sein...), sondern in 2 Bänke zu 2 Kbyte geteilt.  Ein
Wechsel zwischen diesen beiden Bänken ist nur durch die Befehle CALL
und JMP erlaubt, indem vor dem Sprung das höchste Adreßbit mit den
Befehlen

  SEL MB0  bzw.  SEL MB1

vorgegeben wird.  Um den Wechsel zwischen den Bänken zu vereinfachen,
ist eine Automatik in den Befehlen JMP und CALL eingebaut, die einen
dieser beiden Befehle einfügt, falls die Adresse des Sprungbefehles
und das Sprungziel in unterschiedlichen Bänken liegen.  Die explizite
Benutzung der SEL MBx-Befehle sollte daher nicht notwendig sein (obwohl
sie möglich ist) und kann die Automatik auch durcheinanderbringen,
wie in dem folgenden Beispiel:

 000: SEL MB1
      JMP 200h

AS nimmt an, daß das MB-Flag auf 0 steht und fügt keinen SEL MB0-Be-
fehl vor dem Sprung ein, mit der Folge, daß der Prozessor zur Adresse
A00h springt.

Weiterhin ist zu beachten, daß ein Sprungbefehl unter Umständen nicht
2, sondern 3 Bytes lang ist und der Code entsprechend länger wird.


	4.11. MCS-51
	------------

Dem Assembler liegen die Dateien STDDEF51.INC bzw. 80C50X.INC bei, in
denen alle Bits und SFRs der Prozessoren 8051, 8052 und 80515 bzw.
80C501, 502 und 504 verzeichnet sind.  Je nach Einstellung des Prozes-
sortyps mit dem CPU-Befehl wird dabei die korrekte Untermenge einge-
bunden, die richtige Reihenfolge für den Anfang eines Programmes ist
daher

	CPU     <Prozessortyp>
	INCLUDE stddef51.inc   ,

sonst führen die MCS-51-Pseudobefehle in der Include-Datei zu
Fehlermeldungen.

Da der 8051 keinen Befehl kennt, um die Register 0..7 auf den Stack
zu legen, muß mit deren absoluten Adressen gearbeitet werden.  Diese
hängen aber von der momentan aktiven Registerbank ab.  Um diesem Miß-
stand etwas abzuhelfen, ist in den Include-Dateien das Makro USING de-
finiert, dem als Parameter die Symbole Bank0..Bank3 gegeben werden
können.  Das Makro belegt daraufhin die Symbole AR0..AR7 mit den
passenden absoluten Adressen der Register.  Dieses Makro sollte nach
jeder Bankumschaltung benutzt werden.  Es erzeugt selber keinen Code
zur Umschaltung!

Das Makro führt in der Variablen RegUsage gleichzeitig Buch über
alle jemals benutzten Registerbänke; Bit 0 entspricht Bank 0, Bit 1
der Bank 1 usw. .  Der Inhalt kann am Ende der Quelldatei z.B. mit
folgendem Codestück ausgegeben werden:

	irp             BANK,Bank0,Bank1,Bank2,Bank3
	 if             (RegUsage&(2^BANK))<>0
	  message       "Bank \{BANK} benutzt"
	 endif
	endm

Mit der Mehrpass-Fähigkeit ab Version 1.38 wurde es möglich, zusätz-
lich die Befehle JMP und CALL einzuführen.  Bei der Kodierung von
Sprüngen mit diesen Befehlen wählt AS je nach Adreßlage automatisch
die optimale Variante, d.h. SJMP/AJMP/LJMP für JMP und ACALL/LCALL
für CALL.  Es ist natürlich weiterhin möglich, die Varianten direkt
zu verwenden, um eine bestimmte Kodierung zu erzwingen.


	4.12. MCS-251
        -------------

Intel hat sich beim 80C251 ja bemüht, den Übergang für den Program-
mierer auf die neue Familie so weich wie möglich zu gestalten, was
darin gipfelt, daß alte Anwendungen ohne Neuübersetzung auf dem neuen
Prozessor ablaufen können.  Sobald man jedoch den erweiterten Be-
fehlssatz der 80C251 nutzen will, gilt es, einige Details zu beachten,
die sich als versteckte Fußangeln auftun.

An vorderster Stelle steht dabei die Tatsache, daß der 80C251 keinen
getrennten Bitadreßraum mehr hat.  Es sind nunmehr alle SFRs unab-
hängig von ihrer Adreßlage sowie die ersten 128 Speicherstellen des
internen RAMs bitadressierbar.  Möglich wird dies dadurch, daß die
Bitadressierung nicht mehr über einen zusätzlichen virtuellen Adreß-
raum, der andere Adreßräume überdeckt, erfolgt, sondern so wie bei
anderen Prozessoren auch durch eine zweidimensionale Adressierung, die
aus der Speicherstelle, die das Bit beinhaltet sowie der Bitstelle
im Byte besteht.  Dies bedeutet zum einen, daß bei einer Bitangabe
wie z.B. PSW.7 AS die Zerlegung der Teile links und rechts vom Punkt
selber vornimmt.  Es ist also nicht mehr nötig, mittels eines SFRB-
Befehls wie noch beim 8051 explizit 8 Bitsymbole zu erzeugen.  Dies
bedeutet zum anderen, daß es den SFRB-Befehl überhaupt nicht mehr
gibt.  Wird er in zu portierenden 8051-Programmen benutzt, kann er
durch einen einfachen SFR-Befehl ersetzt werden.

Weiterhin hat Intel in den unterschiedlichen Adreßräumen des 8051
gehörig aufgeräumt: Der Bereich des internen RAMs (DATA bzw. IDATA),
der XDATA-Bereich und er bisherige CODE-Bereich wurden in einem
einzigen, 16 Mbyte großen CODE-Bereich vereinigt.  Das interne RAM
beginnt bei Adresse 0, das interne ROM beginnt bei Adresse ff0000h,
dorthin muß also auch der Code mittels ORG hinverlagert werden.
Ausgelagert wurden dagegen die SFRs in einen eigenen Adreßraum (der
bei AS als IO-Segment definiert ist).  In diesem neuen Adreßraum
haben sie aber die gleichen Adressen wie beim 8051.  Der SFR-Befehl
kennt diesen Unterschied und legt mit ihm erzeugte Symbole je nach
Zielprozessor automatisch ins DATA- bzw. IO-Segment.  Da es keinen
Bit-Adreßraum mehr gibt, funktioniert der BIT-Befehl völlig anders:
anstelle einer linearen Adresse von 0 bis 255 beinhalten Bit-Symbole
jetzt in Bit 0..7 die Adresse, in Bit 24..26 die Bitstelle.  Damit ist
es jetzt leider nicht mehr so einfach möglich, Felder von Flags mit
symbolischen Namen anzulegen: Wo man beim 8051 noch z.B.

        segment bitdata

bit1	db	?
bit2	db	?

oder

defbit	macro	name
name	bit	cnt
cnt	set	cnt+1
	endm

schreiben konnte, hilft jetzt nur noch die zweite Variante weiter, z.B.
so:

adr	set	20h	; Startadresse Flags im internen RAM
bpos	set	0

defbit  macro   name
name    bit     adr.bpos
bpos    set     bpos+1
        if      bpos=8
bpos     set     0
adr      set     adr+1
        endif
        endm

Ein weiteres, kleines Detail: Da Intel als Kennzeichnung für den Carry
nun CY statt C bevorzugt, sollte man ein eventuell benutztes Symbol
umbenennen.  AS versteht aber auch weiterhin die alte Variante in den
Befehlen CLR, CPL, SETB, MOV, ANL, und ORL.  Gleiches gilt sinngemäß
für die dazugekommenen Register R8..R15, WR0..WR30, DR0..DR28, DR56,
DR60, DPX und SPX.

Intel möchte es gerne, daß man absolute Adressen in der Form XX:YYYY
schreibt, wobei XX eine 64K-Bank im Adreßraum angibt bzw. mit einem
S Adressen im IO-Raum kennzeichnet.  Wie man sich schon denken kann,
halte ich davon nicht allzu viel, weshalb man an allen Stellen Adres-
sen genauso gut linear angeben kann; lediglich um das S für die Kenn-
zeichnung von I/O-Adressen kommt man nicht herum, z.B. hier:

Carry   bit   s:0d0h.7

Ohne den Präfix würde AS die absolute Adresse in das Code-Segment
legen, und dort sind ja nur die ersten 128 Byte bitadressierbar...

Wie auch schon beim 8051 gibt es die generischen Befehle JMP und
CALL, die je nach Adreßlage automatisch die kürzeste Variante
einsetzen.  Während JMP aber die Variante mit 24 Bit mitberück-
sichtigt, tut CALL dies aus gutem Grund nicht: Der ECALL-Befehl legt
nämlich im Gegensatz zu ACALL und LCALL 3 Bytes auf den Stack, und
man hätte sonst einen CALL-Befehl, bei dem man nicht mehr genau
weiß, was er tut.  Bei JMP tritt diese Problem nicht auf.

Aus einer Sache bin ich nicht ganz schlau geworden: Der 80251 kann
auch immediate-Operanden auf den Stack legen, und zwar sowohl ein-
zelne Bytes als auch ganze Wörter.  Für beide Varianten ist aber
der gleiche Befehl PUSH vorgesehen - und woher soll bitte ein Assem-
bler bei einer Anweisung wie

        push #10

wissen, ob ein Byte oder ein Wort mit dem Wert 10 auf den Stack gelegt
werden soll?  Daher gilt im Augenblick die Regelung, daß PUSH grund-
sätzlich ein Byte ablegt; wer ein Wort ablegen will, schreibt einfach
PUSHW anstelle PUSH.

Noch ein gutgemeinter Ratschlag: Wer den erweiterten Befehlssatz des
80C251 nutzt, sollte den Prozessor auch tunlichst im Source-Modus
betreiben, sonst werden alle neuen Anweisungen ein Byte länger!  Um
die originären 8051-Anweisungem, die dafür im Source-Modus länger
werden, ist es nicht besonders schade: Sie werden entweder von AS
automatisch durch neue, leistungsfähigere ersetzt oder sind be-
treffen veraltete Adressierungsarten (indirekte Adressierung mit
8-Bit-Registern).


	4.13. 8086..V35
	---------------

Eigentlich hatte ich mir geschworen, die Segmentseuche der 8086er
aus diesem Assembler herauszuhalten.  Da aber nun eine Nachfrage
kam und Studenten flexiblere Menschen als die Entwickler dieses
Prozessors sind, findet sich ab sofort auch eine rudimentäre Unter-
stützung dieser Prozessoren in AS.  Unter "rudimentär" verstehe ich
dabei nicht, daß der Befehlssatz nicht vollständig abgedeckt wird,
sondern daß ich nicht den ganzen Wust an Pseudoanweisungen integriert
habe, die sich bei MASM, TASM & Co. finden.
AS ist auch nicht in erster Linie geschrieben worden, um PC-Programme
zu entwickeln (Gott bewahre, das hieße wirklich, das Rad neu zu er-
finden), sondern zur Programmentwicklung für Einplatinenrechner, die
eben unter anderem auch mit 8086ern bestückt sein können.

FÜr Unentwegte, die mit AS doch DOS-Programme schreiben wollen, eine
kleine Liste dessen, was zu beachten ist:

 - Es können nur COM-Programme erzeugt werden.
 - Verwenden Sie nur das CODE-Segment, und legen Sie auch alle Vari-
   ablen darin ab.
 - Alle Segmentregister werden von DOS auf das Codesegment vorini-
   tialisiert.  Ein ASSUME DS:DATA, SS:DATA am Programmanfang ist
   daher notwendig.
 - DOS lädt den Code ab Adresse 100h.  Ein ORG auf diese Adresse ist
   daher zwingend.
 - Die Umwandlung in eine Binärdatei erfolgt mit P2BIN (s.u.), wobei
   als Adreßbereich $-$ anzugeben ist.

AS unterstützt für diese Prozessoren nur ein Small-Programmiermodell,
d.h. EIN Codesegment mit maximal 64 Kbyte und ein ebenfalls höchstens
64 KByte großes Datensegment mit (für COM-Dateien uninitialisierten)
Daten. Zwischen diesen beiden Segmenten kann mit dem SEGMENT-Befehl
hin-und hergeschaltet werden.  Aus dieser Tatsache folgert, daß
Sprünge immer intrasegmentär sind, sofern sie sich auf Adressen im
Codesegment beziehen.  Sofern weite Sprünge doch einmal erforderlich
sein sollten, können sie mit CALLF und JMPF und einer Speicheradresse
oder einen Segment:Offset-Wert als Argument erreicht werden.

Ein weiteres großes Problem dieser Prozessoren ist deren Assembler-
syntax, deren genaue Bedeutung nur aus dem Zusammenhang erkennbar
ist.  So kann im folgenden Beispiel je nach Symboltyp sowohl un-
mittelbare als auch absolute Adressierung gemeint sein:

    mov ax,wert

Bei AS ist immer absolute Adressierung gemeint, wenn um den Operanden
keine eckigen Klammern stehen.  Soll z.B. die Adresse oder der Inhalt
einer Variablen geladen werden, so ergeben sich folgende Unterschie-
de:

Assembler         Adresse             Inhalt
\hline
MASM         mov ax,offset vari   mov ax,vari
             lea ax,vari          mov ax,[vari]
             lea ax,[vari]

AS           mov ax,vari          mov ax,[vari]
             lea ax,[vari]

Der Assembler prüft bei Symbolen, ob sie im Datensegment liegen und
versucht, automatisch einen passenden Segmentpräfix einzufügen, z.B.
falls ohne CS-Präfix auf Symbole im Code zugegriffen wird.  Dieser
Mechanismus kann jedoch nur funktionieren, falls der ASSUME-Befehl
(siehe dort) korrekt angewendet wurde.

Die Intel-Syntax verlangt eine Abspeicherung, ob an einem Symbol
Bytes oder Wörter abgelegt wurden.  AS nimmt diese Typisierung nur
vor, falls in der gleichen Zeile wie das Label ein DB oder DW steht.
Für alle anderen Fälle muß mit den Operatoren WORD PTR, BYTE PTR usw.
explizit angegeben werden, um was für eine Operandengröße es sich
handelt.  Solange ein Register an der Operation beteiligt ist, kann
auf diese Kennzeichnung verzichtet werden, da durch den Registernamen
die Operandengröße eindeutig bestimmt ist.

Der Koprozessor in 8086-Systemen wird üblicherweise durch den TEST-
Eingang des Prozessors synchronisiert, indem selbiger mit dem BUSY-
Ausgang des Koprozessors verbunden wird.  AS unterstützt dieses
Handshaking, indem vor jedem 8087-Befehl automatisch ein WAIT-Befehl
eingefügt wird.  Ist dies aus irgendwelchen Gründen unerwünscht
(z.B. während der Initialisierung), so muß im Opcode hinter dem F
ein N eingefügt werden; aus

   FINIT
   FSTSW  [vari]

wird so z.B.

   FNINIT
   FNSTSW [vari]

Diese Variante ist bei ALLEN Koprozessorbefehlen erlaubt.


        4.14. 8X30x
        -----------

Die Prozessoren dieser Reihe sind auf eine einfache Manipulation von
Bitgruppen auf Peripherieadressen optimiert worden.  Um mit solchen
Bitgruppen auch symbolisch umgehen zu können, existieren die Befehle
LIV und RIV, mit denen einer solchen Bitgruppe ein symbolischer Name
zugewiesen wird.  Diese Befehle arbeiten ähnlich wie EQU, benötigen
aber drei Parameter:

 1. die Adresse der peripheren Speicherzelle, in der sich die Bit-
    gruppe befindet (0..255);
 2. die Bitnummer des ersten Bits in der Gruppe (0..7);
 3. die Länge der Gruppe in Bits (1..8).

ACHTUNG!  Der 8X30x unterstützt keine Bitgruppen, die über mehrere
Speicherstellen hinausreichen, so daß je nach Startposition der
Wertebereich für die Länge eingeschränkt sein kann.  AS nimmt hier
KEINE Prüfung vor, man bekommt lediglich zur Laufzeit merkwürdige
Ergebnisse!

Im Maschinencode drücken sich Länge und Position durch ein 3-Bit-Feld
im Instruktionswort sowie ein passende Registernummer (LIVx bzw.
RIVx) aus.  Bei der Verwendung eines symbolischen Objektes wird AS
diese Felder automatisch richtig besetzen, es ist aber auch erlaubt,
die Länge als dritten Operanden explizit anzugeben, wenn man nicht
mit symbolischen Busobjekten arbeitet.  Trifft AS auf eine Längenanga-
be trotz eines symbolischen Operanden, so vergleicht er beide Längen
und gibt eine Fehlermeldung bei Ungleichheit aus (das gleiche passiert
übrigens auch, wenn man bei einem MOVE-Befehl zwei symbolische Operan-
den mit unterschiedlicher Länge benutzt - die Instruktion hat einfach
nur ein Längenfeld...).

Neben den eigentlichen Maschinenbefehlen des 8X30x implementiert AS
noch ähnlich wie das 'Vorbild' MCCAP einige Pseudoinstruktionen, die
als eingebaute Makros ausgeführt sind:

 - NOP ist eine Kurzschreibweise für MOVE AUX,AUX
 - HALT ist eine Kurzschreibweise für JMP *
 - XML ii ist eine Kurzschreibweise für XMIT ii,R12 (nur 8X305)
 - XMR ii ist eine Kurzschreibweise für XMIT ii,R13 (nur 8X305)
 - SEL <busobj> ist eine Kurzschreibweise für XMIT <adr>,IVL/IVR,
   führt also die notwendige Vorselektion durch, um <busobj> an-
   sprechen zu können.

Die bei MCCAP ebenfalls noch vorhandenen CALL- und RTN-Instruktionen
sind mangels ausreichender Dokumentation momentan nicht implementiert.
Das gleiche gilt für einen Satz an Pseudoinstruktionen zur Datenabla-
ge.  Kommt Zeit, kommt Rat...


	4.15. XA
        --------

Ähnlich wie sein Vorgänger MCS/51, jedoch im Unterschied zu seinem 
"Konkurrenten" MCS/251 besitzt der Philips XA einen getrennten Bit-
adreßraum, d.h. alle mit Bitbefehlen manipulierbaren Bits haben eine
bestimmte, eindimensionale Adresse, die in den Maschinenbefehlen auch
so abgelegt wird.  Die naheliegende Möglichkeit, diesen dritten 
Adreßraum (neben Code und Daten) auch so in AS anzubieten, habe ich 
nicht nutzen können, und zwar aus dem Grund, daß ein Teil der Bit-
adressen im Gegensatz zum MCS/51 nicht mehr eindeutig ist: Bits mit
den Adressen 256 bis 511 bezeichnen Bits der Speicherzellen 20h..3fh
aus dem aktuellen Datensegment.  Dies bedeutet aber, daß diese Adressen
je nach Situation unterschiedliche Bits ansprechen können - ein defi-
nieren von Bits mit Hilfe von DC-Befehlen, was durch ein extra Segment
möglich geworden wäre, würde also nicht übermäßig viel Sinn ergeben.
Zur Definition einzelner, symbolisch ansprechbarer Bits steht aber 
nach wie vor der BIT-Befehl zur Verfügung, mit dem beliebige Bitadres-
sen (Register, RAM, SFR) definiert werden können.  Für Bitadressen im 
internen RAM wird auch die 64K-Bank-Adresse gespeichert, so daß AS 
Zugriffe überprüfen kann, sofern das DS-Register korrekt mit ASSUME
vorbesetzt wurde.

Der XA benutzt die gleichen Pseudobefehle zur Konstantenablage wie
die 68000-Familie.  Dies bedeutet dummerweise auch, daß defaultmäßig
die Anzahl abgelegter Bytes auf eine gerade Zahl aufgerundet wird. 
Beim XA sind gerade Adressen nicht so zwingend, deshalb ist ein 
PADDING OFF am Anfang schon fast obligatorisch...

Nichts drehen kann man dagegen an den Bemühungen von AS, potentielle
Sprungziele (also Zeilen im Code mit Label) auf gerade Adressen auszu-
richten.  Dies macht AS genauso wie andere XA-Assembler auch durch
Einfügen von NOPs vor dem fraglichen Befehl.  


	4.16. Z80UNDOC
        --------------

Da es von Zilog naturgemäß keine Syntaxvorgaben für die undokumen-
tierten Befehle gibt und wohl auch nicht jeder den kompletten Satz
kennt, ist es vielleicht sinnvoll, diese Befehle hier kurz aufzu-
zählen:

Wie auch beim Z380 ist es möglich, die Byte-Hälften von IX und IY
einzeln anzusprechen.  Im einzelnen sind dies folgende Varianten:

 INC Rx              LD R,Rx             LD  Rx,n
 DEC Rx              LD Rx,R             LD  Rx,Ry
 ADD/ADC/SUB/SBC/AND/XOR/OR/CP A,Rx

Dabei stehen Rx bzw. Ry für IXL, IXU, IYL oder IYU.  Zu beachten
ist jedoch, daß in der LD Rx,Ry-Variante beide Register aus dem
gleichen Indexregister stammen müssen.

Die Kodierung von Schiebebefehlen besitzt noch eine undefinierte
Bitkombination, die als SLIA-Befehl zugänglich ist.  SLIA
funktioniert wie SLA, es wird jedoch eine Eins und nicht eine Null
in Bit 0 eingeschoben.  Dieser Befehl kann, wie alle anderen
Schiebebefehle auch, noch in einer weiteren Variante geschrieben
werden:

 SLIA R,(XY+d)

Dabei steht R für ein beliebiges 8-Bit-Register (aber nicht eine
Indexregisterhälfte...), und (XY+d) für eine normale indexregister-
relative Adressierung.  Das Ergebnis dieser Operation ist, daß das
Schiebeergebnis zusätzlich ins Register geladen wird.  Dies funk-
tioniert auch bei den RES- und SET-Befehlen:

 SET/RES R,n,(XY+d)

Des weiteren gibt es noch zwei versteckte I/O-Befehle:

 IN (C) bzw. TSTI
 OUT (C),0

Deren Funktionsweise sollte klar sein.  ACHTUNG! Es gibt keine
Garantie dafür, daß alle Z80-Masken alle diese Befehle beherrschen,
und die Z80-Nachfolger lösen zuverlässig Traps aus.  Anwendung
daher auf eigene Gefahr...


	4.17. Z380
	----------

Da dieser Prozessor als Enkel des wohl immer noch beliebtesten
8-Bit-Prozessors konzipiert wurde, war es bei der Entwicklung
unabdingbar, daß dieser bestehende Z80-Programme ohne Änderung
ausführen kann (natürlich geringfügig schneller, etwa um den
Faktor 10...).  Die erweiterten Fähigkeiten können daher nach
einem Reset mit zwei Flags zugeschaltet werden, die XM (eXtended
Mode, d.h. 32- statt 16-Bit-Adreßraum) und LW (long word mode,
d.h. 32- statt 16- Bit-Operanden) heißen.  Deren Stand muß man
AS über die Befehle EXTMODE und LWORDMODE mitteilen, damit
Adressen und Konstantenwerte gegen die korrekten Obergrenzen
geprüft werden.  Die Umschaltung zwischen 32- und 16-Bit-Befehlen
bewirkt natürlich nur bei solchen Befehlen etwas, die auch in
einer 32-Bit-Version existieren; beim Z380 sind das momentan
leider nur Lade- und Speicherbefehle, die ganze Aritmetik kann
nur 16-bittig ausgeführt werden.  Hier sollte Zilog wohl noch
einmal etwas nachbessern, sonst kann man den Z380 selbst beim
besten Willen nur als "16-Bit-Prozessor mit 32-Bit-Erweiterungen"
bezeichnen...

Kompliziert wird die Sache dadurch, daß die mit LW eingestellte
Operandengröße für einzelne Befehle mit den Präfixen DDIR W
und DDIR LW übersteuert werden kann.  AS merkt sich das Auf-
treten solcher Befehle und schaltet dann für den nächsten
Prozessorbefehl automatisch mit um.  Andere DDIR-Varianten
als W und LW sollte man übrigens nie explizit verwenden, da
AS bei zu langen Operanden diese automatisch einsetzt, und das
könnte zu Verwirrungen führen.  Die Automatik geht übrigens
so weit, daß in der Befehlsfolge

	DDIR    LW
	LD      BC,12345678h

automatisch der erforderliche IW-Präfix mit in die vorange-
hende Anweisung hineingezogen wird, effektiv wird also der
Code

	DDIR    LW,IW
	LD      BC,12345678h

erzeugt.  Der im ersten Schritt erzeugte Code für DDIR LW
wird verworfen, was an einem R im Listing zu erkennen ist.


	4.18. TLCS-900(L)
	-----------------

Diese Prozessoren können in zwei Betriebsarten laufen, einmal im
Minimum-Modus, der weitgehende Z80- und TLCS90-Quellcodekompati-
bilität bietet, und zum anderen im Maximum-Modus, in dem der
Prozessor erst seine wahren Qualitäten entfaltet.  Die Hauptunter-
schiede zwischen den beiden Betriebsarten sind:

 - Breite der Register WA,BC,DE und HL: 16 oder 32 Bit;
 - Anzahl der Registerbanks: 8 oder 4;
 - Programmadreßraum: 64 Kbyte oder 16 Mbyte;
 - Breite von Rücksprungadressen: 16 oder 32 Bit.

Damit AS gegen die richtigen Grenzen prüfen kann, muß man ihm zu
Anfang mit dem Befehl MAXMODE (siehe dort) mitteilen, in welcher
Betriebsart der Code ausgeführt werden wird; Voreinstellung ist
der Minimum-Modus.

Je nach Betriebsart müssen demzufolge auch die 16- oder 32-Bit-
Versionen der Bankregister zur Adressierung verwendet werden, d.h.
WA, BC, DE und HL im Minimum-Modus sowie XWA, XBC, XDE und XHL im
Maximum-Modus.  Die Register XIX..XIZ und XSP sind IMMER 32 Bit
breit und müssen zur Adressierung auch immer in dieser Form ver-
wendet werden; hier muß bestehender Z80-Code also auf jeden Fall
angepaßt werden (neben der Tatsache, daß es gar keinen I/O-Adreß-
raum mehr gibt und alle I/O-Register memory-mapped sind...).

Die von Toshiba gewählte Syntax ist in der Hinsicht etwas unglück-
lich, als daß zur Anwahl der vorherigen Registerbank ein Hochkomma
(') benutzt wird.  Dieses Zeichen wird von den prozessorunabhängigen
Teilen von AS bereits zur Kennzeichnung von Zeichenkonstanten be-
nutzt.  Im Befehl

  ld wa',wa

erkennt AS z.B. nicht das Komma zur Parametertrennung.  Dieses
Problem kann man aber umgehen, indem man ein umgekehrtes Hochkomma
(`) verwendet, z.B.

  ld wa`,wa

Toshiba liefert für die TLCS-900-Reihe selber einen Assembler
(TAS900), der sich in einigen Punkten von AS unterscheidet:

    Symbolkonventionen

 - TAS900 unterscheidet Symbolnamen nur auf den ersten 32
   Zeichen.  AS dagegen speichert Symbolnamen immer in der vollen
   Länge (bis 255 Zeichen) und unterscheidet auch auf dieser Länge.

 - Unter TAS900 können Integerkonstanten sowohl in C-Notation (mit
   vorangestellter 0 für oktal bzw. 0x für hexadezimal) als auch in
   normaler Intel-Notation geschrieben werden.  AS unterstützt in der
   Default-Einstellung NUR die Intel-Notation. Mit dem RELAXED-Befehl
   bekommt man (unter anderem) auch die C-Notation.

 - AS macht keinen Unterschied zwischen Groß- und Kleinschreibung,
   TAS900 hingegen unterscheidet Groß-und Kleinbuchstaben in
   Symbolnamen.  Dieses Verhalten erhält man bei AS erst, wenn man
   die -u-Kommandozeilenoption benutzt.

    Syntax

AS ist bei vielen Befehlen in der Syntaxprüfung weniger streng als
TAS900, bei einigen weicht er (sehr) geringfügig ab.  Diese Erwei-
terungen bzw. Änderungen dienen teilweise der leichteren Portierung
von bestehendem Z80-Code, teilweise einer Schreiberleichterung und
teilweise einer besseren Orthogonalität der Assemblersyntax:

 - Bei den Befehlen LDA, JP und CALL verlangt TAS, daß Adreßausdrücke
   wie XIX+5 nicht geklammert sein dürfen, wie es sonst üblich ist.
   AS verlangt im Sinne der Orthogonalität für LDA dagegen immer eine
   Klammerung, bei JP und CALL ist sie dagegen für einfache, absolute
   Adressen optional.

 - Bei den bedingten Befehlen JP, CALL, JR und SCC stellt AS es dem
   Programmierer frei, die Default-Bedingung "T" (= true) als ersten
   Parameter anzugeben oder nicht.  TAS900 hingegen erlaubt es nur,
   die Default-Bedingung implizit zu benutzen (also z.B. jp (xix+5)
   anstelle von jp t,(xix+5)).

 - AS erlaubt beim EX-Befehl auch Operandenkombinationen, die zwar
   nicht direkt im User's Manual [Tosh900] genannt werden, aber durch
   Vertauschung auf eine genannte zurückgeführt werden können.  Kom-
   binationen wie EX f`,f oder EX wa,(xhl) werden damit möglich.
   TAS900 hingegen läßt nur die "reine Lehre" zu.

 - AS erlaubt, bei den Befehlen INC und DEC die Angabe des Inkrements
   oder Dekrements wegzulassen, wenn dies 1 ist.  Unter TAS900 dagegen
   muß auch eine 1 hingeschrieben werden.

 - Ähnlich verhält es sich bei allen Schiebebefehlen: Ist der zu ver-
   schiebende Operand ein Register, so verlangt TAS900, daß auch eine
   Schiebeamplitude von 1 ausgeschrieben werden muß; ist dagegen eine
   Speicherstelle der Operand, so ist die Schiebezahl (hardwarebe-
   dingt) immer 1 und darf auch nicht hingeschrieben werden.  Unter AS
   dagegen ist die Schiebezahl 1 immer optional und auch für alle Ope-
   randentypen zulässig.

    Makroprozessor

Der Makroprozessor wird TAS900 als externes Programm vorgeschaltet und
besteht aus zwei Komponenten: einem C-artigen Präprozessor und einer
speziellen Makrosprache (MPL), die an höhere Programmiersprachen erin-
nert.  Der Makroprozessor von AS dagegen orientiert sich an "klassi-
schen" Makroassemblern wie dem M80 oder MASM (beides Programme von
Microsoft).  Er ist fester Bestandteil des Programmes.

    Ausgabeformat

TAS900 erzeugt relokatiblen Code, so daß sich mehrere, getrennt assem-
blierte Teile zu einem Programm zusammenbinden lassen.  AS hingegen
erzeugt direkt absoluten Maschinencode, der nicht linkbar ist.  An ei-
ne Erweiterung ist (vorläufig) nicht gedacht.

    Pseudoanweisungen

Bedingt durch den fehlenden Linker fehlen in AS eine ganze Reihe von
für relokatiblen Code erforderlichen Pseudoanweisungen, die TAS900
implementiert.  In gleicher Weise wie bei TAS900 sind folgende Anwei-
sungen vorhanden:

   EQU, DB, DW, ORG, ALIGN, END, TITLE, SAVE, RESTORE,

wobei die beiden letzteren einen erweiterten Funktionsumfang haben.
Einige weitere TAS900-Pseudobefehle lassen sich durch äquivalente AS-
Befehle ersetzen:


TAS900         AS                   Bedeutung/Funktion

DL <Daten>     DD <Daten>           Speicher in Langworten belegen
DSB <Zahl>     DB <Zahl> DUP (?)    Speicher byteweise reservieren
DSW <Zahl>     DW <Zahl> DUP (?)    Speicher wortweise reservieren
DSD <Zahl>     DD <Zahl> DUP (?)    Speicher langwortweise reservieren
$MIN[IMUM]     MAXMODE OFF          folgender Code im Minimum-Modus
$MAX[IMUM]     MAXMODE ON           folgender Code im Maximum-Modus
$SYS[TEM]      SUPMODE ON           folgender Code im System-Modus
$NOR[MAL]      SUPMODE OFF          folgender Code im User-Modus
$NOLIST        LISTING OFF          Assemblerlisting ausschalten
$LIST          LISTING ON           Assemblerlisting einschalten
$EJECT         NEWPAGE              neue Seite im Listing beginnen

Von Toshiba existieren zwei Versionen des Prozessorkerns, wobei die
L-Variante eine "Sparversion" darstellt.  Zwischen TLCS-900 und
TLCS-900L macht AS folgende Unterschiede:

 - Die Befehle MAX und NORMAL sind für die L-Version nicht erlaubt,
   der MIN-Befehl ist für die Vollversion gesperrt.
 - Die L-Version kennt den Normal-Stapelzeiger XNSP/NSP nicht, dafür
   das Steuerregister INTNEST.

Die Befehle SUPMODE und MAXMODE werden nicht beeinflußt, ebenso nicht
deren initiale Einstellung OFF.  Die Tatsache, daß die L-Version im
Maximum-Modus startet und keinen Normal-Modus kennt, muß also vom
Programmierer berücksichtigt werden.  AS zeigt sich jedoch insofern
kulant gegenüber der L-Variante, als daß Warnungen wegen privilegier-
ter Anweisungen im L-Modus unterdrückt werden.


	4.19. TLCS-90
	-------------

Vielleicht fragt sich der eine oder andere, ob bei mir die Reihenfolge
durcheinandergekommen ist, es gab ja von Toshiba zuerst den 90er als
"aufgebohrten Z80" und danach den 900er als 16-Bit-Version.  Nun, ich
bin einfach über den 900er zum 90er gekommen (Danke, Oliver!).  Die
beiden Familien sind sich sehr artverwandt, nicht nur was ihre Syntax
angeht, sondern auch ihre Architektur.  Die Hinweise für den 90er sind
daher eine Untermenge derer für den 900er: Da Schieben, Inkrementieren
und Dekrementieren hier nur um eins möglich sind, braucht und darf die-
se eins auch nicht als erstes Argument hingeschrieben werden.  Bei
den Befehlen LDA, JP und CALL möchte Toshiba wieder die Klammern um
Speicheroperanden weglassen, bei AS müssen sie aber aus Gründen der
Orthogonalität gesetzt werden (der tiefere Grund ist natürlich, daß
ich mir damit eine Sonderabfrage im Parser gespart habe, aber das sagt
man nicht so laut).

Die TLCS-90er besitzen bereits prinzipiell einen Adreßraum von 1
Mbyte, dieser Raum erschließt sich aber nur bei Datenzugriffen über
die Indexregister.  AS verzichtet daher auf eine Berücksichtigung
der Bankregister und begrenzt den Adreßraum für Code auf 64 Kbyte.
Da der Bereich jenseits aber sowieso nur über indirekte Adressierung
erreichbar ist, sollte dies keine allzu große Einschränkung darstel-
len.

	4.20. TLCS-870
	--------------

Schon wieder Toshiba...diese Firma ist im Augenblick wirklich sehr
produktiv!  Speziell dieser Sproß der Familie (Toshibas Mikrokon-
troller sind sich ja alle in Binärkodierung und Programmiermodell
recht ähnlich) scheint auf den 8051-Markt abzuzielen: Die Methode,
Bitstellen durch einen Punkt getrennt an den Adreßausdruck anzu-
hängen, hatte ja beim 8051 ihren Ursprung, führt jetzt aber auch
genau zu den Problemen, die ich beim 8051 geahnt hatte: Der Punkt
ist jetzt einerseits legales Zeichen in Symbolnamen, andererseits
aber auch Teil der Adreßsyntax, d.h. AS muß Adresse und Bitstelle
trennen und einzeln weiterverarbeiten.  Diesen Interessenkonflikt
habe ich vorerst so gelöst, daß der Ausdruck von HINTEN an nach
Punkten durchsucht wird und so der letzte Punkt als Trenner gilt,
eventuelle weitere Punkte werden dem Symbolnamen zugerechnet.
Es gilt weiterhin die flehentliche Bitte, im eigenen Interesse auf
Punkte in Symbolnamen zu verzichten, sie führen nur zu Verwir-
rungen:

   LD    CF,A.7         ; Akku Bit 7 nach Carry
   LD	 C,A.7          ; Konstante A.7 nach Akku


	4.21. TLCS-47
	-------------

Mit dieser 4-Bit-Prozessorfamilie dürfte wohl das unter Ende dessen
erreicht sein, was AS unterstützen kann.  Neben dem ASSUME-Befehl
für das Datenbankregister (siehe dort) ist eigentlich nur ein Detail
erwähnenswert: im Daten- und I/O-Segment werden keine Bytes, sondern
Nibbles reserviert (eben 4-Bitter...).  Die Sache funktioniert ähnlich
wie das Bitdatensegment beim 8051, wo ein DB ja nur einzelne Bit re-
serviert, nur daß es hier eben Nibbles sind.

Toshiba hat für diese Prozessorfamilie einen "erweiterten Befehlssatz"
in Makroform definiert, um das Arbeiten mit diesem doch recht be-
schränkten Befehlssatz zu erleichtern.  Im Fall von AS ist er in der
Datei STDDEF47.INC definiert.  Einige Befehle, deren makromäßige
Realisierung nicht möglich war, sind allerdings "eingebaut" und stehen
daher auch ohne die Include-Datei zur Verfügung:

 - der B-Befehl, der die jeweils optimale Version des Sprungbefehls
   (BSS, BS oder BSL) automatisch wählt;
 - LD in der Variante HL mit immediate;
 - ROLC und RORC mit einer Schiebeamplitude >1.


	4.22. TLCS-9000
	---------------

Hier ist es zum ersten Mal passiert, daß ich einen Prozessor in AS
implementiert habe, der zu diesem Zeitpunkt noch gar nicht auf dem
Markt war. Toshiba hat sich leider auch vorläufig dazu entschieden,
diesen Prozessor "auf Eis" zu legen, bis auf weiteres wird es also
auch kein Silizium geben.  Das hat natürlich zur Folge, daß dieser
Teil

 1. ein "Paper-Design" ist, d.h. noch nicht praktisch getestet
    wurde und
 2. Die Unterlagen, die ich zum 9000er hatte [Tosh9000], noch vor-
    läufig waren, also noch nicht bis ins letzte Klarheit lieferten.

Fehler in diesem Teil sind also durchaus noch möglich (und werden
natürlich bereinigt, wenn es denn einmal gehen sollte!).  Zumindest
die Handvoll Beispiele in [Tosh9000] werden aber richtig übersetzt.


	4.23. 29xxx
        -----------

Wie schon beim ASSUME-Befehl beschrieben, kann AS mit der Kenntnis
über den Inhalt des RBP-Registers feststellen, ob im User-Modus
auf gesperrte Register zugegriffen wird.  Diese Fähigkeit
beschränkt sich natürlich auf direkte Zugriffe (also nicht, wenn
die Register IPA...IPC benutzt werden), und sie hat noch einen
weiteren Haken: da lokale Register (also solche mit Nummern>127)
relativ zum Stackpointer adressiert werden, die Bits in RBP sich
aber immer auf absolute Nummern beziehen, wird die Prüfung für
lokale Register NICHT durchgeführt.  Eine Erweiterung auf lokale
Register würde bedingen, daß AS zu jedem Zeitpunkt den absoluten
Wert von SP kennt, und das würde spätestens bei rekursiven Unter-
programmen scheitern...


	4.24. 80C16x
	------------

Wie in der Erklärung des ASSUME-Befehls schon erläutert, versucht
AS, dem Programmierer die Tatsache, daß der Prozessor mehr physi-
kalischen als logischen Speicher hat, soweit als möglich zu ver-
bergen.  Beachten Sie aber, daß die DPP-Register NUR Datenzugriffe
betreffen und auch dort nur absolute Adressierung, also weder
indirekte noch indizierte Zugriffe, da AS ja nicht wissen kann,
wie die berechnete Adresse zur Laufzeit aussehen wird...
Bei Codezugriffen arbeitet die Paging-Einheit leider nicht, man
muß also explizit mit langen oder kurzen CALLs, JMPs oder RETs
arbeiten.  Zumindest bei den "universellen" Befehlen CALL und JMP
wählt AS automatisch die kürzeste Form, aber spätestens beim RET
sollte man wissen, woher der Aufruf kam.  Prinzipiell verlangen
JMPS und CALLS dabei, daß man Segment und Adresse getrennt angibt,
AS ist jedoch so geschrieben, daß der eine Adresse selber zerlegen
kann, z.B.

   jmps   12345h

anstelle von

   jmps   1,2345h

Leider sind nicht alle Effekte der chipinternen Instruktions-Pipeline
versteckt: Werden CP (Registerbankadresse), SP (Stack) oder eines
der Paging-Register verändert, so steht der neue Wert noch nicht
für den nächsten Befehl zur Verfügung.  AS versucht, solche Situa-
tionen zu erkennen und gibt im Falle eines Falles eine Warnung aus.
Aber auch diese Mimik greift nur bei direkten Zugriffen.

Mit BIT definierte Bits werden intern in einem 12-Bit-Wort abgelegt,
wobei die Bitadresse in Bit 4..11 liegt und die Bitnummer in den
unteren vier Bits.  Diese Anordnung erlaubt es, das nächsthöhere
bzw. nächstniedrigere Bit durch Inkrementieren bzw. Dekrementieren
anzusprechen.  Bei expliziten Bitangaben mit Punkt funktioniert das
aber nicht über Wortgrenzen hinaus.  So erzeugt folgender Ausdruck
eine Wertebereichsüberschreitung:

   bclr   r5.15+1

Hier muß ein BIT her:

msb bit   r5.15
    .
    .
    bclr  msb+1

Für den 80C167/165/163 ist der SFR-Bereich verdoppelt worden; daß ein
Bit im zweiten Teil liegt, wird durch ein gesetztes Bit 12 vermerkt.
Leider hatte Siemens bei der Definition des 80C166 nicht vorausgese-
hen, daß 256 SFRs (davon 128 bitadressierbar) für Nachfolgechips nicht
reichen würden. So wäre es unmöglich, den zweiten SFR-Bereich von
F000H.. F1DFH mit kurzen Adressen oder Bitbefehlen zu erreichen, hät-
ten die Entwickler nicht einen Umschaltbefehl eingebaut:

  EXTR #n

Dieser Befehl bewirkt, daß für die nächsten n Befehle (0<n<5) anstelle
des normalen der erweiterte SFR-Bereich angesprochen werden kann.  AS
erzeugt bei diesm Befehl nicht nur den passenden Code, sondern setzt
intern ein Flag, daß für die nächsten n Befehle nur Zugriffe auf den
erweiterten SFR-Bereich zuläßt.  Da dürfen natürlich keine Sprünge
dabei sein... Bits aus beiden Bereichen lassen sich natürlich jederzeit
definieren, ebenso sind komplette Register aus beiden SFR-Bereichen
jederzeit mit absoluter Adressierung erreichbar.  Nur die kurze bzw.
Bitadressierung geht immer nur abwechselnd, Zuwiderhandlungen werden
mit einer Fehlermeldung geahndet.

Ähnlich sieht es mit den Präfixen für absolute bzw. indirekte Adres-
sierung aus: Da aber sowohl Argument des Präfixes als auch der
Adreßausdruck nicht immer zur Übersetzungszeit bestimmbar sind, sind
die Prüfungsmöglichkeiten durch AS sehr eingeschränkt, weshalb er es
auch bei Warnungen beläßt...im einzelnen sieht das folgendermaßen aus:

 - feste Vorgabe einer 64K-Bank mittels EXTS oder EXTSR: Im Adreß-
   ausdruck werden direkt die unteren 16 Bit der Zieladresse einge-
   setzt.  Haben sowohl Präfix als auch Befehl einen konstanten
   Operanden, so wird überprüft, ob Präfixargument und Bit 16..23 der
   Zieladresse identisch sind.

 - feste Vorgabe einer 16K-Seite mittels EXTP oder EXTPR: Im Adreß-
   ausdruck werden direkt die unteren 14 Bit der Zieladresse einge-
   setzt.  Bit 14 und 15 bleiben konstant 0, da sie in diesem Modus
   nicht vom Prozessor ausgewertet werden.  Haben sowohl Präfix als
   auch Befehl einen konstanten Operanden, so wird überprüft, ob
   Präfixargument und Bit 14..23 der Zieladresse identisch sind.

Damit das etwas klarer wird, ein Beispiel (die DPP-Register haben
die Reset-Vorbelegung) :

	extp	#7,#1		; Bereich von 112K..128K
	mov	r0,1cdefh	; ergibt Adresse 0defh im Code
	mov	r0,1cdefh	; -->Warnung
	exts	#1,#1		; Bereich von 64K..128K
	mov	r0,1cdefh	; ergibt Adresse 0cdefh im Code
	mov	r0,1cdefh	; -->Warnung


	4.25. PIC16C5x/16C8x
	--------------------

Ähnlich wie die MCS-48-Familie teilen auch die PICs ihren Programm-
speicher in mehrere Bänke auf, da im Opcode nicht genügend Platz für
die vollständige Adresse war.  AS verwendet für die Befehle CALL und
GOTO die gleiche Automatik, d.h. setzt die PA-Bits im Statuswort ent-
sprechend Start- und Zieladresse.  Im Gegensatz zu den 48ern ist die-
ses Verfahren hier aber noch deutlich problematischer:

  1. Die Befehle sind nicht mehr nur ein Wort, sondern bis zu drei
     Worten lang, können also nicht mehr in jedem Fall mit einem
     bedingten Sprung übergangen werden.
  2. Es ist möglich, daß der Programmzähler beim normalen Programm-
     fortgang eine Seitengrenze überschreitet.  Die vom Assembler
     angenommene Belegung der PA-Bits stimmt dann nicht mehr mit der
     Realität überein.

Bei den Befehlen, die das Register W mit einem anderen Register ver-
knüpfen, muß normalerweise als zweiter Parameter angegeben werden, ob
das Ergebnis in W oder im Register abgelegt werden soll.  Bei diesem
Assembler ist es erlaubt, den zweiten Parameter wegzulassen.  Welches
Ziel dann angenommen werden soll, hängt vom Typ des Befehls ab: bei
unären Operationen wird defaultmäßig das Ergebnis zurück ins Register
gelegt. Diese Befehle sind:

    COMF, DECF, DECFSZ, INCF, INCFSZ, RLF, RRF und SWAPF

Die anderen Befehle betrachten W defaultmäßig als Akkumulator, zu dem
ein Register verknüpft wird:

    ADDWF, ANDWF, IORWF, MOVF, SUBWF und XORWF

Die von Microchip vorgegebene Schreibweise für Literale ist ziemlich
abstrus und erinnert an die auf IBM 360/370-Systemen übliche Schreib-
weise (Grüße aus Neandertal...).  Um nicht noch einen Zweig in den
Parser einfügen zu müssen, sind bei AS Konstanten in Motorola-Syntax
zu schreiben (wahlweise auch Intel oder C im RELAXED-Modus).


	4.26. PIC 17C4x
	---------------

Für diese Prozessoren gelten im wesentlichen die gleichen Hinweise wie
für ihre kleinen Brüder, mit zwei Ausnahmen: Die zugehörige Include-
Datei enthält nur Registerdefinitionen, und die Probleme bei Sprungbe-
fehlen sind deutlich kleiner.  Aus der Reihe fällt nur LCALL, der einen
16-Bit-Sprung erlaubt.  Dieser wird mit folgendem "Makro" übersetzt:

   MOVLW <Adr15..8>
   MOWF  3
   LCALL <Adr0..7>


	4.27. ST62xx
	------------

Diese Prozessoren können das Code-ROM seitenweise in den Datenbereich
einblenden.  Weil ich nicht die ganze Mimik des ASSUME-Befehles hier
wiederkäuen möchte, verweise ich auf das entsprechende Kapitel, in dem
steht, wie man mit diesem Befehl einigermaßen unfallfrei Konstanten
aus dem ROM lesen kann.

Bei nähererer Betrachtung des Befehlssatzes fallen einige eingebaute
"Makros" auf.  Hier die Liste der Befehle, die mir aufgefallen sind
(es gibt aber wohl noch mehr...):


    Befehl    in Wirklichkeit

    CLR A     SUB A,A
    SLA A     ADD A,A
    CLR adr   LDI adr,0
    NOP       JRZ PC+1

Insbesondere der letztere Fall verblüfft doch etwas...Leider fehlen
aber einige Anweisungen wirklich.  So gibt es z.B. zwar einen AND-
Befehl, aber kein OR...von XOR gar nicht zu reden.  In der Datei
STDDEF62.INC finden sich deshalb neben den Adressen der SFRs noch
einige Makros zur Abhilfe.
			  
Der Original-Assembler AST6 von SGS-Thomson verwendet teilweise andere
Pseudobefehle als AS.  Außer der Tatsache, daß AS Pseudobefehle nicht
mit einem vorangestellten Punkt kennzeichnet, sind folgende Befehle
identisch:

  ASCII, ASCIZ, BLOCK, BYTE, END, ENDM, EQU, ERROR, MACRO,
  ORG, TITLE, WARNING

Folgende AST6-Befehle haben analoge in AS:

     AST6            AS                 Bedeutung/Funktion

     .DISPLAY        MESSAGE            Meldung ausgeben
     .EJECT          NEWPAGE            neue Seite im Listing
     .ELSE           ELSEIF             bed. Assemblierung
     .ENDC           ENDIF              bed. Assemblierung
     .IFC            IF...              bed. Assemblierung
     .INPUT          INCLUDE            Include-Datei einbinden
     .LIST           LISTING, MACEXP    Listing-Einstellung
     .PL             PAGE               Seitenlänge Listing
     .ROMSIZE        CPU                Zielprozessor einstellen
     .VERS
     .SET            EVAL               Variablen neu setzen


        4.28. ST7
        ---------

In [ST7Man] ist der '.w'-Postfix für 16-Bit-Adressen nur für speicher-
indirekte Operanden definiert, um zu vermerken, daß auf einer Zeropa-
geadresse eine 16-bittige Adresse liegt; AS unterstützt ihn jedoch zu-
sätzlich auch für absolute Adressen oder Displacements in indizierter
Adressierung, um trotz eines nur 8 Bit langen Wertes (0..255) ein
16-bittiges Displacement zu erzeugen.


        4.29. ST9
        ---------

Die Bitadressierungsmöglichkeiten des ST9 sind relativ eingeschränkt: 
Mit Ausnahme des BTSET-Befehls ist es nur möglich, auf Bits innerhalb
des aktuellen Arbeitsregistersatzes zuzugreifen.  Eine Bit-Adresse
sieht also folgendermaßen aus:

  rn.[!]b

wobei ! eine optionale Invertierung eines Quelloperanden bedeutet.  
Wird ein Bit symbolisch mittels des BIT-Befehles definiert, so wird 
die Registernummer im Symbolwert in Bit 7..4, die Bitnummer in Bit 
3..1 und eine optionale Invertierung in Bit 0 vermerkt.  AS unter-
scheidet direkte und symbolische Bitangaben am Fehlen eines Punktes,
der Name eines Bitsymboles darf also keinen Punkt enthalten, obwohl
sie an sich zulässig wären.  Es ist auch zulässig, bei der Referen-
zierung von Bitsymbolen diese zu nachträglich zu invertieren:

bit2    bit     r5.3
        .
        .
        bld	r0.0,!bit2

Auf diese Weise ist es auch möglich, eine inverse Definition nach-
träglich wieder aufzuheben.

Bitdefinitionen finden sich in großer Zahl in der Include-Datei 
REGST9.INC, in der die Register- und Bitnamen aller On-Chip-Peri-
pherie beschrieben sind.  Beachten Sie jedoch, daß deren Nutzung
nur möglich ist, wenn die Arbeitsregisterbank vorher auch auf diese
Register ausgerichtet wurde!

Im Gegensatz zu der zum AST9 von SGS-Thomson gehörenden Definitions-
datei sind für AS die Namen der Peripherieregister nur als allgemeine
Registernamen definiert (R...), nicht auch noch als Arbeitsregister
(r...).  Dies ist so, weil AS Geschwindigkeitsgründen keine Alias-
namen für Register definieren kann.


	4.30. 6804
	----------

Eigentlich habe ich diesen Prozessor ja nur eingebaut, um mich über
das seltsame Gebaren von SGS-Thomson zu beklagen: Als ich das 6804-
Datenbuch zum ersten Mal in die Hand bekam, fühlte ich mich ob des
etwas "unvollständigen" Befehlssatzes und der eingebauten Makros
spontan an die ST62-Serie vom gleichen Hersteller erinnert.  Ein
genauerer Vergleich der Opcodes förderte erstaunliches zu Tage:
Ein 6804-Opcode ergibt sich durch Spiegelung aller Bits im entspre-
chenden ST62-OpCode!  Thomson hat hier also offensichtlich etwas
Prozessorkern-Recycling betrieben...wogegen ja auch nichts einzu-
wenden wäre, wenn nicht so eine Verschleierungstaktik betrieben
werden würde: andere Peripherie, Motorola- anstelle Zilog-Syntax
sowie das häßliche Detail, in Opcodes enthaltene Argumente (z.B.
Bitfelder mit Displacements) NICHT zu drehen.  Letzterer Punkt
hat mich auch nach längerem Überlegen dazu bewogen, den 6804 doch
in AS aufzunehmen.  Ich wage übrigens keine Spekulationen, welche
Abteilung bei Thomson von welcher abgekupfert hat...

Im Gegensatz zur ST62-Version enthält die Include-Datei für den
6804 keine Makros, die die Lücken im Befehlssatz etwas "auspol-
stern" sollen.  Dies überlasse ich dem geneigten Leser als
Fingerübung!


	4.31. TMS3201x
	--------------

Offensichtlich ist es Ehrgeiz jedes Prozessorherstellers, seine
eigene Notation für Hexadezimalkonstanten zu erfinden.  Texas Instru-
ments war bei diesen Prozessoren besonders originell: ein vorange-
stelltes >-Zeichen!  Die Übernahme dieses Formates in AS hätte zu
schweren Konflikten mit den Vergleichs-und Schiebeoperatoren von AS im
Formelparser geführt.  Ich habe mich deshalb für die Intel-Notation
entschieden, zu der sich TI bei der 340x0-Serie und den 3201x-Nachfol-
gern ja dann auch durchgerungen hat...

Leider hat das Instruktionswort dieser Prozessoren nicht genügend
Bits, um bei direkter Adressierung alle 8 Bits zu enthalten, weshalb
der Datenadreßraum logisch in 2 Bänke zu 128 Wörtern gespalten ist.
AS verwaltet diesen als ein durchgehendes Segment von 256 Wörtern und
löscht bei direkten Zugriffen automatisch das Bit 7 (Ausnahme: Befehl
SST, der nur in die obere Bank schreiben kann). Der Programmierer ist
dafür erforderlich, daß das Bank-Bit stets den richtigen Wert hat!

Ein weiterer, nur sehr versteckt im Datenbuch stehender Hinweis: Die
SUBC-Anweisung benötigt zur Ausführung intern mehr als einen Takt, das
Steuerwerk arbeitet jedoch schon an dem nächsten Befehl weiter. Im auf
ein SUBC folgenden Befehl darf deshalb nicht auf den Akkumulator zuge-
griffen werden.  AS nimmt hier keine Prüfung vor!


	4.32. TMS320C2x
	---------------

Da ich nicht selber diesen Codegenerator geschrieben habe (was nichts
an seiner Qualität mindert), kann ich nur kurz hier umreißen, wieso
es Befehle gibt, bei denen ein vorangestelltes Label als untypisiert,
d.h. keinem Adreßraum zugeordnet, gespeichert wird: Der 20er der
TMS-Reihe kennt sowohl ein 64 Kbyte großes Code- als auch Datenseg-
ment.  Je nach externer Beschaltung kann man dabei Code- und Datenbe-
reiche überlappen, um z.B. Konstanten im Codebereich abzulegen und
auf diese als Daten zuzugreifen (Ablage im Code ist notwendig, weil
ältere AS-Versionen davon ausgehen, daß ein Datensegment aus RAM
besteht, das in einem Standalone-System nach dem Einschalten keinen
definierten Inhalt hat und verweigern in Segmenten außer Code deshalb
die Ablage von Daten). Ohne dieses Feature würde AS nun jeden Zugriff
auf die abgelegten Daten mit einer Warnung ("Symbol aus falschem
Segment") quittieren. Im einzelnen erzeugen folgende Pseudobefehle
untypisierte Labels:

  BSS, STRING, RSTRING, BYTE, WORD , LONG, FLOAT
  DOUBLE, EFLOAT, BFLOAT und TFLOAT

Sollten doch einmal typisierte Labels gewünscht sein, so kann man
sich behelfen, indem man das Label in eine getrennte Zeile vor dem
Pseudobefehl schreibt.  Umgekehrt kann man einen der anderen Pseudo-
befehle mit einem typenlosen Label versehen, indem man vor dem Befehl
das Label mit

<Name>  EQU     $

definiert.


	4.33. TMS320C3x
	---------------

Die größten Magenschmerzen bei diesem Prozessor hat mir die Syntax
paralleler Befehle bereitet, die auf zwei Zeilen verteilt werden,
wobei beide Befehle an sich auch sequentiell ausgeführt werden können.
Deshalb erzeugt AS zuerst den Code für die einzelne erste Operation,
wenn er dann in der zweiten Zeile erkennt, daß eine parallele Awei-
sung vorliegt, wird der zuerst erzeugte Code durch den neuen ersetzt.
Im Listing kann man dies daran erkennen, daß der Programmzähler
nicht weiterläuft und in der zweiten Zeile anstelle eines Doppel-
punktes ein "R" vor dem erzeugten Code steht.

Bezüglich der doppelten senkrechten Striche und ihrer Position in der
Zeile ist man nicht ganz so flexibel wie beim TI-Assembler: Entweder
man schreibt sie anstelle eines Labels (d.h. in der ersten Spalte)
oder direkt vor den zweiten Befehl ohne Leerzeichen, sonst bekommt
der Zeilenparser von AS Probleme...


        4.34. TMS9900
        -------------

Wie bei den meisten älteren Prozessorfamilien auch, hatte TI seiner-
zeit ein eigenes Format zur Schreibweise von Hexadezimal- und Binär-
konstanten verwendet, anstelle deren AS die normale, heute auch bei
TI gebräuchliche Intel-Notation verwendet.  

Leider war die Dokumentation, die ich zur Verfügung hatte [TI9900], 
eine Beschreibung, die die Assemblersyntax nur am Rande streifte.
Ich habe daher an der einen oder anderen Stelle etwas raten müssen...
zum Beispiel bei der Operandenreihenfolge: Da die meisten anderen TI-
Mikrokontroller die Quelle als ersten Operanden schreiben, habe ich 
dieses auch für dem 9900 übernommen.  Weiterhin wechselt TI mit der
Registerbezeichnung zwischen Rx und WRx...vorerst ist beides zuge-
lassen.


        4.35. TMS70Cxx
        --------------

Diese Prozessorreihe gehört noch zu den älteren, von TI entwickelten
Reihen, und deswegen benutzt TI in ihren eigenen Assemblern noch die
herstellereigene Syntax für hexadezimale und binäre Konstanten (voran-
gestelltes < bzw. ?).  Da das in AS aber so nicht machbar ist, wird
defaultmäßig die Intel-Syntax verwendet.  Auf diese ist Texas bei den
Nachfolgern dieser Familie, nämlich den 370ern auch umgestiegen.  Beim
genaueren Betrachten des Maschinenbefehlssatzes stellt man fest, daß 
ca. 80% der 7000er-Befehle binär aufwärtskompatibel sind, und auch die 
Assemblersyntax ist fast gleich - aber eben nur fast.  Bei der Erwei-
terung des 7000er-Befehlssatzes hat TI nämlich auch gleich die Chance
genutzt, die Syntax etwas zu vereinheitlichen und zu vereinfachen.
Ich habe mich bemüht, einen Teil dieser Änderungen auch in die 7000er
Syntax einfließen zu lassen:

- Anstelle eines Prozentzeichens zur Kennzeichnung von immediate-
  Adressierung darf auch das allgemein bekanntere Doppelkreuz ver-
  wendet werden.

- Wenn bei den Befehlen AND, BTJO, BTJZ, MOV, OR und XOR eine Port-
  adresse (P...) als Quelle oder Ziel benutzt wird, ist es nicht
  notwendig, die Mnemonic-Form mit explizit angehängtem P zu benut-
  zen - die allgemeine Form reicht genauso aus.  

- Der vorangestelle Klammeraffe für absolute oder B-indizierte 
  Adressierung darf weggelassen werden.

- Anstelle des CMPA-Befehls darf auch einfach CMP mit A als Ziel
  benutzt werden.

- Anstelle LDA oder STA darf auch einfach der MOV-Befehl mit A 
  als Ziel bzw. Quelle benutzt werden.

- Anstelle des MOVD-Befehls darf auch MOVW benutzt werden.

- Anstelle von RETS oder RETI darf auch verkürzt RTS bzw. RTI
  geschrieben werden.

- TSTA bzw. TSTB dürfen auch als TST A bzw. TST B geschrieben 
  werden.

- XCHB B ist als Alias für TSTB zugelassen.

Wichtig - diese Varianten sind nur beim TMS70Cxx zugelassen - ent-
sprechende 7000er-Varianten sind bei den 370ern nicht erlaubt!


	4.36. TMS370xxx
	---------------

Obwohl diese Prozessoren keine speziellen Befehle zur Bitmanipulation
besitzen, wird mit Hilfe des Assemblers und des DBIT-Befehles (siehe
dort) die Illusion erzeugt, als ob man einzelne Bits manipulieren
würde.  Dazu wird beim DBIT-Befehl eine Adresse mit einer Bitposition
zusammengefaßt und in einem Symbol abgelegt, das man dann als Argu-
ment für die Pseudobefehle SBIT0, SBIT1, CMPBIT, JBIT0 und JBIT1
verwenden kann.  Diese werden in die Befehle OR, AND, XOR, BTJZ und
BTJO mit einer passenden Bitmaske übersetzt.

An diesen Bit-Symbolen ist überhaupt nichts geheimnisvolles, es han-
delt sich um schlichte Integerwerte, in deren unterer Hälfte die
Speicheradresse und in deren oberer Hälfte die Bitstelle gespeichert
wird.  Man könnte sich seine Symbole also auch ohne weiteres selber
basteln:

defbit  macro   name,bit,adr
name	equ	adr+(bit<<16)
	endm

aber mit dieser Schreibweise erreicht man nicht den EQU-artigen Stil,
den Texas vorgegeben hat (d.h. das zu definierende Symbol steht an-
stelle eines Labels).  ACHTUNG!  Obwohl DBIT eine beliebige Adresse
zuläßt, können für die Pseudobefehle nur die Adressen 0..255 und
1000h..10ffh verwendet werden, eine absolute Adressierungsart kennt
der Prozessor an dieser Stelle nicht...


        4.37. MSP430
        ------------

Der MSP430 wurde als RISC-Prozessor mit minimalem Stromverbrauch 
konzipiert.  Aus diesem Grund ist der Satz von Befehlen, die der
Prozessor in Hardware versteht, auf das absolut notwendige reduziert 
worden (da RISC-Prozessoren keinen Mikrocode besitzen, muß jeder 
Befehl mit zusätzlichem Silizium implementiert werden und erhöht so
den Stromverbrauch).  Eine Reihe von Befehlen, die bei anderen 
Prozessoren in Hardware gegossen wurden, werden beim MSP durch eine 
Emulation mit anderen Befehlen realisiert.  Bei AS finden sich diese 
Befehle mit in der Datei REGMSP.INC.  Wer diese Datei nicht einbindet, 
wird bei über der Hälfte der insgesamt von TI definierten Befehle 
Fehlermeldungen bekommen!!


	4.38. COP8 & SC/MP
        ------------------

Leider Gottes hat sich auch National dazu entschieden, als Schreib-
weise für nichtdezimale Integer-Konstanten die von IBM-Großrechnern
bekannte (und von mir vielgehaßte) Variante X'... zu benutzen.  Das
geht natürlich (wie immer) nicht.  Zum Glück scheint der ASMCOP aber
auch die C-Variante zuzulassen, und diese wurde deshalb der Default
für die COPs und den SC/MP...


        4.39. 75K0
        ----------

Wie bei einigen anderen Prozessoren auch, kennt die Assemblersprache
der 75er von NEC Pseudo-Bitoperanden, d.h. man kann einem Symbol
eine Kombination aus Adresse und Bitnummer zuweisen, die dann bei
bitorientierten Befehlen anstelle direkter Ausdrücke verwendet werden
kann.  Die drei folgenden Befehle erzeugen daher z.B. identischen
Code:

ADM	sfr     0fd8h
SOC     bit     ADM.3

        skt     0fd8h.3
        skt     ADM.3
        skt     SOC

AS unterscheidet direkte und symbolische Bitzugriffe an einem
bei Symbolen fehlenden Punkt; Punkte in Symbolnamen darf man daher
nicht verwenden, da es sonst zu Mißverständnissen bei der Auflösung
kommt.

Die Ablage von Bitsymbolen orientiert sich dabei weitgehend an der
binären Kodierung, die die Prozessorhardware selber verwendet:  Es
werden 16 Bit belegt, und es existieren ein "kurzes" und ein "langes"
Format.  Das kurze Format kann folgende Varianten aufnehmen:

 - direkte Zugriffe auf die Bereiche 0FBxH und 0FFxH
 - indirekte Zugriffe der Form Adr.@L (0FC0H <= Adr <= 0FFFH)
 - indirekte Zugriffe der Form @H+d4.bit

Das obere Byte ist auf 0 gesetzt, das untere Byte enthält den gemäß
[NEC75] kodierten Bitausdruck.  Das lange Format kennt im Gegensatz
dazu nur direkte Adressierung, kann dafür aber (korrekte Einstel-
lungen von MBS und MBE vorausgesetzt) den ganzen Adreßraum abdek-
ken.  Bei langen Ausdrücken stehen im unteren Byte Bit 7..0 der
Adresse, in Bit 8 und 9 die Bitstelle sowie in Bit 10 und 11
konstant 01.  Letztere ermöglichen es, langes und kurzes Format
einfach durch einen Vergleich des oberen Bytes gegen Null zu
unterscheiden.  Die Bits 12..15 enthalten Bit 8..11 der Adresse;
sie werden zwar nicht zur Generierung des Kodes benötigt, müssen
jedoch gespeichert werden, da eine Prüfung auf ein korrektes Banking
erst bei der Verwendung des Symboles erfolgen kann.


	4.40. 78K0
        ----------

NEC benutzt in seinen Datenbüchern zur Kennzeichnung der Zugriffsweise
auf absolute Adressen verschiedene Schreibweisen:

 - absolut kurz: kein Präfix
 - absolut lang: vorangestelltes !
 - PC-relativ: vorangestelltes $

Bei AS sind diese Präfixe nur notwendig, falls man eine bestimmte 
Adressierung erzwingen will und der Befehl verschiedene Varianten
zuläßt.  Setzt man keinen Präfix, so wählt AS automatisch die kür-
zeste Variante.  Es dürfte daher in der Praxis sehr selten notwendig
sein, einen Präfix zu verwenden.


	5. Dateiformate
	===============

In diesem Kapitel sollen die Formate von von AS erzeugten Dateien
beschrieben werden, deren Format sich nicht direkt erschließt.

        5.1. Code-Dateien
        -----------------

Das vom Assembler ausgegebene Codedatenformat muß in der Lage sein,
die Codeteile für unterschiedliche Prozessoren voneinander zu tren-
nen, und sieht daher etwas anders aus als gängige Formate.  Obwohl
dem Assembler Tools zur Bearbeitung der Codedateien beiliegen, hal-
te ich es für guten Stil, das Format hier kurz offenzulegen:

Sofern in der Datei Mehrbyte-Integers gespeichert sind, werden sie
im Intelformat abgelegt, d.h. mit dem LSB zuerst.  Diese Regel gilt
bereits für das 16-Bit-Kennungswort mit dem Wert $1489, d.h. jede
Codedatei beginnt mit den Bytes $89/$14.

Danach folgt eine Reihe beliebig vieler "Records", wobei ein Record
entweder ein zusammenhängendes Teilfeld des Codes darstellt oder be-
stimmte Zusatzinformationen enthält.  Eine Datei kann auch ohne 
Umschaltung des Prozessortyps mehrere Code-Records enthalten, wenn
Code- oder Konstantenbereiche durch reservierte (und nicht zu initia-
lisierende) Speicherbereiche unterbrochen werden.  Der Assembler ver-
sucht auf diese Weise, die Datei nicht länger als nötig werden zu las-
sen.

Allen Records ist gemein ist ein Header-Byte, das den Typ des Records
und die damit folgenden Datenstrukturen festlegt.  In einer Pascal-
artigen Form läßt sich die Record-Struktur folgendermaßen beschreiben:

FileRecord = RECORD CASE Header:Byte OF
              $00:(Creator:ARRAY[] OF Char);
              $01..
              $7f:(StartAdr : LongInt;
                   Length   : Word;
                   Data     : ARRAY[0..Length-1] OF Byte);
              $80:(EntryPoint:LongInt);
              $81:(Header   : Byte;
                   Segment  : Byte;
                   Gran     : Byte;
                   StartAdr : LongInt;
                   Length   : Word;
                   Data     : ARRAY[0..Length-1] OF Byte);
             END

Was in dieser Schreibweise nicht ganz zum Ausdruck kommt, ist, daß
die Länge von Datenfeldern variabel ist und von Length abhängt.

Ein Record mit einem Header-Byte von $81 ist ein Record, der Code
oder Daten aus beliebigen Segmenten beinhalten kann.  Das erste
Byte (Header) gibt an, für welche Prozessorfamilie die folgenden
Daten bzw. der folgende  Code bestimmt ist:  

    Header  Familie               Header  Familie

    $01     680x0, 683xx          $05     PowerPC
    $09     DSP56000              $11     65xx/MELPS-740
    $12     MELPS-4500            $13     M16
    $14     M16C                  $19     65816/MELPS-7700      
    $21     MCS-48                $29     29xxx                 
    $31     MCS-(2)51             $32     ST9
    $33     ST7                   $39     MCS-96/196/296
    $3a     8X30x                 $3b     AVR
    $3c     XA                    $41     8080/8085
    $42     8086..V35             $48     TMS9900
    $49     TMS370xxx             $4a     MSP430
    $4c     80C166/167            $51     Z80/180/380
    $52     TLCS-900              $53     TLCS-90
    $54     TLCS-870              $55     TLCS-47
    $56     TLCS-9000             $61     6800, 6301 oder 6811
    $62     6805/HC08             $63     6809
    $64     6804                  $65     68HC16
    $66     68HC12                $68     H8/300(H)
    $69     H8/500                $6c     SH7000
    $6e     SC/MP                 $6f     COP8
    $70     PIC16C8x              $71     PIC16C5x
    $72     PIC17C4x              $73     TMS7000
    $74     TMS3201x              $75     TMS320C2x
    $76     TMS320C3x             $77     TMS320C5x
    $78     ST62xx                $79     Z8
    $7a     µPD78(C)10            $7b     75K0
    $7c     78K0

Das Segment-Feld gibt an, in welchen Adreßraum des Prozessors der 
folgende Code gehört.  Dabei gilt folgende Zuordnung:

    Nummer  Segment               Nummer  Segment

    $00     <undefiniert>         $01     CODE
    $02     DATA                  $03     IDATA
    $04     XDATA                 $05     YDATA
    $06     BDATA                 $07     IO
    $08     REG

Das Gran-Feld gibt die "Granularität" des Codes an, d.h. die Größe 
der kleinsten, adressierbaren Einheit im folgenden Datensatz.  Dieser
Wert ist eine Funktion von Prozessortyp und Segment und ein wichtiges
Detail für die Interpretation der beiden folgenden Felder, die Start-
adresse und Länge angeben: Während die Startadresse sich auf die 
Granularität bezieht, erfolgt die Längenangabe immer in Bytes!  Wäre
die Startadresse z.B. $300 und die Länge 12, so wäre die sich ergeben-
de Endadresse bei einer Granularität von 1 $30b, bei einer Granulari-
tät von z.B. 4 jedoch $303!  Andere Granularitäten als eins sind sel-
ten und treten in erster Linie bei Signalprozessoren auf, die nicht 
auf Einzelbyteverarbeitung ausgelegt sind deren Datenspeicher z.B.
aus 64kWorten zu 16 Bit besteht (DSP56K).  Der sich ergebende Spei-
cherplatz beträgt dann zwar 128 KByte, er ist aber in 2^16 Worten
organisiert, die mit Adressen von 0,1,2,...65535 adressiert werden!

Die Startadresse ist immer 32-bittig, unabhängig von der Adreßbreite
der jeweiligen Prozessorfamilie.  Im Gegensatz dazu ist die Längenan-
gabe nur 16 Bit lang, ein Record kann also maximal (4+4+2+(64K-1)) = 
65545 Byte lang werden.

Daten-Records mit den Header-Bytes $01..$7f stellen eine Kurzschreib-
weise dar und stellen die Abwärtskompatibilität mit früheren Defini-
tionen des Dateiformats her: Das Header-Byte gibt direkt den Pro-
zessortyp gemäß der ersten Tabelle an, das Zielsegment ist auf CODE
festgelegt und die Granularität ergibt sich aus dem Prozessortyp, auf-
gerundet auf eine Zweierpotenz von Bytes.  AS bevorzugt diese Records, 
wenn Daten bzw. Code für das CODE-Segment anstehen.

Der Record mit dem Typ-Byte $80 legt den Einsprungpunkt fest, d.h.
die Adresse, an der mit der Ausführung des Programmes begonnen werden
soll.  Ein solcher Record ist das Ergebnis einer END-Anweisung mit
einer entsprechenden Adresse als Argument.

Der letzte Record in der Datei trägt das Header-Byte $00 und besitzt
als einziges Datenfeld einen String, dessen Ende durch das Dateiende
definiert ist.  Dieser String spezifiziert, von welchem Programm diese
Datei erzeugt wurde und hat keine weitere Bedeutung.


        5.2. Debug-Dateien
        ------------------

Debug-Dateien können optional von AS erzeugt werden und liefern
nachgeschalteten Werkzeugen wie Disassemblern oder Debuggern für
diese wichtige Informationen.  Diese Informationen teilen sich in
drei Gruppen:

 - Symboltabelle

 - Speicherberlegung, auf Sektionen verteilt

 - Maschinenadressen von Quellzeilen

Letzterer Teil findet sich zuerst in der Datei.  Ein einzelner Ein-
trag in dieser Liste besteht aus zwei, von einem Doppelpunkt getrenn-
ten Zahlen:

 <Zeilennummer>:<Adresse>

Ein solcher Eintrag besagt, daß der aus einer bestimmten Quellcodezei-
le erzeugte Maschinencode auf der angegebenen Adresse (hexadezimal) zu
liegen kam.  Mit einer solchen Information kann ein Debugger beim
Durchsteppen des Programmes die entsprechenden Quellcodezeilen anzei-
gen.  Da ein Programm aber auch aus mehreren Include-Dateien bestehen
kann, und viele Prozessoren mehr als nur einen Adreßraum besitzen (von
dem zugegebenermaßen nur in einem Code liegt), müssen die oben be-
schriebenen Einträge sortiert werden.  AS tut dies in zwei Stufen: Das
primäre Sortierkriterium ist das Zielsegment, innerhalb dieser Segmen-
te wird noch einmal nach Dateien sortiert.  Einzelne Abschnitte werden
dabei durch durch spezielle Zeilen der Form

Segment <Segmentname>

bzw. 

File <Dateiname>

getrennt.

Die Symboltabelle folgt der Quellzeileninformation und ist wieder pri-
mär nach den Segmenten geordnet, aus denen die Symbole stammen.  Im
Gegensatz zur Zeileninformation kommt hier allerdings auch der Ab-
schnitt NOTHING hinzu, der die Symbole beinhaltet, die keinem speziel-
len Adreßraum zugeordnet sind (z.B. Symbole, die einfach mit EQU defi-
niert wurden).  Die Einleitung eines Abschnittes in der Symboltabelle
erfolgt mit einer Zeile der Form

Symbols in Segment <Segmentname>   .

Innerhalb eines Abschnittes sind die Symbole nach Namen sortiert, und
ein Symboleintrag belegt genau eine Zeile.  Eine solche Zeile besteht
wiederum aus 5 Feldern, die durch jeweils mindestens ein Leerzeichen
getrennt sind:

Das erste Feld ist der Name des Symbols selber, eventuell erweitert um
eine in eckigen Klammern eingeschlossene Sektionsnummer, die den Gül-
tigkeitsbereich des Symbols einschränkt.  Die zweite Spalte bezeichnet
den Typ des Symbols: Int für Integerzahlen, Float für Gleitkommazahlen
und String für Zeichenketten.  Die dritte Zeile schließlich beinhaltet
den eigentliche Wert des Symbols.  Falls das Symbol eine Zeichenkette
beinhaltet, ist es notwendig, Steuer- und Leerzeichen mit einer geson-
derten Notation zu kennzeichnen, damit ein im String enthaltenes Leer-
zeichen nicht eventuell als Trennzeichen zur nächsten Spalte interpre-
tiert werden kann.  AS bedient sich dazu der bereits der in Assembler-
quellen üblichen Schreibweise, den ASCII-Zahlenwert mit einem führen-
den Backslash (\) einzusetzen.  Aus dem String

 Dies ist ein Test

wird also z.B.

 Dies\032ist\032ein\032Test

Die Zahlenangabe ist immer dezimal und dreistellig, und der Backslash
selber wird ebenfalls in dieser Schreibweise kodiert.

Das vierte Feld gibt - falls vorhanden - die Größe der Datenstruktur
an, die an der durch das Symbol gekennzeichneten Adresse abgelegt ist.
Ein Debugger kann eine solche Information z.B. nutzen, um symbolisch
angesprochene Variablen direkt in der korrekten Länge aufzulisten.
Hat AS keine Informationen über die Symbolgröße, so steht in diesem
Feld eine schlichte -1.

Das fünfte und letzte Feld gibt schlußendlich durch eine 0 oder 1 an,
ob das Symbol während der Assemblierung jemals referenziert wurde. 
Ein Programm, daß die Symboltabelle liest, kann auf diese Weise z.B.
nicht benutzte Symbole automatisch verwerfen, da sie beim folgenden
Debugging oder der Disassemblierung mit hoher Wahrscheinlichkeit auch
nicht benötigt werden.

Der dritte Abschnitt in einer Debug-Datei beschreibt die im Programm
benutzten Sektionen näher.  Eine solche Beschreibung ist erforder-
lich, da Sektionen den Gültigkeitsbereich von Symbolen einschränken
können.  Je nach momentanem Stand des Programmzählers kann z.B. ein
symbolischer Debugger einzelne Symboldefinitionen für eine Rücküber-
setzung nicht nutzen oder muß Prioritäten bei der Symbolnutzung be-
achten.  Die Definition einer Sektion beginnt mit einer Zeile der
Form

Info for Section nn ssss pp     ,

wobei nn die Nummer der Sektion angibt (die Nummer, die als Postfix
für Symbolnamen in der Symboltabelle genutzt wird), ssss der Name der
Sektion ist und pp die Nummer der Vatersektion darstellt.  Letztere
Information benötigt ein Rückübersetzer, um sich bei der Auffindung
eines Symbols für einen Zahlenwert ausgehend von der aktuellen Sek-
tion im Baum bis zur Wurzel "durchhangeln" kann, bis ein passendes
Symbol gefunden wird.  Auf diese Zeile folgt eine Reihe weiterer
Zeilen, die den von dieser Sektion belegten Code-Bereich beschreiben. 
Jeder einzelne Eintrag (genau einer pro Zeile) beschreibt entweder
eine einzelne Adresse oder einen durch zwei Grenzwerte beschriebenen
Bereich (Trennung von Anfangs-und Endwert durch ein Minuszeichen). 
Die Grenzen sind dabei "inklusive", d.h. die Grenzen gehören auch zu
dem Bereich.  Wichtig ist, daß ein einer Sektion zugehöriger Bereich
nicht nochmals für ihre Vatersektionen aufgeführt wird (eine Ausnahme
ist natürlich, wenn Bereiche absichtlich mehrfach belegt werden, aber
so etwas macht man ja auch nicht, gelle?).  Dies dient einer Optimie-
rung der Bereichsspeicherung während der Assemblierung und sollte auch
für eine Symbolrückübersetzung keine Probleme darstellen, da durch
die einfache Kennzeichnung bereits der Einstiegspunkt und damit der
Suchpfad im Sektionsbaum gegeben ist.  Die Beschreibung einer Sektion
wird durch eine Leerzeile oder das Dateiende gekennzeichnet.

Programmteile, die außerhalb aller Sektionen liegen, werden nicht
gesondert ausgewiesen.  Diese "implizite Wurzelsektion" trägt die
Nummer -1 und wird auch als Vatersektion für Sektionen benutzt, die
keine eigentliche Vatersektion besitzen.

Es ist möglich, daß die Datei Leerzeilen oder Kommentarzeilen (Semiko-
lon am Zeilenanfang) beinhaltet.  Diese sind von einem Leseprogramm zu
ignorieren.


	6. Hilfsprogramme
	=================

Um die Arbeit mit dem Codeformat des Assemblers etwas zu erleichtern,
lege ich einige Progamme zu deren Bearbeitung bei.  Für diese Pro-
gramme gilt sinngemäß das gleiche wie in 1.1. !

Allen Programmen gemeinsam sind die Returncodes, die sie liefern:

Returncode   tritt auf bei...

0            kein Fehler
1            Kommandozeilenparameterfehler
2	     I/O-Fehler
3            Dateiformatfehler

Alle Programme lesen wie AS ihre Eingaben von STDIN und schreiben
Meldungen auf STDOUT (bzw. Fehlermeldungen auf STDERR).  Ein-und
Ausgaben sollten sich daher problemlos umleiten lassen.

Sofern Programme im folgenden Zahlen-oder Adreßangaben von der Kom-
mandozeile lesen, dürfen diese auch hexadezimal geschrieben werden,
indem man sie mit einem voranstehenden Dollarzeichen versieht (z.B.
$10 anstelle von 16).

+------+
| UNIX |
+------+
Unix-Shells ordnen dem Dollarzeichen allerdings eine spezielle Bedeu-
tung zu (Parameterexpansion), weshalb es nötig ist, einem Dollarzei-
chen direkt einen Backslash voranzustellen.

Ansonsten folgen die Aufrufkonventionen und -variationen (bis auf
PLIST und AS2MSG) denen von AS, d.h. man kann dauernd gebrauchte
Schalter in einer Environmentvariablen ablegen (deren Name sich aus
dem Anhängen von CMD an den Programmnamen ergibt, z.B. BINDCMD für
BIND), Optionen negieren und Groß-bzw. Kleinschreibung erzwingen
(näheres zu dem Wie in Kapitel 2.1).

Sofern Adreßangaben benutzt werden, beziehen sie sich immer auf die
Granularität des Adreßraumes des jeweiligen Prozessors; beim PIC
bedeutet z.B. eine Adreßdifferenz von 1 nicht ein Byte, sondern ein
Wort.


        6.1. PLIST
	----------

PLIST ist das einfachste Programm der vier mitgelieferten; es dient
einfach nur dazu, die in einer Codedatei gespeicherten Records aufzu-
listen.  Da das Programm nicht allzuviel bewirkt, ist der Aufruf
ziemlich simpel:

    PLIST <Dateiname>

Der Dateiname wird automatisch um die Endung P erweitert, falls keine
Endung vorhanden ist.

ACHTUNG! An dieser Stelle sind keine Jokerzeichen erlaubt! Falls mit
einem Befehl trotzdem mehrere Programmdateien gelistet werden sollen,
kann man sich mit folgendem "Minibatch" behelfen:

    for %n in (*.p) do plist %n

PLIST gibt den Inhalt der Codedatei in Tabellenform aus, wobei für
jeden Record genau eine Zeile ausgegeben wird.  Die Spalten haben
dabei folgende Bedeutung:

Codetyp      : die Prozessorfamilie, für die der Code erzeugt wurde.

Startadresse : absolute Speicheradresse, an die der Code zu laden ist.

Länge        : Länge des Codestücks in Byte.

Endadresse   : letzte absolute Adresse des Codestücks.  Diese berech-
               net sich als Startadresse+Länge-1.

Alle Angaben sind als hexadezimal zu verstehen.

Zuletzt gibt PLIST noch einen Copyrightvermerk aus, sofern er einen
solchen in der Datei findet, und die Summe aller Codelängen.

PLIST ist praktisch ein DIR für Codedateien.  Man kann es benutzen,
um sich den Inhalt einer Datei auflisten zu lassen, bevor man sie
weiterbearbeitet.



        6.2. BIND
        ---------

BIND ist ein Programm, mit dem man die Records mehrerer Codedateien
in eine Datei zusammenkopieren kann.  Die dabei vorhandene Filter-
funktion erlaubt es aber auch, nur Records eines bestimmten Typs
zu übernehmen.  Auf diese Weise kann BIND auch dazu verwendet wer-
den, um eine Codedatei in mehrere aufzuspalten.

Die allgemeine Syntax von BIND lautet

   BIND <Quelldatei(en)> <Zieldatei> [Optionen]

Wie auch AS betrachtet BIND alle nicht mit einem +, - oder / eingelei-
teten Parameter als Dateiangaben, von denen die letzte die Zieldatei
angeben muß.  Alle anderen Dateiangaben bezeichnen Quellen, diese
Angaben dürfen auch wieder Jokerzeichen enthalten.

An Optionen definiert BIND momentan nur eine:

 f <Header[,Header...]> : gibt eine Liste von Header IDs an, die
                          kopiert werden sollen.  Alle anderen
			  Records werden nicht kopiert.  Ohne die-
			  se Angabe werden alle Records kopiert.
			  Die in der Liste angegebenen entsprechen
			  dem Header-Feld in der Recordstruktur, wie
			  es in Abschnitt 5.1 beschrieben wurde. Die
                          einzelnen Header-Nummern in der Liste
                          werden durch Kommas getrennt.

Um z.B. alle MCS-51-Codeteile aus einer Programmdatei auszusieben,
benutzt man BIND folgendermaßen:

   BIND <Quellname> <Zielname> -f $31

Fehlt bei einer Dateiangabe eine Endung, so wird automatisch die En-
dung P angefügt.


	6.3. P2HEX
	----------

P2HEX ist eine Erweiterung von BIND.  Es besitzt alle Kommandozeilen-
optionen von BIND und hat die gleichen Konventionen bzgl. Dateinamen.
Im Gegensatz zu BIND wird die Zieldatei aber als Hexfile ausgegeben,
d.h. als eine Folge von Zeilen, die den Code als ASCII-Hexzahlen ent-
halten.

P2HEX kennt 7 verschiedene Zielformate, die über den Kommandozeilen-
parameter F ausgewählt werden können:

 - Motorola S-Record (-F Moto)
 - MOS Hex (-F MOS)
 - Intel-Hex (Intellec-8, -F Intel)
 - 16-Bit Intel-Hex (MCS-86, -F Intel16)
 - 32-Bit Intel-Hex (-F Intel32)
 - Tektronix Hex (-F Tek)
 - Texas Instruments DSK (-F DSK)

Wird kein Zielformat explizit angegeben, so wählt P2HEX anhand des
Prozessortyps automatisch eines aus, und zwar S-Records für Motorola-
Prozessoren, Hitachi und TLCS-900, MOS für 65xx/MELPS, DSK für die
16-Bit-Texas-Signalprozessoren und Intel-Hex für den Rest.  Je nach
Breite der Startadresse kommen bei S-Record Records der Typen 1,2
oder 3 zum Einsatz, jedoch nie in einer Gruppe gemischt.
Die Intel-, Tektronix-und MOS-Formate sind auf 16 Bit-Adressen be-
schränkt, das 16-Bit Intel-Format reicht 4 Bit weiter.  Längere Adres-
sen werden von P2HEX mit einer Warnung gemeldet und abgeschnitten (!).

FÜr die PICs und können die drei von Microchip spezifizierten Varian-
ten des Intel-Hex-Formates erzeugt werden, und zwar mit dem Schalter

-m <0..3>

Das Format 0 ist INHX8M, in dem alle Bytes in Lo-Hi-Ordnung enthalten
sind.  Die Adreßangaben verdoppeln sich, weil bei den PICs die Adres-
se sich nur um 1 pro Wort erhöht.  Dieses Format ist gleichzeitig die
Vorgabe.  Im Format 1 (INHX16M) werden alle Worte in ihrer natürli-
chen Ordnung abgelegt.  Dieses Format verwendet Microchip für seine
eigenen Programiergeräte.  Format 2 (INHX8L) und 3 (INHX8H) trennen
die Worte in ihre oberen und unteren Bytes auf.  Um die komplette In-
formation zu erhalten, muß P2HEX zweimal aufgerufen werden, z.B. so:

  p2hex test -m 2
  rename test.hex test.obl
  p2hex test -m 3
  rename test.hex test.obh

Für das Motorola-Format verwendet P2HEX zusätzlich einen in [CPM68K]
genannten Recordtyp mit der Nummer 5, der die Zahl der folgenden
Daten-Records (S1/S2/S3) bezeichnet.  Da dieser Typ vielleicht nicht
jedem Programm bekannt ist, kann man ihn mit der Option

 +5

unterdrücken.

Finden sich Coderecords verschiedener Prozessoren in einer Quelldatei,
so erscheinen die verschiedenen Hexformate auch gemischt in der Ziel-
datei - es empfiehlt sich also dringend, von der Filterfunktion Ge-
brauch zu machen.

Neben dem Codetypenfilter kennt P2HEX noch ein Adreßfilter, das nütz-
lich ist, falls der Code auf mehrere EPROMs verteilt werden muß:

-r <Startadresse>-<Endadresse>

Die Startadresse ist dabei die erste Speicherzelle, die im Fenster
liegen soll, die Endadresse die der letzten Speicherzelle im Fenster,
NICHT die der ersten außerhalb.  Um z.B. ein 8051-Programm in 4 2764-
EPROMs aufzuteilen, geht man folgendermaßen vor:

p2hex <Quelldatei> eprom1 -f $31 -r $0000-$1fff
p2hex <Quelldatei> eprom2 -f $31 -r $2000-$3fff
p2hex <Quelldatei> eprom3 -f $31 -r $4000-$5fff
p2hex <Quelldatei> eprom4 -f $31 -r $6000-$7fff

Defaultmäßig ist das Fenster 32 KByte groß und beginnt bei Adresse 0.

ACHTUNG! Die Splittung ändert nichts an den absoluten Adressen, die
in den Hexfiles stehen!  Sollen die Adressen im Hexfile bei 0 begin-
nen, so kann man dies durch den zusätzlichen Schalter

-a

erreichen.

Als Sonderwerte für Start-und Endadresse beim r-Parameter ist ein
schlichtes Dollar-Zeichen ($) erlaubt.  Diese kennzeichnet die erste
bzw. letzte in der Programmdatei belegte Adresse.  Wer also sicher
sein will, daß immer das ganze Programm in der Hex-Datei abgelegt
wird, braucht sich mit dem Schalter

 -r $-$

keine Gedanken mehr zu machen.  Dollarzeichen und feste Adressen
lassen sich selbstverständlich auch gemischt verwenden, z.B. kann
mit

 -r $-$7fff

das obere Ende auf die ersten 32K begrenzt werden.

Den Inhalt einer Datei kann man mit einem Offset auf eine beliebige
Position verschieben; diesen Offset hängt man einfach in Klammern an
den Dateinamen an.  Ist der Code in einer Datei z.B. auf Adresse 0 in
der P-Datei abgelegt, man möchte ihn jedoch auf Adresse 1000h
verschieben, so hängt man an ($1000) an den Dateinamen (ohne
Leerzeichen!) an.

Da das TI-DSK-Format Daten und Code unterscheiden kann, läßt sich
mit dem Schalter

 -d <Start>-<Ende>

festlegen, welche Adreßbereiche als Daten ausgegeben werden sollen.
Dollarzeichen sind hier NICHT zugelassen.  Für das DSK- sowie
Intel- und Motorola-Format relevant ist dagegen die Option

 -e <Adresse> ,

mit der man die in die Hex-Datei einzutragende Startadresse fest-
legen kann.  Fehlt diese Angabe, so wird nach einen entsprechenden
Eintrag in der Code-Datei gesucht.  Ist auch dort kein Hinweis auf
einen Einsprungpunkt zu finden, so wird kein Eintrag in die HEX-Datei
geschrieben (DSK/Intel) bzw. das entsprechende Feld wird auf 0 gesetzt
(Motorola).

Leider ist sich die Literatur nicht ganz über die Endezeile für Intel-
Hexfiles einig.  P2HEX kennt daher 3 Varianten, einstellbar über den
Parameter i mit einer nachfolgenden Ziffer:

 0  :00000001FF
 1  :00000001
 2  :0000000000

Defaultmäßig wird die Variante 0 benutzt, die die gebräuchlichste zu sein
scheint.

Fehlt der Zieldateiangabe eine Endung, so wird HEX als Endung ange-
nommen.

Defaultmäßig gibt P2HEX pro Zeile maximal 16 Datenbytes aus, wie es
auch die meisten anderen Tools tun, die Hex-Files erzeugen.  Wollen
Sie dies ändern, so können Sie dies mit dem Schalter

-l <Anzahl>

tun.  Der erlaubte Wertebereich liegt dabei zwischen 2 und 254 Daten-
bytes; ungerade Werte werden implizit auf gerade Anzahlen aufgerundet.

Anders als BIND erzeugt P2HEX keine Leerdatei, wenn nur ein Dateina-
me (=Zieldatei) angegeben wurde, sondern bearbeitet die dazugehörige
Codedatei.  Es ist also ein Minimalaufruf a la

 P2HEX <Name>

möglich, um <Name>.HEX aus <Name>.P zu erzeugen.


	6.4. P2BIN
	----------

P2BIN funktioniert wie P2HEX und bietet die gleichen Optionen (bis
auf die a- und i-Optionen, die bei Binärdateien keinen Sinn ergeben),
nur wird das Ergebnis nicht als Hexdatei, sondern als einfache Bi-
närdatei abgelegt.  Dies kann dann z.B. direkt in ein EPROM gebrannt
werden.

Zur Beeinflussung der Binärdatei kennt P2BIN gegenüber P2HEX noch
drei weitere Optionen:

 l <8-Bit-Zahl>   :  gibt den Wert an, mit dem unbenutzte Speicher-
		     stellen in der Datei gefüllt werden sollen.
                     Defaultmäßig ist der Wert $ff, so daß ein halb-
                     wegs intelligenter EPROM-Brenner sie über-
		     springt.  Man kann aber hiermit auch andere Wer-
                     te einstellen, z.B. enthalten die gelöschten
                     Speicherzellen der MCS-48-EPROM-Versionen Nul-
		     len.  In einem solchen Falle wäre 0 der richti-
		     ge Wert.

 s                :  weist das Programm an, eine Prüfsumme über die
       		     Binärdatei zu berechnen.  Die Prüfsumme wird
		     einmal als 32-Bit-Wert ausgegeben, zum anderen
		     wird das Zweierkomplement der Bits 0..7 in der
		     letzten Speicherstelle abgelegt, so daß die Mo-
		     dulo-256-Summe zu 0 wird.

 m                :  für den Fall, daß ein Prozessor mit 16- oder
                     32-Bit-Datenbus eingesetzt wird und die Binär-
		     datei für mehrere EPROMs aufgesplittet werden
		     muß.  Das Argument kann folgende Werte annneh-
		     men:

		     ALL    : alles kopieren
		     ODD    : alle Bytes mit ungerader Adresse ko-
			      pieren
                     EVEN   : alle Bytes mit gerader Adresse ko-
                              pieren
		     BYTE0..: nur alle Bytes kopieren, deren Adres-
		     BYTE3    die Form 4n+0 .. 4n+3 hat.
		     WORD0, : nur das untere bzw. obere 16-Bit-Wort
		     WORD1    der 32-Bit-Worte kopieren.

		     Nicht wundern: Bei diesen Optionen ist die Bi-
                     närdatei um den Faktor 2 oder 4 kleiner als bei
		     ALL.  Dies ist bei konstantem Adreßfenster lo-
                     gisch.


	6.5. AS2MSG
	-----------

Bei AS2MSG handelt es sich eigentlich um kein Hilfsprogramm, sondern
um ein Filter, das (glücklichen) Besitzern von Borland-Pascal 7.0 das
Arbeiten mit dem Assembler erleichtern soll.  In den DOS-Arbeitsumge-
bungen existiert ein "Tools"-Menü, das man um eigene Programme, z.B.
AS erweitern kann.  Das Filter erlaubt, die von AS gelieferten Fehler-
meldungen mit Zeilenangabe direkt im Editorfenster anzuzeigen.  Dazu
muß im Tools-Menü ein neuer Eintrag angelegt werden (Options/Tools/New).
Tragen Sie in die einzelnen Felder folgende Werte ein :

 - Title: ~M~akroassembler
 - Program path: AS
 - Command line: -E !1 $EDNAME $CAP MSG(AS2MSG) $NOSWAP $SAVE ALL
 - bei Bedarf einen Hotkey zuordnen (z.B. Shift-F7)

Die Option -E sorgt dafür, daß Turbo-Pascal nicht mit STDOUT und
STDERR durcheinander kommt.

Ich setze dabei voraus, daß sowohl AS als auch AS2MSG sich in einem
Verzeichnis befinden, welches in der Pfadliste aufgeführt ist.  Nach
einem Druck auf dem passenden Hotkey (oder Auswahl aus dem Tools-
Menü) wird AS mit dem Namen der Textdatei im aktiven Editorfenster
aufgerufen.  Die dabei aufgetretenen Fehler werden in ein separates
Fenster geleitet, durch das man nun "browsen" kann.  Mit Ctrl-Enter
springt man eine fehlerhafte Zeile an.  Zusätzlich enthält das
Fenster die Statistik, die AS am Ende der Assemblierung ausgibt.
Diese erhalten als Dummy-Zeilennummer 1.

Für diese Arbeitsweise sind sowohl TURBO.EXE (Real Mode) als auch
BP.EXE (Protected Mode) geeignet.  Ich empfehle BP, da in dieser Va-
riante beim Aufruf nicht erst der halbe DOS-Speicher "freigeswappt"
werden muß.


			--- Anhänge ---


        A. Fehlermeldungen von AS
	=========================

Im folgenden findet sich eine halb-tabellarische Auflistung der in
AS definierten Fehlermeldungen.  Zu jeder Fehlermeldung finden sich
folgende Angaben:

 - interne Fehlernummer (für den Anwender nur mit der n-Option sichtbar);
 - Fehlermeldung im Klartext;
 - Typ       :
   - Warnung   : zeigt mögliche Fehler oder ineffizienten Code an.
                 Assemblierung geht weiter.
   - Fehler    : echte Fehler.  Assemblierung geht weiter, aber keine
                 Code-Datei wird geschrieben.
   - fatal     : schwerwiegende Fehler.  Assemblierung wird abge-
                 brochen.
 - Ursache   : die Situation(en), in denen der Fehler ausgegeben wird;
 - Argument  : Die Ausgabe, die auf Wunsch als erweiterte Fehlermel-
	       dung erfolgt.

   0 Displacement=0, überflüssig

        Fehlertyp:
	   Warnung
        Ursache:
	   bei 680x0-, 6809 und COP8-Prozessoren: Das Displacement
	   in einem Adreßausdruck hat den Wert 0 ergeben.  Es wird
           ein  Adreßausdruck  ohne Displacement erzeugt.  Um keine
           Phasenfehler zu erzeugen, werden NOP-Befehle eingefügt.
        Argument:
        keines


  10 Kurzadressierung möglich

	Fehlertyp:
           Warnung
	Ursache:
           bei 680x0-, 6502- und 68xx-Prozessoren können
	   bestimmte Speicherbereiche mit kurzen Adressen erreicht
           werden.  Um keine Phasefehler zu erzeugen, wird zwar der
	   kürzere Ausdruck erzeugt, der freie Platz wird aber mit
	   NOPs aufgefüllt.
        Argument:
	   keines


  20 kurzer Sprung möglich

	Fehlertyp:
	   Warnung
        Ursache:
           Bei 680x0 und 8086-Prozessoren kann der Sprung
           sowohl mit langem als auch kurzem Displacement ausgeführt
           werden.  Da kein kurzer Sprung angefordert wurde, wurde im
           ersten Pass Platz für den langen Sprung freigehalten.
	   Es wird ein kurzer Sprung erzeugt, der freie Platz wird
	   mit NOPs aufgefüllt, um Phasenfehler zu vermeiden.
	Argument:
           keines


  30 kein Sharefile angelegt, SHARED ignoriert

        Fehlertyp:
	   Warnung
	Ursache:
	   Es wurde eine SHARED-Anweisung gefunden, es wurde aber
           keine Kommandozeilenoption angegeben, um eine Shared-Datei
           zu erzeugen.
        Argument:
           keines


  40 FPU liest Wert evtl. nicht korrekt ein (>=1E1000)

        Fehlertyp:
	   Warnung
        Ursache:
	   Das BCD-Gleitkommaformat der 680x0-Koprozessoren erlaubt
           zwar vierstellige Exponenten, lt. Datenbuch können solche
	   Werte aber nicht korrekt eingelesen werden.  Der vierstel-
	   lige Wert wird zwar erzeugt, eine Funktion ist aber nicht
           gewähleistet.
        Argument:
           keines


  50 Privilegierte Anweisung

	Fehlertyp:
           Warnung
        Ursache:
           Es wurde eine Anweisung benutzt, die nur im Supervisor-Mode
           zulässig ist, obwohl dieser nicht mittels SUPMODE ON vorher
           explizit angezeigt wurde.
        Argument:
	   keines


  60 Distanz 0 nicht bei Kurzsprung erlaubt (NOP erzeugt)

	Fehlertyp:
           Warnung
        Ursache:
	   Ein kurzer Sprung mit der Distanz 0 ist bei 680x0- bzw. 
           COP8-Prozessoren nicht erlaubt, da dieser Sonderwert für
           lange Sprünge benötigt wird.  Stattdessen wurde ein NOP-
           Befehl eingefügt.
        Argument:
	   keines


  70 Symbol aus falschem Segment

	Fehlertyp:
           Warnung
        Ursache:
           Das in dem Operanden benutzte Symbol ist aus einem Adreß-
           raum, der nicht mit dem benutzten Befehl bearbeitet werden
	   kann.
        Argument:
	   keines


  75 Segment nicht adressierbar

        Fehlertyp:
           Warnung
	Ursache:
	   Das in dem Operanden benutzte Symbol ist aus einem Adreß-
	   raum, der mit keinem der Segmentregister des 8086 adres-
           siert werden kann.
        Argument:
           Der Name des nicht adressierbaren Segments


  80 Änderung des Symbolwertes erzwingt zusätzlichen Pass

	Fehlertyp:
	   Warnung
	Ursache:
	   Ein Symbol hat im einen anderen Wert zugewiesen bekommen
	   als im vorhergehenden Pass.  Diese Warnung wird nur aus-
	   gegeben, falls die r-Option angegeben wurde.
	Argument:
	   Name des fraglichen Symbols


  90 Überlappende Speicherbelegung

	Fehlertyp:
           Warnung
	Ursache:
	   Bei der Bildung der Belegungsliste wurde festgestellt, daß
           ein Speicherbereich im Codesegment mehrfach benutzt wurde.
           Ursache können unüberlegte ORG-Anweisungen sein.
        Argument:
           keines


 100 keine CASE-Bedingung zugetroffen

	Fehlertyp:
           Warnung
	Ursache:
           bei einem SWITCH..CASE-Konstrukt ohne ELSECASE-Zweig traf
           keiner der CASE-Zweige zu.
        Argument:
	   keines


 110 Seite möglicherweise nicht adressierbar

        Fehlertyp:
           Warnung
        Ursache:
	   Das in dem Operanden benutzte Symbol liegt nicht in der
	   momentan mit ASSUME eingestellten Fenster (ST62xx,78(C)10).
        Argument:
           keines


 120 Registernummer muß gerade sein

	Fehlertyp:
	   Warnung
        Ursache:
           Die Hardware erlaubt nur ein Registerpaar zu verketten,
           dessen Startadresse gerade ist (RR0, RR2..., nur Z8).
        Argument:
	   keines


 130 veralteter Befehl

	Fehlertyp:
	   Warnung
	Ursache:
	   Der verwendete Befehl ist zwar noch definiert, ist in
	   seiner Funktion aber durch andere, neue Befehle ersetzbar
	   und daher in zukünftigen Prozessorversionen eventuell
	   nicht mehr vorhanden.
	Argument:
	   keines

 140 Nicht vorhersagbare Ausführung dieser Anweisung

	Fehlertyp:
	   Warnung
	Ursache:
	   Die verwendete Adressierungsart ist bei diesem Befehl zwar
	   prinzipiell erlaubt, ein Register wird jedoch in einer
	   Weise doppelt verwendet, daß je nach Ausführungsreihen-
	   folge sich unterschiedliche Ergebnisse einstellen können.
	Argument:
	   keines

 150 Lokaloperator außerhalb einer Sektion überflüssig

	Fehlertyp:
	   Warnung
	Ursache:
	   Ein vorangestellter Klammeraffe dient dazu, sich explizit
	   auf zu der Sektion lokale Symbole zu beziehen.  Wenn man
	   sich außerhalb einer Sektion befindet, gibt es keine
	   lokalen Symbole, weshalb dieser Operator überflüssig ist.
	Argument:
	   keines

 160 sinnlose Operation

	Fehlertyp:
	   Warnung
	Ursache:
	   Die Anweisung ergibt entweder überhaupt keine Sinn oder
	   kann auf andere Weise schneller und kürzer ausgeführt
	   werden.
	Argument:
	   keines

 170 unbekannter Symbolwert erzwingt zusätzlichen Pass

	Fehlertyp:
	   Warnung
	Ursache:
	   AS vermutet eine Vorwärtsreferenz eines Symbols, d.h. das
	   Symbol wird benutzt, bevor es definiert wurde, und hält
	   einen weiteren Pass für unumgänglich.  Diese Warnung wird
	   nur ausgegeben, falls die r-Option angegeben wurde.
	Argument:
	   Der Name des fraglichen Symbols


 180 Adresse nicht ausgerichtet

	Fehlertyp:
	   Warnung
	Ursache:
	   Eine Adresse ist nicht ein mehrfaches der Operandengröße.
	   Das Datenbuch verbietet zwar solche Zugriffe, im Instruk-
	   tionswort ist aber Platz für diese Adresse, so daß AS es
	   bei einer Warnung belassen hat.
	Argument:
	   keines


 190 I/O-Adresse darf nicht verwendet werden

	Fehlertyp:
	   Warnung
	Ursache:
	   Der verwendete Adressierungsmodus oder die angesprochene
	   Adresse sind zwar prinzipiell erlaubt, die Adresse liegt
	   aber im Bereich der Peripherieregister, die in diesem
	   Zusammenhang nicht verwendet werden dürfen.
	Argument:
	   keines


 200 mögliche Pipeline-Effekte

	Fehlertyp:
	   Warnung
	Ursache:
	   Ein Register wird in einer Befehlsfolge so verwendet, daß
	   die Befehlsausführung möglicherweise nicht in der hinge-
	   schriebenen Form ablaufen wird.  Üblicherweise wird ein
	   Register benutzt, bevor der neue Wert zur Verfügung steht.
	Argument:
	   das die Verklemmung verursachende Register


 210 mehrfache Adreßregisterbenutzung in einer Anweisung

	Fehlertyp:
	   Warnung
	Ursache:
	   Ein Adreßregister wird in mehreren Adreßausdrücken eines
	   Befehls benutzt.  Sofern einer der beiden Ausdrücke das
	   Register modifiziert, sind die Ergebnisadressen nicht
	   eindeutig festgelegt.
	Argument:
	   das mehrfach verwendete Register


 220 Speicherstelle ist nicht bitadressierbar

	Fehlertyp:
	   Warnung
	Ursache:
           Mit einer SFRB-Anweisung wurde versucht, eine Speicher-
           stelle als bitadressierbar zu deklarieren, die aufgrund
           der Architektur des 8051 nicht bitadressierbar ist.
	Argument:
	   das mehrfach verwendete Register


 230 Stack ist nicht leer

	Fehlertyp:
	   Warnung
	Ursache:
           Am Ende eines Durchlaufes ist ein vom Programm
           definierter Stack nicht leer.
	Argument:
	   der Name des Stacks sowie seine Resttiefe


 240 NUL-Zeichen in Strings, Ergebnis undefiniert

	Fehlertyp:
	   Warnung
	Ursache:
           Eine String-Konstante enthält ein NUL-Zeichen. Dies funk-
           tioniert zwar mit der Pascal-Version, in Hinblick auf die
           C-Version von AS ist dies aber ein Problem, da C Strings
           mit einem NUL-Zeichen terminiert, d.h. der String wäre
           für C an dieser Stelle zu Ende...
	Argument:
           keines


 250 Befehl überschreitet Seitengrenze

	Fehlertyp:
	   Warnung
	Ursache:
           Ein Befehl steht zu Teilen auf verschiedenen Seiten.  Da
           der Programmzähler des Prozessors aber nicht über Seiten-
           grenzen hinweg inkrementiert wird, würde zur Laufzeit an-
           stelle des Instruktionsbytes von der Folgeseite wieder das
           erste Byte der alten Seite geholt; das Programm würde feh-
           lerhaft ablaufen.
	Argument:
           keines


1000 Symbol doppelt definiert

	Fehlertyp:
	   Fehler
        Ursache:
	   Einem Symbol wurde durch ein Label oder EQU, PORT, SFR,
	   LABEL, SFRB oder BIT ein neuer  Wert zugewiesen, dies ist
	   aber nur bei SET/EVAL erlaubt.
        Argument:
           Name des fraglichen Symbols, bei eingeschalteter Querver-
	   weisliste zusätzlich die Zeile der ersten Definition.


1010 Symbol nicht definiert

	Fehlertyp:
           Fehler
	Ursache:
	   Ein benutztes Symbol ist auch im 2.Pass noch nicht in der
	   Symboltabelle enthalten.
        Argument:
	   Name des nicht gefundenen Symbols


1020 Ungültiger Symbolname

        Fehlertyp:
	   Fehler
        Ursache:
           Ein Symbolname entspricht nicht den Bedingungen für einen
           gültigen Symbolnamen.  Beachten Sie, daß für Makro-und
           Funktionsparameter strengere Regeln gelten!
        Argument:
	   der fehlerhafte Symbolname


1090 Ungültiges Format

	Fehlertyp:
	   Fehler
	Ursache:
	   Das benutzte Befehlsformat existiert bei diesem Befehl
	   nicht.
	Argument:
	   Der Kennbuchstabe des verwendeten Formates


1100 Überflüssiges Attribut

	Fehlertyp:
	   Fehler
        Ursache:
           Der benutzte Befehl (Prozessor oder Pseudo) darf kein mit
	   einem Punkt angehängtes Attribut haben.
	Argument:
           keines


1105 Attribut darf nur 1 Zeichen lang sein

        Fehlertyp:
           Fehler
	Ursache:
           Das mit einem Punkt an einen Befehl angehängte Attribut muß
           genau ein Zeichen lang sein; weder mehr noch weniger ist
	   erlaubt.
        Argument:
	   keines


1110 Unpassende Operandenzahl

        Fehlertyp:
           Fehler
	Ursache:
           Die bei einem Befehl (Prozessor oder Pseudo) angegebene
           Operandenzahl liegt nicht in dem für diesen Befehl erlaub-
           ten Bereich.
	Argument:
           keines


1115 Unpassende Operandenzahl

        Fehlertyp:
           Fehler
	Ursache:
           Die bei diesem Befehl angegebene Zahl von Optionen liegt
	   nicht in dem für diesen Befehl erlaubten Bereich.
	Argument:
           keines


1120 nur immediate-Adressierung erlaubt

        Fehlertyp:
           Fehler
	Ursache:
           Der benutzte Befehl läßt nur immediate-Operanden (mit vor-
	   angestelltem #) zu.
        Argument:
           keines


1130 Unpassende Operandengröße

	Fehlertyp:
           Fehler
        Ursache:
           Der Operand hat zwar einen für den Befehl zugelassenen Typ,
           jedoch nicht die richtige Länge (in Bits).
        Argument:
	   keines


1131 Widersprechende Operandengrößen

        Fehlertyp:
	   Fehler
        Ursache:
	   Die angegebenen Operanden haben unterschiedliche Längen (in
           Bit).
        Argument:
           keines


1132 Undefinierte Operandengröße

        Fehlertyp:
           Fehler
        Ursache:
           Aus Opcode und Operanden läßt sich die Operandengröße nicht
           eindeutig bestimmen (ein Problem des 8086-Assemblers).  Sie
	   müssen die Operandengröße durch einen BYTE, WORD, usw. PTR-
           Präfix festlegen.
        Argument:
           keines


1135 Ungültiger Operandentyp

	Fehlertyp:
           Fehler
        Ursache:
           Ein Ausdruck hat einen an dieser Stelle nicht zulässigen
	   Typ (Integer/Gleitkomma/String).
        Argument:
           Die an dieser Stelle zulässigen Datentypen


1140 Zuviele Argumente

        Fehlertyp:
           Fehler
	Ursache:
           Einem Befehl wurden mehr als die unter AS zulässigen 20
           Parameter übergeben.
        Argument:
           keines


1200 Unbekannter Befehl

        Fehlertyp:
           Fehler
        Ursache:
	   Der benutzte Befehl ist weder ein Pseudobefehl von AS
           noch ein Befehl des momentan eingestellten Prozessors.
        Argument:
	   keines


1300 Klammerfehler

        Fehlertyp:
	   Fehler
        Ursache:
           Der Formelparser ist auf einen (Teil-)Ausdruck gestoßen,
           in dem die Summe öffnender und schließender Klammern
           nicht übereinstimmt.
        Argument:
	   der beanstandete (Teil-)Ausdruck


1310 Division durch 0

        Fehlertyp:
	   Fehler
        Ursache:
           Bei einer Division oder Modulooperation ergab die Auswer-
	   tung des rechten Teilausdruckes 0.
        Argument:
           keines


1315 Bereichsunterschreitung

        Fehlertyp:
           Fehler
        Ursache:
           Der angegebene Integer-Wert unterschreitet den
           zulässigen Bereich.
	Argument:
           aktueller Wert und zulässiges Minimum (manchmal,
           ich stelle das gerade um...)


1320 Bereichsüberschreitung

	Fehlertyp:
           Fehler
        Ursache:
	   Der angegebene Integer-Wert überschreitet den
           zulässigen Bereich.
        Argument:
           aktueller Wert und zulässiges Maximum (manchmal,
           ich stelle das gerade um...)


1325 Adresse nicht ausgerichtet

	Fehlertyp:
	   Fehler
	Ursache:
	   Die angegebene direkte Speicheradresse entspricht nicht
	   den Ansprüchen des Datentransfers, d.h. ist nicht ein
	   mehrfaches der Operandengröße.  Nicht alle Prozessoren
	   erlauben unausgerichtete Datenzugriffe.
	Argument:
	   keines


1330 Distanz zu groß

        Fehlertyp:
           Fehler
        Ursache:
           Der in einem Adreßausdruck enthaltene Displacement-Wert
	   ist zu groß.
        Argument:
	   keines


1340 Kurzadressierung nicht möglich

        Fehlertyp:
           Fehler
	Ursache:
           Die Adresse des Operanden liegt außerhalb des Speicherbe-
           reiches, in dem Kurzadressierung möglich ist.
        Argument:
           keines


1350 Unerlaubter Adressierungsmodus

        Fehlertyp:
           Fehler
        Ursache:
	   Der benutzte Adressierungsmodus existiert generell zwar,
           ist an dieser Stelle aber nicht erlaubt.
	Argument:
	   keines


1351 Nummer muß ausgerichtet sein

	Fehlertyp:
	   Fehler
	Ursache:
	   An dieser Stelle sind nur ausgerichtete (=gerade,..) Adressen
	   erlaubt, da die untersten Bits für andere Zwecke verwendet
	   werden oder reserviert sind.
	Argument:
	   keines

1355 Adressierungsmodus im Parallelbetrieb nicht erlaubt

	Fehlertyp:
	   Fehler
	Ursache:
	   Die verwendeten Adressierungsmodi sind zwar im sequentiellen
	   Modus zulässig, jedoch nicht bei parallelen Instruktionen.
	Argument:
	   keines

1360 Undefinierte Bedingung

	Fehlertyp:
	   Fehler
	Ursache:
           Die benutzte Bedingung für bedingte Sprünge existiert nicht.
        Argument:
           keines


1370 Sprungdistanz zu groß

        Fehlertyp:
           Fehler
        Ursache:
	   Sprungbefehl und Sprungziel liegen zu weit auseinander, um
           mit einem Sprung der benutzten Länge überbrückt werden zu
	   können.
        Argument:
           keines


1375 Sprungdistanz ist ungerade

	Fehlertyp:
	   Fehler
	Ursache:
	   Da Befehle nur auf geraden Adressen liegen dürfen, muß eine
	   Sprungdistanz zwischen zwei Befehlen auch immer gerade sein,
	   das Bit 0 der Distanz wird anderweitig verwendet.  Diese
	   Bedingung ist verletzt worden.  Grund ist üblicherweise die
	   Ablage einer ungeraden Anzahl von Daten in Bytes oder ein
	   falsches ORG.
	Argument:
	   keines


1380 ungültiges Schiebeargument

	Fehlertyp:
           Fehler
        Ursache:
           als Argument für die Schiebeamplitude darf nur eine Kon-
           stante oder ein Datenregister verwendet werden. (nur
           680x0)
	Argument:
           keines


1390 Nur Bereich 1..8 erlaubt

	Fehlertyp:
           Fehler
	Ursache:
           Konstanten für Schiebeamplituden oder ADDQ-Argumente
	   dürfen nur im Bereich 1..8 liegen. (nur 680x0)
        Argument:
	   keines


1400 Schiebezahl zu groß

        Fehlertyp:
           Fehler
        Ursache:
           (nicht mehr verwendet)
	Argument:
           keines


1410 Ungültige Registerliste

	Fehlertyp:
           Fehler
	Ursache:
           Das Registerlisten-Argument von MOVEM oder FMOVEM hat ein
           falsches Format. (nur 680x0)
        Argument:
	   keines


1420 Ungültiger Modus mit CMP

        Fehlertyp:
           Fehler
        Ursache:
           Die verwendete Operandenkombination von CMP ist nicht er-
	   laubt. (nur 680x0)
        Argument:
           keines


1430 Ungültiger Prozessortyp

        Fehlertyp:
	   Fehler
        Ursache:
           Den mit CPU angeforderten Zielprozessor kennt AS nicht.
        Argument:
	   der unbekannte Prozessortyp


1440 Ungültiges Kontrollregister

        Fehlertyp:
           Fehler
        Ursache:
           Das bei MOVEC benutzte Kontrollregister  kennt der mit
	   CPU gesetzte Prozessor (noch) nicht.
        Argument:
           keines


1445 Ungültiges Register

	Fehlertyp:
	   Fehler
	Ursache:
	   Das benutzte Register ist zwar prinzipiell vorhanden,
	   hier aber nicht erlaubt.
	Argument:
	   keines


1450 RESTORE ohne SAVE

        Fehlertyp:
	   Fehler
        Ursache:
           Es wurde ein RESTORE-Befehl gefunden, obwohl kein mit
           SAVE gespeicherter Zustand (mehr) auf dem Stapel vor-
	   handen ist.
        Argument:
           keines


1460 fehlendes RESTORE

        Fehlertyp:
           Fehler
	Ursache:
           Nach der Assemblierung sind nicht alle SAVE-Befehle
           wieder aufgelöst worden.
        Argument:
           keines

1465 unbekannte Makro-Steueranweisung

	Fehlertyp:
	   Fehler
	Ursache:
	   Eine beim MACRO-Befehl zusätzlich angegebene Steueran-
	   weisung ist AS unbekannt.
	Argument:
	   die fragliche Anweisung

1470 fehlendes ENDIF/ENDCASE

        Fehlertyp:
           Fehler
        Ursache:
	   Nach der Assemblierung sind nicht alle Konstrukte zur
           bedingten Assemblierung aufgelöst worden.
        Argument:
	   keines


1480 ungültiges IF-Konstrukt

        Fehlertyp:
	   Fehler
        Ursache:
           Die Reihenfolge der Befehle in einem IF- oder SWITCH-
           Konstrukt stimmt nicht.
        Argument:
           keines


1483 doppelter Sektionsname

        Fehlertyp:
           Fehler
	Ursache:
           Es existiert bereits eine Sektion gleichen Namens auf
           dieser Ebene.
	Argument:
           der doppelte Name


1484 unbekannte Sektion

	Fehlertyp:
           Fehler
        Ursache:
           Im momentanen Sichtbarkeitsbereich existiert keine Sektion
           dieses Namens.
        Argument:
	   der unbekannte Name


1485 fehlendes ENDSECTION

        Fehlertyp:
	   Fehler
        Ursache:
           Nach Ende eines Durchganges sind nicht alle Sektionen wie-
	   der geschlossen worden.
        Argument:
           keines


1486 falsches ENDSECTION

        Fehlertyp:
           Fehler
        Ursache:
           die bei ENDSECTION angegebene Sektion ist nicht die inner-
           ste offene.
	Argument:
           keines


1487 ENDSECTION ohne SECTION

	Fehlertyp:
           Fehler
        Ursache:
	   Es wurde ein ENDSECTION-Befehl gegeben, obwohl gar keine
           Sektion offen war.
        Argument:
           keines


1488 nicht aufgelöste Vorwärtsdeklaration

        Fehlertyp:
           Fehler
        Ursache:
           Ein mit FORWARD oder PUBLIC angekündigtes Symbol wurde
	   nicht in der Sektion definiert.
        Argument:
	   der Name des fraglichen Symbols


1489 widersprechende FORWARD<->PUBLIC-Deklaration

	Fehlertyp:
           Fehler
	Ursache:
           Ein Symbol wurde sowohl als privat als auch global defi-
           niert.
        Argument:
           der Name des Symbols


1490 falsche Argumentzahl für Funktion

        Fehlertyp:
           Fehler
        Ursache:
	   Die Anzahl der Argumente für eine selbstdefinierte
           Funktion stimmt nicht mit der geforderten Anzahl
	   überein.
        Argument:
           keines

1495 unaufgelöste Literale (LTORG fehlt)

	Fehlertyp:
	   Fehler
	Ursache:
	   Am Programmende oder beim Umachalten zu einem
	   anderen Zielprozessor blieben noch nicht abgelegte
	   Literale übrig.
	Argument:
	   keines

1500 Befehl auf dem ... nicht vorhanden

	Fehlertyp:
           Fehler
        Ursache:
           Der benutzte Befehl existiert zwar  grundsätzlich, das
           eingestellte Mitglied der Prozessorfamilie beherrscht
           ihn aber noch nicht.
	Argument:
           keines


1505 Adressierungsart auf dem ... nicht vorhanden

	Fehlertyp:
           Fehler
	Ursache:
           Der benutzte Adressierungsmodus existiert zwar grund-
           sätzlich, das eingestellte Mitglied der Prozessorfamilie
           beherrscht ihn aber noch nicht.
	Argument:
           keines


1510 Ungültige Bitstelle

        Fehlertyp:
           Fehler
        Ursache:
	   Die angegebene Bitnummer ist nicht erlaubt oder eine Angabe
           fehlt komplett.
        Argument:
           keines


1520 nur ON/OFF erlaubt

	Fehlertyp:
           Fehler
        Ursache:
           Dieser Pseudobefehl darf als Argument nur ON oder OFF
	   haben.
        Argument:
           keines


1530 Stack ist leer oder nicht definiert

	Fehlertyp:
           Fehler
        Ursache:
           Es wurde bei einem POPV-Befehl versucht, einen Stack
           anzusprechen, der entweder nie definiert oder bereits
           leergeräumt wurde.
        Argument:
           der Name des fraglichen Stacks


1540 Nicht genau ein Bit gesetzt

	Fehlertyp:
           Fehler
        Ursache:
           In einer Bitmaske, die der BITPOS-Funktion übergeben 
           wurde, war nicht genau ein Bit gesetzt.
        Argument:
           keines


1600 vorzeitiges Dateiende
        Fehlertyp:
           Fehler
        Ursache:
           Es wurde mit einem BINCLUDE-Befehl versucht, über das 
           Ende einer Datei hinauszulesen.
        Argument:
           keines


1700 ROM-Offset geht nur von 0..63

        Fehlertyp:
           Fehler
	Ursache:
           Das Konstanten-ROM der 680x0-Koprozessoren hat nur max.
           63 Einträge.
        Argument:
           keines


1710 Ungültiger Funktionscode

        Fehlertyp:
           Fehler
        Ursache:
	   Als Funktionscodeargument darf nur SFC, DFC, ein Daten-
           register oder eine Konstante von 0..15 verwendet werden.
           (nur 680x0-MMU)
	Argument:
           keines


1720 Ungültige Funktionscodemaske

	Fehlertyp:
           Fehler
        Ursache:
           Als Funktionscodemaske darf nur ein Wert von 0..15 ver-
           wendet werden. (nur 680x0-MMU)
        Argument:
	   keines


1730 Ungültiges MMU-Register

        Fehlertyp:
	   Fehler
        Ursache:
           Die MMU hat kein Register mit dem angegebenen Namen. (nur
	   680x0-MMU)
        Argument:
           keines


1740 Level nur von 0..7

        Fehlertyp:
           Fehler
        Ursache:
           Die Ebene für PTESTW und PTESTR muß eine Konstante von
           0..7 sein. (nur 680x0-MMU)
	Argument:
           keines


1750 ungültige Bitmaske

	Fehlertyp:
           Fehler
        Ursache:
	   Die bei den Bit-Feld-Befehlen angegebene Bitmaske hat ein
           falsches Format. (nur 680x0)
        Argument:
           keines


1760 ungültiges Registerpaar

        Fehlertyp:
           Fehler
        Ursache:
           Das angegebene Registerpaar ist hier nicht verwendbar oder
	   syntaktisch falsch. (nur 680x0)
        Argument:
	   keines


1800 offene Makrodefinition

        Fehlertyp:
           Fehler
	Ursache:
           Eine Makrodefinition war am Dateiende nicht zuende.  Ver-
           mutlich fehlt ein ENDM.
        Argument:
           keines


1805 EXITM außerhalb eines Makrorumpfes

        Fehlertyp:
           Fehler
        Ursache:
           EXITM bricht die Expansion von Makro-Konstrukten ab.  Dieser 
           Befehl macht nur innerhalb von Makros Sinn und es wurde 
           versucht, ihn außerhalb aufzurufen.
        Argument:
           keines

1810 mehr als 10 Makroparameter

        Fehlertyp:
           Fehler
        Ursache:
	   Ein Makro darf höchstens 10 Parameter haben.
        Argument:
	   keines


1815 doppelte Makrodefinition

	Fehlertyp:
	   Fehler
	Ursache:
	   Ein Makronamne wurde in einer Sektion doppelt vergeben.
	Argument:
	   der doppelt verwendete Name


1820 Ausdruck muß im ersten Pass berechenbar sein

        Fehlertyp:
           Fehler
	Ursache:
           Der benutzte Befehl beeinflußt die Codelänge, daher sind
           Vorwärtsreferenzen hier nicht erlaubt.
        Argument:
           keines


1830 zu viele verschachtelte IFs

        Fehlertyp:
           Fehler
        Ursache:
	   (nicht mehr verwendet)
        Argument:
	   keines


1840 ELSEIF/ENDIF ohne ENDIF

        Fehlertyp:
           Fehler
	Ursache:
           es wurde ein ELSEIF- oder ENDIF-Befehl gefunden, obwohl
           kein offener IF-Befehl vorhanden ist.
        Argument:
           keines


1850 verschachtelter/rekursiver Makroaufruf

        Fehlertyp:
           Fehler
        Ursache:
	   (nicht mehr verwendet)
        Argument:
	   keines


1860 unbekannte Funktion

        Fehlertyp:
           Fehler
	Ursache:
           Die angesprochene Funktion ist weder eingebaut noch nach-
           träglich definiert worden.
	Argument:
           der Funktionsname


1870 Funktionsargument außerhalb Definitionsbereich

        Fehlertyp:
           Fehler
        Ursache:
	   Das Argument liegt nicht im Bereich der angesprochenen
           transzendenten Funktion.
	Argument:
           keines


1880 Gleitkommaüberlauf

	Fehlertyp:
	   Fehler
	Ursache:
	   Das Argument liegt zwar im Bereich der angesprochenen
	   transzendenten Funktion, das Ergebnis wäre aber nicht
	   mehr darstellbar.
	Argument:
	   keines


1890 ungültiges Wertepaar

	Fehlertyp:
	   Fehler
	Ursache:
	   Das benutzte Pärchen aus Basis und Exponent kann nicht
	   berechnet werden.
	Argument:
           keines


1900 Befehl darf nicht auf dieser Adresse liegen

        Fehlertyp:
           Fehler
        Ursache:
           Die Prozessorhardware erlaubt keine Sprünge von dieser
           Adresse.
	Argument:
           keines


1905 ungültiges Sprungziel

	Fehlertyp:
           Fehler
	Ursache:
           Die Prozessorhardware erlaubt keine Sprünge zu dieser
	   Adresse.
        Argument:
	   keines


1910 Sprungziel nicht auf gleicher Seite

        Fehlertyp:
           Fehler
        Ursache:
           Sprungbefehl und Sprungziel müssen bei diesem Befehl
	   auf der gleichen Seite liegen.
        Argument:
           keines


1920 Codeüberlauf

        Fehlertyp:
	   Fehler
        Ursache:
	   Es wurde versucht, mehr als 1024 Bytes Code oder Daten
           in einer Zeile zu erzeugen.
	Argument:
           keines


1925 Adreßüberlauf

	Fehlertyp:
	   Fehler
	Ursache:
	   Der Adreßraum dieses Prozessors wurde überschritten.
	Argument:
	   keines


1930 Konstanten und Platzhalter nicht mischbar

	Fehlertyp:
	   Fehler
	Ursache:
	   Anweisungen, die Speicher reservieren und solche, die ihn
           mit Konstanten belegen, dürfen nicht in einer Pseudo-
           anweisung gemischt werden.
        Argument:
           keines


1940 Codeerzeugung nur im Codesegment zulässig

	Fehlertyp:
	   Fehler
	Ursache:
	   Alle Segmente außer Code dienen nur der Reservierung von
	   Speicher, in ihnen dürfen weder Code noch Daten abgelegt
	   werden.
           (nicht mehr benutzt)
	Argument:
	   keines


1950 Paralleles Konstrukt nicht möglich

	Fehlertyp:
	   Fehler
	Ursache:
	   Entweder sind die beiden Instruktionen prinzipiell nicht
	   parallel ausführbar, oder sie stehen nicht unmittelbar
	   untereinander.
	Argument:
	   keines

1960 ungültiges Segment
        Fehlertyp:
           Fehler
        Ursache:
	   Das angegebene Segment ist an dieser Stelle nicht
           anwendbar.
        Argument:
	   der benutzte Segmentname


1961 unbekanntes Segment

        Fehlertyp:
	   Fehler
        Ursache:
           Das bei SEGMENT angegebene Segment existiert bei diesem
           Prozessor nicht.
        Argument:
           der benutzte Segmentname


1962 unbekanntes Segmentregister

        Fehlertyp:
           Fehler
	Ursache:
           Das angegebene Segmentregister existiert nicht (nur 8086).
        Argument:
	   keines


1970 ungültiger String

        Fehlertyp:
	   Fehler
        Ursache:
           Der angegebene String hat ein ungültiges Format.
        Argument:
           keines


1980 ungültiger Registername

        Fehlertyp:
           Fehler
        Ursache:
	   Das angegebene Register existiert nicht oder darf hier
           nicht verwendet werden.
        Argument:
	   keines


1985 ungültiges Argument

        Fehlertyp:
	   Fehler
        Ursache:
           Der angegebene Befehl darf nicht mit einem REP-Präfix
           versehen werden.
        Argument:
           keines


1990 keine Indirektion erlaubt

        Fehlertyp:
           Fehler
	Ursache:
           in dieser Kombination ist keine indirekte Adressierung
           erlaubt.
	Argument:
           keines


1995 nicht im aktuellen Segment erlaubt

	Fehlertyp:
           Fehler
        Ursache:
           (nicht mehr verwendet)
        Argument:
           keines


1996 nicht im Maximum-Modus zulässig

        Fehlertyp:
           Fehler
	Ursache:
           Dieses Register ist nur im Minimum-Modus definiert.
        Argument:
	   keines


1997 nicht im Minimum-Modus zulässig

	Fehlertyp:
	   Fehler
        Ursache:
           Dieses Register ist nur im Maximum-Modus definiert.
        Argument:
           keines


2000 Ungültige Präfix-Kombination

        Fehlertyp:
           Fehler
        Ursache:
           Die angegebene Kombination von Präfixen ist nicht zulässig
           oder nicht im Maschinenkode darstellbar.
        Argument:
           keines


2010 ungültige Escape-Sequenz

        Fehlertyp:
           Fehler
        Ursache:
           Das mit einem Backslash eingeleitete Sonderzeichen ist
           nicht definiert.
        Argument:
           keines


10001 Fehler bein Öffnen der Datei

        Fehlertyp:
           fatal
        Ursache:
	   Beim Versuch, eine Datei zu öffnen, ist ein Fehler
           aufgetreten.
        Argument:
	   Beschreibung des E/A-Fehlers


10002 Listingschreibfehler

        Fehlertyp:
	   fatal
        Ursache:
	   Beim Schreiben des Assemblerlistings ist ein Fehler
           aufgetreten.
        Argument:
           Beschreibung des E/A-Fehlers


10003 Dateilesefehler

	Fehlertyp:
           fatal
	Ursache:
           Beim Lesen aus einer Quelldatei ist ein Fehler auf-
           getreten.
	Argument:
           Beschreibung des E/A-Fehlers


10004 Dateischreibfehler

	Fehlertyp:
           fatal
        Ursache:
           Beim Schreiben von Code- oder Share-Datei ist ein
           Fehler aufgetreten.
	Argument:
	   Beschreibung des E/A-Fehlers


10006 Speicherüberlauf

        Fehlertyp:
	   fatal
	Ursache:
           Der verfügbare Speicher reicht nicht mehr, alle Daten-
	   strukturen aufzunehmen.  Weichen Sie auf die DPMI- oder
           OS/2-Version von AS aus.
        Argument:
           keines


10007 Stapelüberlauf

        Fehlertyp:
           fatal
        Ursache:
           Der Programmstapel ist wegen zu komplizierter Formel-
	   ausdrücke oder einer ungünstigen Anlage der Symbol-
	   oder Makrotabelle übergelaufen.  Versuchen Sie es noch
	   einmal mit der '-A'-Option.
	Argument:
           keines


        B. E/A-Fehlermeldungen
        ======================

Die hier aufgelisteten Fehlermeldungen werden nicht nur von AS bei
E/A-Fehlern ausgegeben, sondern auch von den Hilfsprogrammen PLIST,
BIND, P2HEX und P2BIN.  Es sind nur die Fehler näher erklärt, die
m.E. bei der Arbeit auftreten können.  Sollte doch einmal ein nicht
erläuterter E/A-Fehler auftreten, so dürfte der Grund in einem Pro-
grammfehler liegen.  Melden Sie dies unbedingt!!

   2   Datei nicht gefunden
	Die angegebene Datei existiert nicht oder liegt auf einem
        anderen Laufwerk.

   3   Pfad nicht gefunden
        Der Pfad eines Dateinamens existiert nicht oder liegt auf
        einem anderen Laufwerk.

   4   zu viele offene Dateien
	DOS sind die Dateihandles ausgegangen.  Erhöhen Sie die
        FILES= -Angabe in der CONFIG.SYS.

   5   Dateizugriff verweigert
	Entweder reichen die Netzwerkrechte für einen Dateizugriff
        nicht, oder es wurde versucht, eine schreibgeschützte Datei
        zu überschreiben oder zu verändern.

   6   Ungültiger Dateihandle

  12   Ungültiger Zugriffsmodus

  15   Ungültiger Laufwerksbuchstabe
	Das angesprochene Laufwerk existiert nicht.

  16   aktuelles Verzeichnis kann nicht gelöscht werden

  17   RENAME geht nicht über Laufwerke

 100   vorzeitiges Dateiende
        Eine Datei war zuende, obwohl sie es aufgrund ihrer Struktur
	noch nicht sein dürfte.  Vermutlich ist sie beschädigt.

 101   Diskette/Platte voll
        Das spricht wohl für sich!  Aufräumen!!

 102   ASSIGN fehlt

 103   Datei nicht offen

 104   Datei nicht für Einlesen offen

 105   Datei nicht für Ausgaben offen

 106   Ungültiges numerisches Format

 150   Diskette ist schreibgeschützt
        Wenn Sie schon keine Festplatte als Arbeitsmedium verwenden,
        so sollten Sie wenigstens die Schreibschutzecke entfernen!

 151   Unbekanntes Gerät
        Sie haben versucht, ein Peripheriegerät anzusprechen, welches
	DOS unbekannt ist.  Dies sollte normalerweise nicht auftreten,
	da der Name dann automatisch als Datei interpretiert wird.

 152   Laufwerk nicht bereit
	Schließen Sie die Klappe des Diskettenlaufwerks.

 153   unbekannte DOS-Funktion

 154   Prüfsummenfehler auf Diskette/Platte
	Ein harter Lesefehler auf der Diskette.  Nochmal versuchen;
        wenn immer noch vorhanden, Diskette neu formatieren bzw.
        ernste Sorgen um Festplatte machen!

 155   ungültiger DPB

 156   Positionierfehler
        Der Platten/Disketten-Controller hat eine bestimmte Spur nicht
	gefunden.  Siehe Nr. 154!

 157   unbekanntes Sektorformat
        DOS kann mit dem Format der Diskette nichts anfangen.

 158   Sektor nicht gefunden
        Analog zu Nr. 158, nur daß hier der angeforderte Sektor auf
        der Spur nicht gefunden werden konnte.

 159   Papierende
        Offensichtlich haben Sie die Ausgaben von AS direkt auf einen
	Drucker umgeleitet.  Assemblerlistings können seeehr lang
        sein...

 160   Gerätelesefehler
        Nicht näher vom Gerätetreiber klassifizierter Lesefehler.

 161   Geräteschreibfehler
        Nicht näher vom Gerätetreiber klassifizierter Schreibfehler.

 162   allgemeiner Gerätefehler
        Hier ist der Gerätetreiber völlig ratlos, was passiert sein
        könnte.


        C. Häufig gestellte Fragen
        ==========================

In diesem Kapitel habe ich versucht, einige besonders häufig ge-
stellte Fragen mit den passenden Antworten zu sammeln.  Die Ant-
worten auf die hier auftauchenden Probleme finden sich zwar auch
an anderer Stelle in der Anleitung, jedoch findet man sie vielleicht
nicht auf den ersten Blick...

F: Ich bin DOS leid.  Für welche Plattformen gibt es AS sonst ?
A: Neben der Protected-Mode-Version, die AS unter DOS mehr Speicher
   zur Verfügung stellt, existieren Portierungen für OS/2 und Unix-
   Systeme wie z.B. Linux (im Teststadium).  An Versionen, die Soft-
   wareherstellern in Redmond beim Geldscheffeln zuarbeiten würden,
   ist momentan nicht gedacht.  Sofern jemand anders in dieser Hin-
   sicht aktiv werden will, stelle ich ihm aber gerne die AS-Quellen
   zur Verfügung, von denen sich die C-Variante insbesondere eignen
   dürfte.  Über Fragen zu diesen Quellen hinaus sollte er sich aber
   nicht viel von mir erwarten...

F: Ist eine Unterstützung des XYZ-Prozessors für AS geplant? 
A: Es kommen immer neue Prozessoren heraus, und ich bemühe mich, bei
   Erweiterung von AS Schritt zu halten.  Der Stapel mit der Auf-
   schrift "Unerledigt" auf meinem Schreibtisch unterschreitet aber
   selten die 10cm-Grenze... Bei der Planung, welche Kandidaten zu-
   erst abgearbeitet werden, spielen Wünsche von Anwendern natürlich
   eine große Rolle.  Das Internet und die steigende Zahl elektronisch
   publizierter Dokumentation erleichtern die Beschaffung von Unter-
   lagen, speziell bei ausgefallenen oder älteren Architekturen wird
   es aber immer wieder schwierig.  Wenn sich die fragliche Prozessor-
   familie nicht in der Liste in Planung befindlicher Prozessoren be-
   findet (siehe Kapitel 1), macht es sich sehr gut, der Anfrage auch
   gleich ein passendes Datenbuch hinzuzupacken (zur Not auch leih-
   weise!).

F: Ein freier Assembler ist ja eine feine Sache, aber eigentlich
   bräuchte ich jetzt auch noch einen Disassembler...und einen
   Debugger...ein Simulator wäre auch ganz nett..
A: AS ist ein Freizeitprojekt von mir, d.h. etwas, was ich in der
   Zeit tue, wenn ich mich nicht gerade um den Broterwerb kümmere.
   Von dieser Zeit nimmt AS schon einen ganz erheblichen Teil ein,
   und ab und zu genehmige ich mir auch mal eine Auszeit, um den
   Lötkolben zu schwingen, mal wieder eine Tangerine Dream-Platte 
   bewußt zu hören, mich vor den Fernseher zu hocken oder einfach
   nur dringenden menschlichen Bedürfnissen nachzugehen.  Ich habe
   einmal angefangen, einen Disassembler zu konzipieren, der wieder
   voll reassemblierbaren Code erzeugt und automatisch Daten- und
   Code-Bereiche trennt, habe das Projekt aber relativ schnell wieder
   eingestellt, weil die restliche Zeit für so etwas einfach nicht
   mehr reicht.  Ich mache lieber eine Sache gut als ein halbes
   Dutzend mäßig.  Von daher muß die Antwort also wohl "nein"
   heißen...

F: In den Bildschirmausgaben von AS tauchen seltsame Zeichen auf,
   z.B. Pfeile und eckige Klammern.  Warum?
A: AS verwendet zur Bildschirmsteuerung defaultmäßig einige ANSI-
   Terminalsteuersequenzen.  Haben Sie keinen ANSI-Treiber instal-
   liert, so kommen diese Steuerzeichen ungefiltert auf Ihrem Bild-
   schirm heraus.  Installieren Sie entweder einen ANSI-Treiber oder
   schalten Sie die Steuersequenzen mit dem DOS-Befehl SET USEANSI=N
   ab.

F: Während der Assemblierung bricht AS plötzlich mit der Meldung
   eines Stapelüberlaufes ab.  Ist mein Programm zu kompliziert?
A: Ja und Nein.  Die Symboltabelle für Ihr Programm ist nur etwas
   unregelmäßig gewachsen, was zu zu hohen Rekursionstiefen im
   Zugriff auf die Tabelle geführt hat.  Diese Fehler treten ins-
   besondere bei der 16-Bit-OS/2-Version von AS auf, die nur über
   einen relativ kleinen Stack verfügt.  Starten Sie AS noch einmal
   mit dem -A-Kommandozeilenschalter.  Hilft dies auch nicht, so kom-
   men als mögliche Problemstellen noch zu komplizierte Formelaus-
   drücke in Frage.  Versuchen Sie in einem solchen Fall, die Formel
   in Zwischenschritte aufzuspalten.

F: AS scheint mein Programm nicht bis zum Ende zu assemblieren.  Mit
   einer älteren Version von AS (1.39) hat es dagegen funktioniert.
A: Neuere Versionen von AS ignorieren das END-Statement nicht mehr,
   sondern beenden danach wirklich die Assemblierung.  Insbesondere
   bei Include-Dateien ist es früher vorgekommen, daß Anwender jede
   Datei mit einem END-Statement beendet haben.  Entfernen Sie die
   überflüssigen ENDs.

F: Weil ich noch ein paar kompliziertere Assemblierfehler im Programm
   hatte, habe ich mir ein Listing gemacht und es einmal genauer an-
   geschaut.  Dabei ist mir aufgefallen, daß einige Sprünge nicht auf
   das gewünschte Ziel, sondern auf sich selbst zeigen!
A: Dieser Effekt tritt bei Vorwärtssprüngen auf, bei denen der Formel-
   parser von AS im ersten Pass die Zieladresse noch nicht kennen
   kann.  Da der Formelparser ein unabhängiges Modul ist, muß er sich
   in einem solchen Fall einen Wert ausdenken, der auch relativen
   Sprüngen mit kurzer Reichweite nicht wehtut, und dies ist nun
   einmal die aktuelle Programmzähleradresse selber...im zweiten Pass
   wären die korrekten Werte erschienen, aber zu diesem ist es nicht
   gekommen, da schon im ersten Pass Fehler auftraten.  Korrigieren
   Sie die anderen Fehler zuerst, so daß AS zum zweiten Pass kommt,
   und das Listing sollte wieder vernünftiger aussehen.

F: Mein Programm wird zwar korrekt assembliert, bei der Umwandlung
   mit P2BIN oder P2HEX erhalte ich aber nur eine leere Datei.
A: Dann haben Sie wahrscheinlich das Adreßfilter nicht korrekt
   eingestellt.  Defaultmäßig reicht der Filter von 0 bis 32 Kbyte,
   falls Ihr Programm Teile außerhalb dieses Bereiches besitzen
   sollte, werden diese nicht übernommen.  Sollte Ihr Code komplett
   jenseits 32 Kbyte liegen (wie es bei 65er und 68er-Prozessoren
   üblich ist), dann erhalten Sie das von Ihnen geschilderte Ergeb-
   nis.  Setzen Sie das Adreßfilter einfach auf einen passenden
   Bereich (s. das Kapitel zu P2BIN/P2HEX).


        D. Pseudobefehle gesammelt
        ==========================


In diesem Anhang finden sich noch einmal als schnelle Referenz alle
von AS zur Verfügung gestellten Pseudobefehle.  Die Liste ist in zwei
Teile gegliedert: Im ersten Teil finden sich Befehle, die unabhängig
vom eingestellten Zielprozessor vorhanden sind, danach folgen fÜr 
jede Prozessorfamilie die zusätzlich vorhandenen Befehle:

        Immer vorhandene Befehle
        ------------------------

=             :=             ALIGN          BINCLUDE       CASE
CHARSET       CPU            DEPHASE        ELSECASE       ELSEIF
END           ENDCASE        ENDIF          ENDM           ENDSECTION
ENUM          ERROR          EQU            EXITM          FATAL
FORWARD       FUNCTION       GLOBAL         IF             IFB
IFDEF         IFEXIST        IFNB           IFNDEF         IFNEXIST
IFNUSED       IFUSED         INCLUDE        IRP            LABEL
LISTING       MACEXP         MACRO          MESSAGE        NEWPAGE
ORG           PAGE           PHASE          POPV           PUSHV
PRTEXIT       PRTINIT        PUBLIC         READ           RELAXED
REPT          RESTORE        SAVE           SECTION        SEGMENT
SHARED        SWITCH         TITLE          WARNING        WHILE

Zusätzlich existiert SET bzw. EVAL, falls SET bereits ein Prozessor-
befehl ist.

        Motorola 680x0
        --------------

DC[.<size>]   DS[.<size>]    FULLPMMU       FPU            PADDING
PMMU          SUPMODE


        Motorola 56000
        --------------

DC            DS             XSFR           YSFR


        PowerPC
        -------

BIGENDIAN     DB             DD             DQ             DS
DT            DW             SUPMODE


        Motorola 68xx/Hitachi 6309
        --------------------------

ADR           BYT            DC[.<size>]    DFS            DS[.<size>]
FCB           FCC            FDB            PADDING        RMB


        Motorola 6805/68HC08
        --------------------

ADR           BYT            DFS            FCB            FCC
FDB           RMB


        Motorola 6809/Hitachi 6309
        --------------------------

ADR           ASSUME         BYT            DFS            FCB
FCC           FDB            RMB


        Motorola 68HC12
        ---------------

ADR           BYT            DC[.<size>]    DFS            DS[.<size>]
FCB           FCC            FDB            PADDING        RMB


        Motorola 68HC16
        ---------------

ADR           ASSUME         BYT            DFS            FCB
FCC           FDB            RMB


        Hitachi H8/300(L/H)
        -------------------

DC[.<size>]   DS[.<size>]    MAXMODE        PADDING


        Hitachi H8/500
        --------------

ASSUME        DC[.<size>]    DS[.<size>]    MAXMODE        PADDING


        Hitachi SH7x00
        --------------

COMPLITERALS  DC[.<size>]    DS[.<size>]    LTORG          PADDING
SUPMODE


        65xx/MELPS-740
        --------------

ADR           ASSUME         BYT            DFS            FCB
FCC           FDB            RMB


        65816/MELPS-7700
        ----------------

ADR           ASSUME         BYT            DB             DD
DQ            DS             DT             DW             DFS
FCB           FCC            FDB            RMB


        Mitsubishi MELPS-4500
        ---------------------

DATA          RES            SFR


        Mitsubishi M16
        --------------

DB            DD             DQ             DS             DT
DW


        Mitsubishi M16C
        ---------------

DB            DD             DQ             DS             DT
DW


        Intel MCS-48
        ------------

DB            DD             DQ             DS             DT
DW


        Intel MCS-(2)51
        ---------------

BIGENDIAN     BIT            DB             DD             DQ
DS            DT             DW             PORT           SFR
SFRB          SRCMODE


        Intel MCS-96
        ------------

ASSUME        DB             DD             DQ             DS
DT            DW
 

        Intel 8080/8085
        ---------------

DB            DD             DQ             DS             DT
DW            PORT


        Signetics 8X30x
        ---------------

LIV           RIV

 
        Philips XA
        ----------

ASSUME        BIT            DB             DC[.<size>]    DD 
DQ            DS[.<size>]    DT             DW             PADDING
PORT          SUPMODE


        AMD 29K
        -------

ASSUME        DB             DD             DQ             DS
DT            DW             EMULATED       SUPMODE


        Siemens 80C166/167
        ------------------

ASSUME        BIT            DB             DD             DQ
DS            DT             DW


        Zilog Zx80
        ----------

DB            DD             DEFB           DEFW           DQ
DS            DT             DW             EXTMODE        LWORDMODE


        Zilog Z8
        --------

DB            DD             DQ             DS             DT
DW            SFR


        Toshiba TLCS-900
        ----------------

DB            DD             DQ             DS             DT
DW            MAXIMUM        SUPMODE


        Toshiba TLCS-90
        ---------------

DB            DD             DQ             DS             DT
DW


        Toshiba TLCS-870
        ----------------

DB            DD             DQ             DS             DT
DW


        Toshiba TLCS-47(0(A))
        ---------------------

ASSUME        DB             DD             DQ             DS
DT            DW             PORT


        Toshiba TLCS-9000
        -----------------

DB            DD             DQ             DS             DT
DW


        Microchip PIC16C5x
        ------------------

DATA          RES            SFR            ZERO


        Microchip PIC16C5x
        ------------------

DATA          RES            SFR            ZERO


        Microchip PIC17C42
        ------------------

DATA          RES            SFR            ZERO


        SGS-Thomson ST6
        ---------------

ASCII         ASCIZ          ASSUME         BYTE           BLOCK
SFR           WORD      


        SGS-Thomson ST7
        ---------------

DC[.<size>]   DS[.<size>]    PADDING


        SGS-Thomson ST9
        ---------------

ASSUME        BIT            DB             DD             DQ
DS            DT             DW             REG


        6804
        ----

ADR           BYT            DFS            FCB            FCC
FDB           RMB            SFR


        Texas TM3201x
        -------------

DATA          PORT           RES


        Texas TM32C02x
        --------------

BFLOAT        BSS            BYTE           DATA           DOUBLE
EFLOAT        TFLOAT         LONG           LQxx           PORT
Qxx           RES            RSTRING        STRING         WORD


        Texas TMS320C3x
        ---------------

ASSUME        BSS            DATA           EXTENDED       SINGLE
WORD


        Texas TM32C05x
        --------------

BFLOAT        BSS            BYTE           DATA           DOUBLE
EFLOAT        TFLOAT         LONG           LQxx           PORT
Qxx           RES            RSTRING        STRING         WORD


        Texas TMS9900
        -------------

BSS           BYTE           PADDING        WORD


        Texas TMS70Cxx
        --------------

DB            DD             DQ             DS             DT
DW


        Texas TMS370
        ------------

DB            DBIT           DD             DQ             DS
DT            DW


        Texas MSP430
        ------------

BSS           BYTE           PADDING        WORD


        National SC/MP
        --------------

DB            DD             DQ             DS             DT
DW
	

        National COP8
        -------------

ADDR          ADDRW          BYTE           DB             DD
DQ            DS             DSB            DSW            DT
DW            FB             FW             SFR            WORD


        NEC uPD78C1x
        ------------

ASSUME        DB             DD             DQ             DS
DT            DW


        NEC 75K0
        --------

ASSUME        BIT            DB             DD             DQ
DS            DT             DW             SFR

   
        NEC 78K0
        --------

DB            DD             DQ             DS             DT
DW


        E. Vordefinierte Symbole
        ========================


Name         Datentyp   Definition  Bedeutung

BIGENDIAN    Boolean    dynam.(0)   Konstantenablage mit MSB first ?

CASESENSITIVE Boolean   normal      Unterscheidung von Groß-und Klein-
                                    buchstaben in Symbolnamen ?

CONSTPI      Gleitkomma normal      Kreiszahl Pi (3.1415.....)

DATE         String     vordef.     Datum des Beginns der Assem-
                                    blierung (1.Pass)

FALSE        Boolean    vordef.     0 = logisch "falsch"

HASFPU       Boolean    dynam.(0)   Koprozessor-Befehle freige-
                                    schaltet ?

HASPMMU      Boolean    dynam.(0)   MMU-Befehle freigeschaltet ?

INEXTMODE    Boolean    dynam.(0)   XM-Flag für 4 Gbyte Adreßraum ge-
                                    setzt ?

INLWORDMODE  Boolean    dynam.(0)   LW-Flag für 32-Bit-Befehle ge-
                                    setzt ?

INMAXMODE    Boolean    dynam.(0)   Prozessor im Maximummodus ?

INSUPMODE    Boolean    dynam.(0)   Prozessor im Supervisor-Modus ?

INSRCMODE    Boolean    dynam.(0)   Prozessor im Quellmodus ?

FULLPMMU     Boolean    dynam.(0/1) voller PMMU-Befehlssatz erlaubt ?

LISTON       Boolean    dynam.(1)   Listing freigeschaltet ?

MACEXP       Boolean    dynam.(1)   Expansion von Makrokonstrukten im
                                    Listing freigeschaltet ?

MOMCPU       Integer    dynam.      Nummer der momentan gesetzten
			(68008)	    Ziel-CPU

MOMCPUNAME   String     dynam.      Name der momentan gesetzten Ziel-
                        (68008)     CPU

MOMFILE      String     Spezial     augenblickliche Quelldatei
                                    (schließt Includes ein)

MOMLINE      Integer    Spezial     aktuelle Zeilennummer in der
                                    Quelldatei

MOMPASS      Integer    Spezial     Nummer des laufenden Durchgangs

MOMSECTION   String     Spezial     Name der aktuellen Sektion oder
				    Leerstring, falls außerhalb aller
                                    Sektionen

MOMSEGMENT   String     Spezial     Name des mit SEGMENT eingestellten
                                    Adreßraumes

PADDING      Boolean    dynam.(1)   Auffüllen von Bytefeldern auf gan-
                                    ze Anzahl ?

RELAXED      Boolean    dynam.(0)   Schreibweise von Integer-Konstan-
                                    ten in beliebiger Syntax erlaubt ?

PC           Integer    Spezial     mom. Programmzähler (Thomson)

TIME         String     vordef.     Zeit des Beginns der Assemblie-
                                    rung (1. Pass)

TRUE         Integer    vordef.     1 = logisch "wahr"

VERSION      Integer    vordef.     Version von AS in BCD-Kodierung,
				    z.B. 1331 hex für Version 1.33p1

*            Integer    Spezial     mom. Programmzähler (Motorola,
                                    Rockwell, Microchip, Hitachi)

$            Integer    Spezial     mom. Programmzähler (Intel, Zilog,
                                    Texas, Toshiba, NEC, Siemens, AMD)

Boolean-Symbole sind eigentlich normale normale Integer-Symbole, mit
dem Unterschied, daß ihnen von AS nur zwei verschiedene Werte (0 oder
1, entsprechend False oder True) zugewiesen werden.  Spezialsymbole
werden von AS nicht in der Symboltabelle abgelegt, sondern aus Ge-
schwindigkeitsgründen direkt im Parser abgefragt.  Sie tauchen daher
auch nicht in der Symboltabelle des Listings auf.  Während vordefi-
nierte Symbole nur einmal am Anfang eines Passes besetzt werden, kön-
nen sich die Werte dynamischer Symbole während der Assemblierung
mehrfach ändern, da sie mit anderen Befehlen vorgenommene Einstel-
lungen widerspiegeln.  Die in Klammern stehenden Werte geben dann die
Voreinstellung zu Beginn eines Passes an.

Die hier aufgelistete Schreibweise ist diejenige, mit der man die 
Symbole auch im case-sensitiven Modus erreicht.

Die hier aufgeführten Namen sollte man für eigene Symbole meiden;
entweder kann man sie zwar definieren, aber nicht darauf zugreifen
(bei Spezialsymbolen), oder man erhält eine Fehlermeldung wegen eines
doppelt definierten Symboles.  Im gemeinsten Fall führt die Neube-
legung durch AS zu Beginn eines Passes zu einem Phasenfehler und
einer Endlosschleife...


	F. Danksagungen
	===============

Wenn man sich entschließt, ein solches Kapitel neu zu schreiben, nach-
dem es eigentlich schon zwei Jahre veraltet ist, läuft man automatisch
Gefahr, daß dabei der eine oder andere gute Geist, der etwas zum bis-
herigen Gelingen dieses Projektes beigetragen hat, vergessen wird.  Der
allererste  Dank gebührt daher allen Personen, die ich in der folgenden 
Aufzählung unfreiwillig unterschlagen habe!  

AS als Universalassembler, wie er jetzt besteht, ist auf Anregung von
Bernhard (C.) Zschocke entstanden, der einen "studentenfreundli-
chen", d.h. kostenlosen 8051-Assembler für sein Mikroprozessorprakti-
kum brauchte und mich dazu bewegt hat, einen bereits bestehenden 
68000-Assembler zu erweitern.  Von dortan nahm die Sache ihren Lauf...
Das Mikroprozessorpraktikum an der RWTH Aachen hat auch immer die
eifrigsten Nutzer der neuesten AS-Features (und damit Bug-Sucher) ge-
stellt und damit einiges zur jetzigen Qualität von AS beigetragen.

Das Internet und FTP haben sich als große Hilfe bei der Meldung von
Bugs und der Verbreitung von AS erwiesen.  Ein Dank geht daher an
die FTP-Administratoren (Bernd Casimir in Stuttgart, Norbert Breidohr
in Aachen und Jürgen Meißburger in Jülich).  Insbesondere letzterer 
hat sich sehr engagiert, um eine praxisnahe Lösung im ZAM zu 
finden.

Ach ja, wo wir schon im ZAM sind: Wolfgang E. Nagel hat zwar nichts
direkt mit AS zu tun, immerhin ist er aber mein Chef und wirft 
ständig vier Augen auf das, was ich tue.  Bei AS scheint zumindest
ein lachendes dabei zu sein...

Ohne Datenbücher und Unterlagen zu Prozessoren ist ein Programm wie
AS nicht zu machen.  Ich habe von einer enormen Anzahl von Leuten
Informationen bekommen, die von einem kleinen Tip bis zu ganzen
Datenbüchern reichen.  Hier eine Aufzählung (wie oben gesagt, ohne 
Garantie auf Vollständigkeit!):

Ernst Ahlers, Charles Altmann, Bernd Casimir, Gunther Ewald,
Stephan Hruschka, Peter Kliegelhöfer, Ulf Meinke, Matthias Paul, 
Norbert Rosch, Steffen Schmid, Leonhard Schneider, Oliver Sellke,
Christian Stelter, Oliver Thamm, Thorsten Thiele.

...und ein gehässiger Dank an Rolf-Dieter-Klein und Tobias Thiel, die
mit ihren ASM68K demonstrierten, wie man es nicht machen sollte und
mich damit indirekt dazu angeregt haben, etwas besseres zu schrei-
ben!

So ganz allein habe ich AS nicht verzapft.  AS enthält die OverXMS-
Routinen von Wilbert van Leijen, um die Overlay-Module ins Extended
Memory verlagern zu können.  Eine wirklich feine Sache, einfach und
problemlos anzuwenden!

Die TMS320C2x/5x-Codegeneratoren sowie die Datei STDDEF2x.INC stammen
von Thomas Sailer, ETH Zürich.  Erstaunlich, an einem Wochenende hat
er es geschafft, durch meinen Code durchzusteigen und den neuen Ge-
nerator zu implementieren.  Entweder waren das reichliche Nacht-
schichten oder ich werde langsam alt...


	G. Änderungen seit Version 1.3
	==============================

Version 1.31:  - zusätzlicher MCS-51-Prozessortyp 80515.  Die Nummer
		 wird wiederum nur vom Assembler verwaltet.  Die Da-
		 tei STDDEF51.INC wurde um die dazugehörigen SFRs
		 erweitert. ACHTUNG! Einige 80515-SFRs haben sich
                 adreßmäßig verschoben!

               - zusätzlich Prozessor Z80 unterstützt;

               - schnellerer 680x0-Codegenerator.

Version 1.32:  - Schreibweise von Zeropageadressen für 65xx nicht mehr
                 als Adr.z, sondern wie beim 68xx als <Adr;

               - unterstützt die Prozessoren 6800, 6805, 6301 und
		 6811;

               - der 8051-Teil versteht jetzt auch DJNZ, PUSH und POP
		 (sorry);

               - im Listing werden neben den Symbolen jetzt auch die
                 definierten Makros aufgelistet;

	       - Befehle IFDEF/IFNDEF für bedingte Assemblierung, mit
                 denen sich die Existenz eines Symboles abfragen
		 läßt;

	       - Befehle PHASE/DEPHASE zur Unterstützung von Code,
                 der zur Laufzeit auf eine andere Adresse verschoben
		 werden soll;

	       - Befehle WARNING/ERROR/FATAL, um anwenderspezifi-
                 sche Fehlermeldungen ausgeben zu können;

               - Die Datei STDDEF51.INC enthält zusätzlich das Makro
		 USING zur einfacheren Handhabung der Registerbänke
		 der MCS-51er;

               - Kommandozeilenoption u, um Segmentbelegung anzuzei-
		 gen.

Version 1.33:  - unterstützt den 6809;

	       - zusätzlich Stringvariablen;

	       - Die Befehle TITLE, PRTINIT, PRTEXIT, ERROR, WARNING
		 und FATAL erwarten jetzt einen Stringausdruck, Kon-
                 stanten müssen demzufolge nicht mehr in Hochkommas,
		 sondern in Gänsefüßchen eingeschlossen werden. Ana-
                 loges gilt für DB, DC.B und BYT;

	       - Befehl ALIGN zur Ausrichtung des Programmzählers bei
		 Intel-Prozessoren:

               - Befehl LISTING, um die Erzeugung eines Listings ein-
                 und ausschalten zu können;

	       - Befehl CHARSET zur Definition eigener Zeichensätze.

Version 1.34:  - Wenn im ersten Pass Fehler auftreten, wird gar kein
		 zweiter Pass mehr durchgeführt;

	       - neues vordefiniertes Symbol VERSION, welches die
                 Version von AS enthält;

	       - Befehl MESSAGE, um Durchsagen und Meldungen programm-
                 gesteuert zu erzeugen;

               - Formelparser über Stringkonstanten zugänglich;

               - Bei Fehlern in Makroexpansionen wird zusätzlich die
		 laufende Zeile im Makro angezeigt;

	       - Funktion UPSTRING, um einen String in Großbuchstaben
                 zu wandeln.

Version 1.35:  - Funktion TOUPPER, um ein einzelnes Zeichen in Groß-
                 buchstaben zu wandeln;

               - Befehl FUNCTION, um eigene Funktionen definieren zu
                 können;

               - Kommandozeilenoption D, um Symbole von außen definie-
		 ren zu können;

               - Fragt die Environment-Variable ASCMD für häufig ge-
		 brauchte Optionen ab;

	       - bei gesetzter u-Option wird das Programm zusätzlich
                 auf doppelt belegte Speicherbereiche abgeprüft;

	       - Kommandozeilenoption C, um eine Querverweisliste zu
		 erzeugen.

Version 1.36:  - unterstützt zusätzlich die Prozessorfamilien PIC 16C5x
                 und PIC17C4x;

               - im Listing wird zusätzlich die Verschachtelungsebene
                 bei Include-Dateien angezeigt;

               - in der Querverweisliste wird zusätzlich die Stelle
		 angezeigt, an der ein Symbol definiert wurde;

               - Kommandozeilenoption A, um eine kompaktere Ablage
                 der Symboltabelle zu erzwingen.

Version 1.37:  - unterstützt zusätzlich die Prozessoren 8086, 80186,
		 V30, V35, 8087 und Z180;

	       - Befehle SAVE und RESTORE zur besseren Umschaltung von
                 Flags;

               - Operatoren zur logischen Verschiebung und Bitspiegelung;

               - Kommandozeilenoptionen können mit einem Pluszeichen
		 negiert werden;

               - Filter AS2MSG zur bequemen Arbeit mit AS unter
                 Turbo-Pascal 7.0;

	       - ELSEIF darf ein Argument zur Bildung von IF-THEN-ELSE-
                 Leitern haben;

	       - Zur bequemeren bedingten Assemblierung zusätzlich ein
                 CASE-Konstrukt;

               - Selbstdefinierte Funktionen dürfen mehr als ein Argument
                 haben;

               - P2HEX kann nun auch Hexfiles für 65er-Prozessoren er-
		 zeugen;

               - BIND, P2HEX und P2BIN haben jetzt die gleichen Varia-
                 tionsmöglichkeiten in der Kommandozeile wie AS;

               - Schalter i bei P2HEX, um 3 Varianten für den Endere-
		 cord einzustellen;

               - Neue Funktionen ABS und SGN;

               - Neue Pseudovariablen MOMFILE und MOMLINE;

               - Ausgabemöglichkeit erweiterter Fehlermeldungen;

	       - Befehle IFUSED und IFNUSED, um abzufragen, ob ein
                 Symbol bisher benutzt wurde;

	       - Die Environment-Variablen ASCMD, BINDCMD usw. können
                 auch einen Dateinamen enthalten, in dem für die
		 Optionen mehr Platz ist;

	       - P2HEX erzeugt nun die von Microchip vorgegebenen
                 Hex-Formate (p4);

               - mit der Seitenlängenangabe 0 können automatische
		 Seitenvorschübe im Listing vollständig unterdrückt
                 werden (p4);

               - neue Kommandozeilenoption P, um die Ausgabe des
                 Makroprozessors in eine Datei zu schreiben (p4);

               - in der Kommandozeile definierte Symbole dürfen nun
                 auch mit einem frei wählbaren Wert belegt werden
                 (p5).

Version 1.38:  - Umstellung auf Mehrpass-Betrieb.  Damit kann AS auch
		 bei Vorwärtsreferenzen immer den optimalen Code
		 erzeugen;

	       - Der 8051-Teil kennt nun auch die Befehle JMP und CALL;

	       - unterstützt zusätzlich die Toshiba TLCS-900-Reihe (p1);

	       - Befehl ASSUME, um dem Assembler die Belegung der 8086-
		 Segmentregister mitzuteilen (p2);

	       - unterstützt zusätzlich die ST62xx-Reihe von SGS-Thomson
		 (p2);

	       - ..sowie die 3201x-Signalprozessoren von Texas Instru-
		 ments (p2);

	       - Option F bei P2HEX, um die automatische Formatwahl
		 übersteuern zu können (p2);

	       - P2BIN kann nun auch durch Angabe von Dollarzeichen
		 Anfang und Ende des Adreßfensters selbstständig
		 festlegen (p2);

	       - Der 8048-Codegenerator kennt nun auch die 8041/42-
		 Befehlserweiterungen (p2);

	       - unterstützt zusätzlich die Zilog Z8-Mikrokontroller
                 (p3).

Version 1.39:  - Definitionsmöglichkeit von Sektionen und lokalen
		 Labels;

	       - Kommandozeilenschalter h, um Hexadezimalzahlenausgabe
		 mit Kleinbuchstaben zu erzwingen;

	       - Variable MOMPASS, um die Nummer des augenblicklichen
		 Durchganges abfragen zu können;

	       - Kommandozeilenschalter t, um einzelne Teile des As-
		 semblerlistings ausblenden zu können;

	       - kennt zusätzlich die L-Variante der TLCS-900-Reihe
		 von Toshiba und die MELPS-7700-Reihe von Mitsubishi
		 (p1);

	       - P2HEX akzeptiert nun auch Dollarzeichen für Start-
		 und Endadresse (p2);

	       - unterstützt zusätzlich die TLCS90-Familie von Toshi-
		 ba (p2);

	       - P2HEX kann Daten zusätzlich im Tektronix- und 16-
		 Bit Intel-Hex-Format ausgeben (p2);

	       - bei Adreßüberschreitungen gibt P2HEX Warnungen aus
		 (p2);

	       - Include-Datei STDDEF96.INC mit Adreßdefinitionen für
		 die TLCS-900-Reihe (p3);

	       - Befehl READ, um Werte während der Assemblierung
		 interaktiv einlesen zu können (p3);

	       - Fehlermeldungen werden nicht mehr einfach auf die
		 Standardausgabe, sondern auf den von DOS dafür
		 vorgesehenen Kanal (STDERR) geschrieben (p3);

	       - Der beim 6811-Teil fehlende STOP-Befehl ist nun
		 da (scusi,p3);

	       - unterstützt zusätzlich die µPD78(C)1x-Familie von
		 NEC (p3);

	       - unterstützt zusätzlich den PIC16C84 von Microchip
		 (p3);

	       - Kommandozeilenschalter E, um die Fehlermeldungen in
		 eine Datei umleiten zu können (p3);

	       - Die Unklarheiten im 78(C)1x-Teil sind beseitigt (p4);

	       - neben dem MELPS-7700 ist nun auch das "Vorbild" 65816
		 vorhanden (p4);

	       - Die ST62xx-Pseudoanweisung ROMWIN wurde entfernt und
		 mit in den \tt ASSUME\rm -Befehl eingegliedert (p4);

	       - unterstützt zusätzlich den 6804 von SGS-Thomson (p4);

	       - durch die NOEXPORT-Option in der Makrodefinition kann
		 nun für jedes Makro einzeln festgelegt werden, ob es
		 in der MAC-Datei erscheinen soll oder nicht (p4);

	       - Die Bedeutung von MACEXP für Expansionen von Makros
		 hat sich wegen der zusätzlichen NOEXPAND-Option in
		 der Makrodefinition leicht geändert (p4);

	       - Durch die GLOBAL-Option in der Makrodefinition können
		 nun zusätzlich Makros definiert werden, die durch
		 ihren Sektionsnamen eindeutig gekennzeichnet sind
		 (p4).

Version 1.40:  - unterstützt zusätzlich den DSP56000 von Motorola;

	       - P2BIN kann nun auch das untere bzw. obere Wort aus
		 32-Bit-Wörtern abtrennen;

	       - unterstützt zusätzlich die TLCS-870- und TLCS-47-
		 Familie von Toshiba (p1);

	       - mit einem vorangestellten ! kann man durch Makros
		 "verdeckte" Maschinenbefehle wieder erreichen (p1);

	       - mit der GLOBAL-Anweisung lassen sich Symbolnamen
		 nun auch qualifiziert exportieren (p1);

	       - mit der r-Option kann man sich nun eine Liste der
		 Stellen erzeugen lassen, die zusätzliche Durchläufe
		 erzwangen (p1);

	       - bei der E-Option kann nun die Dateiangabe weggelas-
		 sen werden, so daß ein passender Default gewählt
		 wird (p1);

	       - mit der t-Option kann nun die Zeilennumerierung im
		 Listing abgeschaltet werden (p1);

	       - Escapesequenzen sind nun auch in in ASCII geschrie-
		 benen Integerkonstanten zulässig (p1);

	       - Mit dem Pseudobefehl PADDING kann das Einfügen von
		 Füllbytes im 680x0-Modus ein- und ausgeschaltet
		 werden (p2);

	       - ALIGN ist nun für alle Zielplattformen erlaubt (p2);

	       - kennt zusätzlich die PIC16C64-SFRs (p2);

	       - unterstützt zusätzlich den 8096 von Intel (p2);

	       - Bei DC kann zusätzlich ein Wiederholungsfaktor an-
		 gegeben werden (r3);

	       - unterstützt zusätzlich die TMS320C2x-Familie von
		 Texas Instruments (Implementierung von Thomas
		 Sailer, ETH Zürich, r3); P2HEX ist auch entsprechend
		 erweitert;

	       - statt EQU darf nun auch einfach ein Gleichheits-
		 zeichen benutzt werden (r3);

	       - zur Definition von Aufzählungen zusätzlich ein
		 ENUM-Befehl (r3);

	       - END hat jetzt auch eine Wirkung (r3);

	       - zusätzliche Kommandozeilenoption n, um zu
		 Fehlermeldungen zusätzlich die internen Fehlernummern
		 zu erhalten (r3);

	       - unterstützt zusätzlich die TLCS-9000er von Toshiba (r4);

	       - unterstützt zusätzlich die TMS370xxx-Reihe von Texas
		 Instuments, wobei als neuer Pseudobefehl DBIT
		 hinzukam (r5);

	       - kennt zusätzlich die DS80C320-SFRs (r5);

	       - der Makroprozessor kann nun auch Includes aus Makros
		 heraus einbinden, wozu das Format von Fehlermeldungen
		 aber leicht geändert werden mußte.  Falls Sie AS2MSG
		 verwenden, ersetzen Sie es unbedingt durch die neue
		 Version! (r5)

	       - unterstützt zusätzlich den 80C166 von Siemens (r5);

	       - zusätzlich eine VAL-Funktion, um Stringausdrücke
		 auswerten zu können (r5).

	       - Mit Hilfe von in geschweiften Klammern eingeschlos-
		 senen Stringvariablen lassen sich nun selber Symbole
		 definieren (r5);

	       - kennt zusätzlich die Eigenheiten des 80C167 von
		 Siemens (r6);

	       - jetzt gibt es für die MELPS740-Reihe auch die
		 special-page-Adressierung (r6);

	       - mit eckigen Klammern kann man explizit Symbole aus
		 einer bestimmten Sektion ansprechen.  Die Hilfs-
		 konstruktion mit dem Klammeraffen gibt es nicht
		 mehr (r6)!

	       - kennt zusätzlich die MELPS-4500-Reihe von Mitsubi-
		 shi (r7);

	       - kennt zusatzlich die H8/300 und H8/300H-Prozessoren
		 von Hitachi (r7);

	       - die mit LISTING und MACEXP gemachten Einstellungen
		 lassen sich nun auch wieder aus gleichnamigen Sym-
		 bolen auslesen (r7);

	       - kennt zusätzlich den TMS320C3x von Texas Instruments
		 (r8);

	       - kennt zusätzlich den SH7000 von Hitachi (r8);

               - der Z80-Teil wurde um die Unterstützung des Z380
                 erweitert (r9);

               - der 68K-Teil wurde um die feinen Unterschiede der
                 683xx-Mikrokontroller erweitert (r9);

               - ein Label muß nun nicht mehr in der ersten Spalte
                 beginnen, wenn man es mit einem Doppelpunkt
		 versieht (r9);

               - kennt zusätzlich die 75K0-Reihe von NEC (r9);

               - mit dem neuen Kommandozeilenschalter o kann der Name
                 der Code-Datei neu festgelegt werden (r9);

               - der ~~-Operator ist in der Rangfolge auf einen sinn-
                 volleren Platz gerutscht (r9);

               - ASSUME berücksichtigt für den 6809 jetzt auch das
                 DPR-Register und seine Auswirkungen (pardon, r9);

               - Der 6809-Teil kennt nun auch die versteckten Erwei-
                 terungen des 6309 (r9);

               - Binärkonstanten können jetzt auch in C-artiger Notation
                 geschrieben werden (r9).

Version 1.41:  - über das Symbol MOMSEGMENT kann der momentan gesetzte
                 Adreßraum abgefragt werden;

               - anstelle von SET bzw. EVAL kann jetzt auch einfach :=
                 geschrieben werden;

               - mit der neuen Kommandozeilenoption q kann ein "stiller"
                 Assemblerlauf erzwungen werden;

               - das Schlüsselwort PARENT zum Ansprechen der Vatersektion
                 wurde um PARENT0...PARENT9 erweitert;

               - der PowerPC-Teil wurde um die Mikrokontroller-Versionen
                 MPC505 und PPC403 erweitert;

               - mit SET oder EQU definierte Symbole können nun einem
                 bestimmten Adreßraum zugeordnet werden;

               - durch das Setzen der Environment-Variablen USEANSI
                 kann die Verwendung von ANSI-Bildschirmsteuersequenzen
                 an-und ausgeschaltet werden (r1);

               - der SH7000-Teil kennt jetzt auch die SH7600-Befehls-
                 erweiterungen (und sollte jetzt korrekte Displacements
                 berechnen...) (r1);

               - im 65XX-Teil wird jetzt zwischen 65C02 und 65SC02
	         unterschieden (r1);

               - neben der Variablen MOMCPU gibt es jetzt auch den
	         String MOMCPUNAME, der den Prozessornamen im Voll-
                 text enthält (r1);

               - P2HEX kennt jetzt auch die 32-Bit-Variante des
                 Intel-Hex-Formates (r1);

               - kennt jetzt auch die Einschränkungen des 87C750 (r2);

               - die Nummern für fatale Fehlermeldungen wurden auf den
                 Bereich ab 10000 verschoben, um Platz für normale
                 Fehlermeldungen zu schaffen (r2);

               - unbenutzte Symbole werden in der Symboltabelle jetzt
                 mit einem Stern gekennzeichnet (r2);

               - unterstützt zusätzlich die 29K-Familie von AMD (r2);

               - unterstützt zusätzlich die M16-Familie von Mitsu-
                 bishi (r2);

               - unterstüztzt zusätzlich die H8/500-Familie von
	         Hitachi (r3);

               - die Anzahl von Datenbytes, die P2HEX pro Zeile aus-
                 gibt, ist jetzt variierbar (r3);

               - der Pass, ab dem durch die -r-Option erzeugte War-
	         nungen ausgegeben werden, ist einstellbar (r3);

               - der Makroprozessor kennt jetzt ein WHILE-Statement,
                 mit dem ein Code-Stück eine variable Anzahl wieder-
		 holt werden kann (r3);

               - der PAGE-Befehl erlaubt es nun auch, die Breite des
                 Ausgabemediums fürs Listing anzugeben (r3);

               - Um neue Pseudo-Prozessortypen einführen zu können,
                 lassen sich jetzt CPU-Aliasse definieren (r3);

               - unterstüztzt zusätzlich die MCS/251-Familie von
	         Intel (r3);

               - bei eingeschalteter Querverweisliste wird bei dop-
                 pelt definierten Symbolen die Stelle der ersten
                 Definition angezeigt (r3);

               - unterstützt zusätzlich die TMS320C5x-Familie von
		 Texas Instruments (Implementierung von Thomas
                 Sailer, ETH Zürich, r3);

               - die OS/2-Version sollte jetzt auch mit langen Da-
                 teinamen klarkommen.  Wenn man nicht jeden Mist
                 selber kontrolliert... (r3)

               - über den Befehl BIGENDIAN kann im MCS-51/251-Modus
                 jetzt gewählt werden, ob die Ablage von Konstanten
                 im Big- oder Little-Endian-Format erfolgen soll
                 (r3);

               - es wird beim 680x0 jetzt zwischen dem vollen und 
                 eingeschränkten MMU-Befehlssatz unterschieden; eine
                 manuelle Umschaltung ist mit dem FULLPMMU-Befehl
                 möglich (r3);

               - über die neue Kommandozeilenoption I kann eine
                 Liste aller eingezogenen Include-Files mit ihrer
                 Verschachtelung ausgegeben werden (r3);

               - unterstützt zusätzlich die 68HC16-Familie von
		 Motorola (r3);

               - Beim END-Statement kann jetzt zusätzlich ein
                 Einsprungpunkt für das Programm angegeben werden
                 (r3);

               - P2HEX und P2BIN erlauben es jetzt, den Inhalt einer
                 Code-Datei adreßmäßig zu verschieben (r4);

               - einem SHARED-Befehl anhängende Kommentare werden
                 jetzt in die Share-Datei mit übertragen (r4);

               - unterstützt zusätzlich die 68HC12-Familie von
                 Motorola (r4);

               - unterstützt zusätzlich die XA-Familie von Philips
                 (r4);

               - unterstützt zusätzlich die 68HC08-Familie von
                 Motorola (r4);

               - unterstützt zusätzlich die AVR-Familie von
                 Atmel (r4);

               - aus Kompatibilität zum AS11 von Motorola existieren 
                 zusätzlich die Befehle FCB, FDB, FCC und RMB (r5);

               - unterstützt zusätzlich den M16C von Mitsubishi (r5);

               - unterstützt zusätzlich den COP8 von National Semi-
                 conductor (r5);

               - zwei neue Befehle zur bedingten Assemblierung: IFB
                 und IFNB (r5);

               - mit dem EXITM-Befehl ist es nun möglich, eine Makro-
                 expansion vorzeitig abzubrechen (r5);

               - unterstützt zusätzlich den MSP430 von Texas Instru-
                 ments (r5);

               - LISTING kennt zusätzlich die Varianten NOSKIPPED und
                 PURECODE, um nicht assemblierten Code aus dem Listing
                 auszublenden (r5);

               - unterstützt zusätzlich die 78K0-Familie von NEC (r5);

               - BIGENDIAN ist jetzt auch im PowerPC-Modus verfügbar
                 (r5);

               - zusätzlich ein BINCLUDE-Befehl, um Binärdaten ein-
                 binden zu können (r5);

               - zusätzliche TOLOWER- und LOWSTRING-Funktionen, um
                 Groß- in Kleinbuchstaben umzuwandeln (r5);

               - es ist jetzt möglich, auch in anderen Segmenten als
                 CODE Daten abzulegen.  Das Dateiformat wurde ent-
                 sprechend erweitert (r5);

               - der DS-Befehl, mit dem man Speicherbereiche reser-
                 vieren kann, ist jetzt auch im Intel-Modus zulässig
                 (r5);

               - Mit der Kommandozeilenoption U ist es jetzt möglich,
                 AS in einen case-sensitiven Modus umzuschalten, in
                 dem Namen von Symbolen, selbstdefinierten Funktionen,
                 Makros, Makroparametern sowie Sektionen nach Groß-
                 und Kleinschreibung unterschieden werden (r5);

               - SFRB berücksichtigt jetzt auch die Bildungsregeln 
                 für Bitadressen im RAM-Bereich; werden nicht bit-
                 adressierbare Speicherstellen angesprochen, erfolgt
                 eine Warnung (r5);

               - zusätzliche Pseudobefehle PUSHV und POPV, um Symbol-
                 werte temporär zu sichern (r5);

               - zusätzliche Funktionen BITCNT, FIRSTBIT, LASTBIT und
                 BITPOS zur Bitverarbeitung (r5);

               - bei den CPU32-Prozessoren ist jetzt auch der 68360 
                 berücksichtigt (r5);

               - unterstützt zusätzlich die ST9-Familie von SGS-Thom-
                 son (r6);

               - unterstützt zusätzlich den SC/MP von National Semi-
                 conductor (r6);

               - unterstützt zusätzlich die TMS70Cxx-Familie von Texas
                 Instruments (r6);

               - unterstützt zusätzlich die TMS9900-Familie von Texas
                 Instruments (r6);

               - unterstützt zusätzlich die Befehlssatzerweiterungen
                 des 80296 (r6);

               - die unterstützten Z8-Derivate wurden erweitert (r6);

               - berücksichtigt zusätzlich die Maskenfehler des 80C504
                 von Siemens (r6);

               - zusätzliche Registerdefinitionsdatei für die C50x-
                 Prozessoren von Siemens (r6);

               - unterstützt zusätzlich die ST7-Familie von SGS-Thom-
                 son (r6);

               - die Intel-Pseudobefehle zur Datenablage sind jetzt
                 auch für 65816/MELPS-7700 zulässig (r6);

               - für 65816/MELPS-7700 kann die Adreßlänge jetzt durch
                 Präfixe explizit festgelegt werden (r6);

               - unterstützt zusätzlich die 8X30x-Familie von Sig-
                 netics (r6);


        H. Hinweise zum Quellcode von AS
	================================

Wie in der Einleitung erwähnt, gebe ich nach Rücksprache den Quellcode
von AS heraus.  Im folgenden sollen einige Hinweise zu dessen Handhabung
gegeben werden.


	H.1. Sprachvoraussetzungen
	--------------------------

AS ist in Turbo-Pascal implementiert worden.  "Aua", höre ich jetzt
die C-Freaks schreien, "in C geht so etwas doch viel besser, außerdem
ist es dann beliebig portabel!"  Jaaaa, wenn das alles so einfach
wäre...AS ist ein Projekt, das ich nun schon seit einigen Jahren
verfolge, und zu der Zeit, als ich damit anfing, bestand die Betriebs-
systemwelt des PC-Benutzers aus DOS, DOS und DOS, und die Erfahrung, 
daß ich ohne Festplatte schon bei Turbo-C mit 4 Disketten jonglieren
mußte, Turbo-Pascal aber immer noch auf eine paßte, wirkte noch sehr
deutlich nach.  Auch das Dickicht der Speichermodelle eines DOS-C-
Compilers machte die Sache nicht attraktiver.  Außerdem kannte ich
mich mit Turbo-Pascal am besten aus, und es war die Sprache, in der
ich am produktivsten war.  C hatte ich durchaus schon einmal auspro-
biert, und es machte auf mich einen chaotischen und archaischen Ein-
druck:

  - Die Strukturierung oberhalb der Funktionsebene hat Assemblerni-
    veau (das eines normalen Assemblers, AS kann durch das Konzept
    lokaler Variablen in dieser Hinsicht eher mehr als C), es ist
    nicht möglich, Prozeduren zu deklarieren, die lokal zu einer
    anderen Prozedur sind und auf deren Variablen zugreifen können.
    Wer portable Programme schreiben will, dem helfen Spracherwei-
    terungen wie in GNU-C hier auch nicht richtig weiter!

  - Ein dem WITH-Befehl von Pascal entsprechendes Konstrukt fehlt.

  - Es gab keine brauchbare Typ-Prüfung der Parameter bei Funktio-
    nen, wenn man sich auf den damals noch aktuellen K&R-Standard
    beschränkte.

  - Man kann keine Funktionen schreiben, die einen String als WERT
    erhalten oder zurückgeben, was den Programmierer dazu zwingt,
    per Hand umständliche und aufwendige Hin-und Herkopierereien
    durchzuführen.

All das führte dazu, daß ich Turbo-Pascal zur Implementierung von
AS benutzte, und bis heute ist das so geblieben.  Die Zeiten haben
sich aber geändert: Mit der Einstellung der Turbo/Borland-Pascal-
Linie durch Borland gibt es an aktuellen Pascal-Compilern nur noch
so etwas wie Delphi, das m.E. eigentlich nur zur Entwicklung von
Programmen taugt, die aus 90% Oberfläche bestehen, für ein kommando-
zeilengesteuertes Programm wie AS also völlig ungeeignet ist. 
Außerdem hat sich mein betriebssystemmäßiger Schwerpunkt inzwischen
deutlich in Richtung Unix verschoben, und der ANSI-Standard hat sich
inzwischen durchgesetzt.  Eine Portierung der AS-Sourcen auf C habe
ich daher inzwischen fast beendet, momentan ist die Pascal-Version 
aber noch die "Referenz".  Zum Übersetzen wird Borland-Pascal in 
der Version 7 empfohlen; mit Version 6 geht es zur Not zwar auch,
man kann einige Features (wie Protected Mode) aber nicht ausnutzen.

Ein nicht ganz unwichtiger Hinweis für Anwender der Version 7.0 von
Turbo/Borland-Pascal: Wie sich schon länger herumgesprochen hat, hat
diese Version einige Bugs, weshalb Borland auch gezwungen war, die
Version 7.01 herauszugeben.  Bei AS tritt das Problem auf, daß
teilweise Longint-Schiebebefehle mit einer Amplitude von mehr als 16
verwendet werden, für die die Version 7.0 eine fehlerhafte 386-Opti-
mierung enthält.  Wenn Sie (wie ich) nicht das Geld für den Update
auf 7.01 ausgeben wollen und die Quellen der Laufzeitbibliothek
besitzen, können Sie den Fehler auch selber beseitigen, indem Sie die
beiden fehlerhaften Routinen in LONG.ASM austauschen, z.B. so:

; Longint shift right
; In	DX:AX = Value
;	CX    = Shift count
; Out	DX:AX = Result
; Correction 11.6.1994 AA

LongShr:

	CMP	Test8086,2
	JB	@@1
    .386
        SHL     EAX,16
        SHRD    EAX,EDX,16
        SHR     EAX,CL
        SHLD    EDX,EAX,16
	RETF
    .8086
@@1:	AND	CX,1FH
	JE	@@3
@@2:	SHR	DX,1
	RCR	AX,1
	LOOP	@@2
@@3:	RETF

; Longint shift left
; In	DX:AX = Value
;	CX    = Shift count
; Out	DX:AX = Result
; Correction 11.6.1994 AA

LongShl:

	CMP	Test8086,2
	JB	@@1
    .386
        SHL     EAX,16
        SHRD    EAX,EDX,16
        SHL     EAX,CL
        SHLD    EDX,EAX,16
	RETF
    .8086
@@1:	AND	CX,1FH
	JE	@@3
@@2:	SHL	AX,1
	RCL	DX,1
	LOOP	@@2
@@3:	RETF

Wer keine Quellen hat, kann alternativ auch als "Notlösung" die Vari-
able Test8086 im Hauptprogramm auf einen Wert <2 setzen und so die
Optimierungen ganz unterbinden...


        H.2 Modulaufteilung
        -------------------

Programme in der Größe von AS müssen notwendigerweise in mehrere Mo-
dule aufgespalten werden, nicht nur um eine vernünftige Strukturie-
rung zu erreichen, sondern auch, um unter DOS die ewige 64Kbyte-
Grenze zu überwinden.  Im einzelnen besteht AS aus folgenden Modulen:

        STDINC.PAS

Dies ist im eigentlichen Sinne kein Modul, sondern eine Include-Datei,
die von allen anderen Modulen eingebunden wird.  Sie enthält die
unvermeidlichen Compiler-Schalter, die sich je nach Zielplattform
etwas unterscheiden.

	AS.PAS

Diese Datei enthält das Hauptmodul von AS und muß demzufolge in der
IDE als Hauptdatei eingetragen werden.  Sie beinhaltet die überge-
ordnete Steuerung der einzelnen Durchläufe, das Einlesen der Quell-
dateien sowie Teile des Makroprozessors.  Dieser Programmteil ist
unabhängig vom Zielprozessor.

        ASMDEF.PAS

Dieses Modul enthält lediglich Deklarationen von überall benötigten
Konstanten und gemeinsam benutzten Variablen.  

        ASMSUB.PAS

Hier finden sich gesammelt einige häufig gebrauchte Unterroutinen,
welche in erster Linie die Bereiche Stringbearbeitung und Fehler-
behandlung abdecken.

        ASMPARS.PAS

Hier geht es ins Eingemachte: In diesem Modul werden die Symbolta-
bellen (global und lokal) in zwei Binärbäumen verwaltet.  Außerdem
findet sich hier eine ziemlich große Prozedur EvalExpression, wel-
che einen (Formel-)ausdruck analysiert und auswertet.  Die Proze-
dur liefert das Ergebnis (Integer, Gleitkomma oder String) in
einem varianten Record zurück.  Zur Auswertung von Ausdrücken bei
der Codeerzeugung sollten allerdings eher die Funktionen EvalInt-
Expression, EvalFloatExpression und EvalStringExpression verwendet
werden.  Änderungen zum Einfügen neuer Prozessoren sind hier nicht
erforderlich und sollten auch nur mit äußerster Überlegung erfolgen,
da man hier sozusagen an "die Wurzel" von AS greift.

	ASMMAC.PAS

In diesem Modul finden sich die Routinen zur Speicherung und
Abfrage von Makros.  Der eigentliche Makroprozessor befindet sich
in AS.PAS!!

	ASMIF.PAS

Hier befinden sich alle Routinen, die die bedingte Assemblierung
steuern.  Exportiert wird als wichtigste Variable das Flag IfAsm,
welches anzeigt, ob Codeerzeugung momentan ein- oder ausgeschal-
tet ist.

        ASMCODE.PAS

In diesem Modul befindet sich die Verwaltung der Code-Ausgabedatei. 
Exportiert wird ein Interface, mit dem sich eine Code-Datei öffnen
und schließen läßt, und das Routinen zum Einschreiben (und
Zurücknehmen) von Code anbietet.  Eine wichtige Aufgabe dieses Moduls
ist die Pufferung des Schreibvorgangs, die die Ausgabegeschwindigkeit
erhöht, indem der erzeugte Code in größeren Blöcken geschrieben wird.

	CODEALLG.PAS

In diesem Modul werden all die Befehle bearbeitet, die für alle Pro-
zessoren definiert sind, z.B. EQU und ORG.  Hier findet sich auch
der  CPU-Befehl, mit dem zwischen den einzelnen Prozessoren hin-und
hergeschaltet wird.

	CODEPSEU.PAS

Hier finden sich Pseudobefehle, die von mehreren Codegeneratoren ver-
wendet werden.  Dies ist einmal die Intel-Gruppe mit der DB..DT-
Gruppe, zum anderen die Pendants für die 8/16-Bitter von Motorola oder
Rockwell.  Wer in diesem Bereich um einen Prozessor erweitern will,
kann mit einem Aufruf den größten Teil der Pseudobefehle erschlagen.

	DECODECM.PAS

Dieses Modul implementiert den Mechanismus der Kommandozeilenparameter.
Es benötigt eine Spezifikation der erlaubten Parameter, zerlegt die
Kommadozeile und ruft die entsprechenden Callbacks auf.
Der Mechanismus leistet im einzelnen folgendes:

  - Mitbearbeitung von Optionen in einer Environment-Variablen oder
    entsprechenden Datei;

  - Rückgabe einer Menge, welche die noch nicht bearbeiteten Kommando-
    zeilenparameter beschreibt;

  - Trenunng von positiven und negativen Schaltern;

  - Eine Hintertür, falls die darüberliegende Entwicklungsumgebung die
    Kommandozeile nur in Groß- oder Kleinschreibung übergibt.

Dieses Modul wird nicht nur von AS, sondern auch von den Hilfsprogram-
men BIND, P2HEX und P2BIN verwendet.

	STDHANDL.PAS

Dieses mit Abstand kürzeste Modul dient nur einem einzigen Zweck (und
ist vielleicht auch in anderen Programmen nützlich).  Es ergänzt
Pascal um die von C her bekannte Möglichkeit, auf die neben Standard-
eingabe und -ausgabe von DOS vordefinierten Kanäle

 - STDERR (Ausgabe Fehlermeldungen)
 - STDPRN (Default-Drucker)
 - STDAUX (serielle Schnittstelle)

über normale Text-Variablen zuzugreifen.  AS benutzt momentan nur
STDERR.

	NLS.PAS

Hiermit wird ein Thema abgehandelt, das sowohl von Borland als auch
den meisten Programmierern eher stiefmütterlich behandelt wird: der
National Language Support (kurz NLS), den es bei DOS schon seit
Version 2.0 gibt.  Diese Unit liefert die Informationen über Dinge,
die sich von Land zu Land unterscheiden:

- Datumsformat: Reihenfolge von Tag, Monat und Jahr sowie das Trenn-
  zeichen;
- Zeitformat: 12- oder 24-Stunden-Format;
- Umsetzung von Klein- in Großbuchstaben;
- Trennzeichen für Tausender- und Nachkommastellen;
- Währungsname und -format;
- Sortierreihenfolge von Zeichen.

AS benutzt noch nicht alle von dieser Unit angebotenen Informationen
(was will man auch dort mit Geldbeträgen? :-) ), die NLS-Unterstüt-
zung wird in Zukunft aber noch besser werden.  Insbesondere diese
Unit bietet sich zur Verwendung in anderen Programmen an: Durch
schlichtes Einbinden erhält man eine korrekt für alle Zeichen arbei-
tende UpCase-Funktion, die Borland uns schon seit Jahren vorenthält!

        STRINGLI.PAS

Dies ist nur ein kleiner "Hack", der Routinen zur Verwaltung von linearen
Listen mit Strings als Inhalt definiert, welche z.B. im Makroprozessor von
AS gebraucht werden.

        STRINGUT.PAS

Hier sind einige häufig genutzte String-Operationen gelandet.

        CHUNKS.PAS

Dieses Modul definiert einen Datentyp, mit dem eine Liste von Adreß-
bereichen verwaltet werden kann.  Dies Funktion wird von AS für die 
Belegungslisten benötigt, außerdem benutzten P2BIN und P2HEX diese 
Listen, um vor Überlappungen zu warnen.

        INCLIST.PAS

In diesem Modul ist die Listenstruktur definiert, über die AS die 
Verschachtelung von Include-Dateien im Listing ausgeben kann.

        FILENUMS.PAS

Dateinamen werden von AS an vielen Stellen tokenisiert, d.h. in Form
numerischer Codes gespeichert.  In diesem Modul werden die Listen
verwaltet, die eine Hin-und Herwandlung zwischen Dateinamen und Token
ermöglichen.

	CODExxxx.PAS

Diese Dateien schlußendlich enthalten die eigentlichen Codegeneratoren
für die verschiedenen Prozessoren.  Sie sind alle nach dem gleichen
Schema aufgebaut (natürlich mit unterschiedlichem Inhalt!), das im
folgenden Abschnitt erklärt wird.


        H.3 Neuer Prozessor...was nun ?
	-------------------------------

Der mit Abstand häufigste Grund, im Quellcode von AS etwas zu ver-
ändern, dürfte wohl die Erweiterung um einen neuen Zielprozessor
sein.  Das Verfahren der Definition eines neuen Prozessors hat sich
mit V1.39p5 drastisch geändert: Es ist wesentlich indirekter geworden,
hat aber den Vorteil, daß in den Standard-Modulen von AS nur noch an
EINER Stelle etwas geändert werden muß.  Es beruht sehr stark auf in-
direkten Verweisen und Prozedurvariablen, verlangt also schon etwas
vertiefte Kenntnisse von (Turbo-)Pascal.  Wer aber in Assembler pro-
grammiert, sollte damit keine grundsätzlichen Probleme haben.
Im folgenden will ich kochbuchartig die zum Einhängen erforderlichen
Schritte beschreiben:


	Festlegung des Prozessornamens
	- - - - - - - - - - - - - - -

Der für den Prozessor zu wählende Name muß zwei Kriterien erfüllen:

 1. Der Name darf noch nicht von einem anderen Prozessor belegt sein.
    Beim Aufruf von AS ohne Parameter erhält man eine Liste der be-
    reits vorhandenen Typen.

 2. Soll der Prozessorname vollständig in der Variablen MOMCPU auf-
    tauchen, so darf er außer am Anfang keine Buchstaben außerhalb
    des Bereiches von A..F enthalten.  In der Variablen MOMCPUNAME
    liegt aber zur Assemblierzeit immer der volle Name vor.
    Sonderzeichen sind generell nicht erlaubt, Kleinbuchstaben
    werden vom CPU-Befehl bei der Eingabe in Großbuchtaben umgewan-
    delt und sind daher auch nicht im Prozessornamen sinnvoll.


	Definition des Codegeneratormoduls
	- - - - - - - - - - - - - - - - -

Die Unit, die für den neuen Prozessor zuständig sein soll, sollte
einer gewissen Einheitlichkeit wegen den Namen CODExxxx tragen,
wobei xxxx etwas mit dem Prozessornamen zu tun haben sollte.  Den
Kopf mit den Compilerschaltern sowie den Uses-Anweisungen übernimmt
man am besten direkt aus einer bereits vorhandenen Codegenerator-Unit.

Die Unit selber muß weder Variablen noch Prozeduren oder Funktionen
nach außen exportieren, da die ganze Kommunikation zur Laufzeit über
indirekte Sprünge abgewickelt wird.  Die dazu erforderlichen Initia-
lisierungen müssen im Initialisierungsteil der Unit vorgenommen
werden, indem für jeden von der Unit zu behandelnden Prozessortyp
ein Aufruf der Funktion AddCPU erfolgt:

   CPUxxxx:=AddCPU('XXXX',SwitchTo_xxxx);

'XXXX' ist dabei der für den Prozessor festgelegte Name, der später
im Assemblerprogramm verwendet werden muß, um AS auf diesen Zielpro-
zessor umzuschalten.  SwitchTo_xxxx (im folgenden kurz als "Umschal-
ter" bezeichnet) ist eine parameterlose Prozedur, die von AS aufge-
rufen wird, sobald auf diesen Prozessor umgeschaltet werden soll.
Als Ergebnis liefert AddCPU eine Zahlenwert, der als interne "Ken-
nung" für diesen Prozessor fungiert.  In der globalen Variablen
MomCPU wird ständig die Kennung des momentan gesetzten Zielprozes-
sors mitgeführt.  Der von AddCPU gelieferte Wert sollte in einer
privaten Variable des Typs CPUVar (hier CPUxxxx genannt) abgelegt
werden.  Falls ein Codegeneratormodul verschiedene Prozessoren (z.B.
einer Familie) verwaltet, kann es so durch Vergleich von MomCPU
gegen diese Werte feststellen, welche Befehlsuntermenge momentan
zugelassen ist.

Dem Umschalter obliegt es, AS auf den neuen Zielprozessor "umzupo-
len".  Dazu müssen im Umschalter einige globale Variablen besetzt
werden:

  - ConstMode: Diese Variable kann die Werte ConstModeIntel,
    ConstModeMoto oder ConstModeC haben und bestimmt, in welcher
    Form Zahlensysteme bei Integerkonstanten spezifiziert werden
    sollen.

  - PCSymbol: Diese Variable enthält den String, mit dem aus dem As-
    sembler-Programm heraus der momentane Stand des Programmzählers
    abgefragt werden kann.  Für Intel-Prozessoren ist dies z.B. ein
    Dollarzeichen.

  - HeaderID: Dieses Byte enthält die Kennung, mit der in der Code-
    datei die Prozessorfamilie gekennzeichnet wird (s. das Kapitel,
    welches das Code-Format von AS beschreibt).  Um Zweideutigkeiten
    zu vermeiden, bitte ich, den Wert mit mir abzusprechen.  Auf
    jeden Fall sollten Werte außerhalb des Bereiches $01..$7f benutzt
    werden, diese sind für Sonderzwecke (wie z.B. eine zukünftige
    Erweiterung um einen Linker) reserviert.

  - NOPCode: In bestimmten Situationen kann es sein, daß AS unbenutz-
    te Bereiche im Code mit NOPs auffüllen muß.  Diese Variable be-
    inhaltet den dazu erforderlichen Code.

  - SetIsOccupied: Einige Prozessoren verwenden SET als Maschinenbe-
    fehl.  Wird diese Variable gesetzt, so gibt AS SET-Befehle an den
    Codegenerator weiter und verwendet stattdessen EVAL.

  - ValidSegs: Nicht alle Prozessoren definieren alle von AS unter-
    stützten Adreßräume.  Mit dieser Menge legt man fest, welche
    Untermenge für den jeweiligen Prozessor von SEGMENT-Befehl zu-
    gelassen wird.  Im mindesten muß das Code-Segment freigeschaltet
    werden.  Die Gesamtmenge aller vorhandenen Segmenttypen kann im
    Modul ASMDEF nachgelesen werden (Seg.....-Konstanten).

  - SegInits: Dieses Feld speichert die initialen (ohne ORG-Befehl)
    Startadressen in den einzelnen Segmenten.  Nur in Ausnnahme-
    fällen (physikalisch überlappende, aber logisch getrennte Adreß-
    räume) sind hier andere Werte als 0 sinnvoll.

  - Grans: Hiermit kann für jedes Segment die Größe des kleinsten
    adressierbaren Elements in Bytes festgelegt werden, d.h. die
    Größe des Elements, für das eine Adresse um eins erhöht wird.
    Bei den allermeisten Prozessoren (auch 16 oder 32 Bit) ist dies
    ein Byte, nur Signalprozessoren und die PICs fallen z.B. aus dem
    Rahmen.

  - ListGrans: Hiermit kann wieder für alle Segmente getrennt fest-
    gelegt werden, in was für Gruppen die Bytes im Assemblerlisting
    dargestellt werden sollen.  Beim 68000 sind z.B. Befehle immer
    ein mehrfaches von 2 Bytes lang, weshalb die entsprechende Va-
    riable auf 2 gesetzt ist.

  - TurnWords: Falls der Prozessor ein Big-Endian-Prozessor sein
    sollte und eines der Elemente von ListGrans ungleich eins ist,
    sollte dieses Flag auf True gesetzt werden, um korrekte Code-
    Dateien zu erhalten.

  - DivideChars: Dieser String enthält all jene Zeichen, die als
    Trennzeichen für die Parameter eines Assemblerbefehls zugelassen
    sind.  Nur für extreme Ausreißer (wie den DSP56) sollte sich in
    diesem String etwas anderes finden als ein Komma.

  - HasAttrs: Einige Prozessoren wie die 68k-Reihe teilen einen
    Maschinenbefehl durch einen Punkt noch weiter in Mnemonic und
    Attribut auf.  Ist dies beim neuen Prozessor auch der Fall, so
    ist dieses Flag auf True zu setzen.  AS liefert dann die Einzel-
    teile in den Variablen OpPart und AttrPart.  Setzt man es dagegen
    auf False, so bleibt der Befehl in OpPart zusammen, und AttrPart
    ist immer leer.  Sofern der Prozessor keine Attribute verwendet,
    sollte man HasAttrs auf jeden Fall auf False setzen, da man sich
    sonst die Möglichkeit nimmt, Makros mit einem Punkt im Namen
    (z.B. zur Emulation anderer Assembler) zu definieren.

  - AttrChars: Falls HasAttrs gesetzt wurde, müssen in diesem String
    alle Zeichen eingetragen werden, die das Attribut vom Befehl
    trennen können.  Meist ist dies nur der Punkt.

Gehen Sie nicht davon aus, daß eine dieser Variablen einen vordefi-
nierten Wert hat, sondern besetzen Sie ALLE Felder neu!!

Neben diesen Variablen sind noch drei Prozedurvariablen zu besetzen,
die die Verbindung von AS zu den "aktiven" Teilen des Codegenerator-
moduls herstellen:

  - MakeCode: Diese Routine wird nach der Zerlegung einer Zeile
    in Mnemonic und Parameter aufgerufen.  Das Mnemonic liegt in der
    Variablen OpPart, die Parameter in dem Feld ArgStr.
    Die Zahl der Parameter kann aus der Variablen ArgCnt ausgelesen
    werden.  Das binäre Ergebnis muß in dem Byte-Feld BAsmCode abge-
    legt werden, dessen Länge in der Variablen CodeLen.  Falls der
    Prozessor wortorientiert wie der 68000 oder viele Signalprozesso-
    ren ist, kann Feld auch wortweise als WAsmCode adressiert werden.
    Für ganz extreme Fälle gibt es auch noch DAsmCode ... Die Code-
    länge wird ebenfalls in solchen Einheiten angegeben.

  - ChkPC: Obwohl AS die Programmzähler intern durchgängig mit
    32 Bit verwaltet, benutzen die meisten Prozessoren nur einen
    kleineren Adreßraum.  Diese Funktion liefert AS Informationen, ob
    der momentane Programmzähler den erlaubten Bereich überschritten
    hat.  Bei Prozessoren mit mehreren Adreßräumen kann diese Routine
    natürlich deutlich komplizierter ausfallen.  Ein Beispiel dafür
    findet sich z.B. im Modul Code51.  Falls alles in Ordnung ist,
    muß die Funktion TRUE zurückliefern, ansonsten FALSE.
    VORSICHT!  Da Turbo-Pascal momentan noch keine vorzeichenlosen
    32-Bit-Integers kennt, muß hier damit gerechnet werden, daß der
    Programmzählerwert negativ ist!  Eine Abfrage, ob der momentane
    Wert kleiner Null ist, ist daher keine Schönheitsoperation, son-
    dern unbedingt notwendig!

  - IsDef: Bestimmte Prozessoren kennen neben EQU noch weitere
    Pseudobefehle, bei denen ein in der ersten Spalte stehender
    Symbolname kein Label darstellt, z.B. BIT beim 8051.  Diese
    Funktion muß TRUE zurückliefern, falls ein solcher, zusätz-
    licher Befehl vorliegt.  Im einfachsten Fall braucht nur FALSE
    zurückgeliefert zu werden.

  - SwitchFrom: Diese parameterlose Prozedur erlaubt dem Codegene-
    ratormodul, noch "Aufräumarbeiten" durchzuführen, wenn auf einen
    anderen Zielprozessor umgeschaltet wird.  So kann man an dieser
    Stelle z.B. Speicher freigeben, der im Umschalter belegt wurde
    und nur benötigt wird, während dieses Codegeneratormodul aktiv
    ist.  Im einfachsten Fall zeigt diese Prozedurvariable auf eine
    leere Prozedur.  Ein Beispiel für die Anwendung dieser Prozedur
    finden Sie im Modul CODE370, das seine Codetabellen dynamisch
    erzeugt und wieder freigibt.

Die Routinen, auf die diese drei Prozedurvariablen zeigen, sind alle
parameterlos und müssen (wie der Umschalter übrigens auch) als FAR
deklariert werden, sonst können sie nicht einer Prozedurvariable zu-
gewiesen werden.

Bei Bedarf kann sich die Unit im Initialisierungsteil noch in die
Kette aller Funktionen eintragen, die vor Beginn eines Durchlaufes
durch den Quelltext ausgeführt werden.  Dies ist z.B. immer dann der
Fall, wenn die Code-Erzeugung im Modul abhängig vom Stand bestimmter,
durch Pseudobefehle beeinflußbarer Flags ist.  Ein häufig auftreten-
der Fall ist z.B., daß ein Prozessor im User- oder Supervisor-
Modus arbeiten kann, wobei im User-Modus bestimmte Befehle gesperrt
sind.  Im Assembler-Quelltext könnte dieses Flag, das angibt, in wel-
chem Modus der folgende Code ausgeführt wird, durch einen Pseudobe-
fehl umgeschaltet werden.  Es ist aber dann immer noch eine Initia-
lisierung erforderlich, die sicherstellt, daß in allen Durchläufen
ein identischer Ausgangszustand vorliegt.  Der über die Prozedur-
variable InitPassProc angebotene Haken bietet die Möglichkeit, der-
artige Initialisierungen vorzunehmen.  Das verwendete Prinzip ähnelt
dabei dem Einhängen in einen Interruptvektor: In der Initialisierung
der Unit wird der alte Wert von InitPassProc gesichert.  Danach kann
InitPassProc auf die hinzuzufügende Routine (parameterlose, FAR
deklarierte Prozedur) umgebogen werden.  Die neue Routine ruft dann
zuerst die alte Initialisierungsroutine auf und führt danach ihre
eigenen Operationen durch.

Analog zu InitPassProc funktioniert die über CleanUpProc aufgebaute
Prozedurkette, die es den Codegeneratoren erlaubt, nach dem Abschluß
der Assemblierung noch Aufräumarbeiten (z.B. das Freigeben von
Literaltabellen o.ä.) durchzuführen.  Dies ist sinnvoll, wenn mehrere
Dateien mit einem Aufruf assembliert werden, sonst hätte man noch
"Müll" aus einem vorigen Lauf in den Tabellen.  Momentan nutzt kein
Modul diese Möglichkeit.

Bisweilen sind bei einem bestimmten Prozessor Symbole definiert,
ohne daß man sie irgendwo explizit erzeugen müßte.  Ein Beispiel
ist z.B. die TMS370-Reihe, bei der z.B. die ersten 256 Speicherzel-
len als "Register" R0..R255 bzw. R0FF angesprochen werden können.
Dafür existiert in AS eine Prozedurvariable InternSymbol, die vom
Codegenerator belegt werden kann.  Wann immer der Formelparser einen
Ausdruck analysieren muß, ruft er diese Routine nach der Untersuchung
auf Konstanten hin auf.  Falls die Routine ein vordefiniertes Symbol
erkennt, muß sie das Ergebnis in einen übergebenen Record des Typs
TempResult eintragen, d.h. das Feld Typ mit der Art des Ergebnisses
(TempInt für Integer, TempFloat für Gleitkomma oder TempString für
Strings) belegen sowie das eigentliche Ergebnis in eines der Felder
Int, Float oder Ascii eintragen.  War die Untersuchung erfolglos, so
schreiben Sie einfach TempNone in das Feld Typ.  Fehlermeldungen aus
dieser Routine heraus sollten vermieden werden, da nicht zu identi-
fizierende Namen normale Symbole bezeichnen könnten (was der Parser
dann im folgenden abprüft).  Seien Sie vorsichtig mit dieser Routine,
da Sie mit ihr mitten in den Parser hineingreifen können!

Wer will, kann sich übrigens auch mit einem Copyright-Eintrag ver-
ewigen, indem er in der Initialisierung der Unit (bei den AddCPU-
Befehlen) einen Aufruf der Prozedur AddCopyright einfügt, in der
folgenden Art:

    AddCopyright("Intel 80986-Codegenerator (C) 2010 Hubert Simpel");

Der übergebene String wird dann nach dem Programmstart zusätzlich
zu der Standardmeldung ausgegeben.


	Eintragen des Codegeneratormodules
	- - - - - - - - - - - - - - - - -

So schwierig die formal richtige Definition des Moduls ist, so
trivial wird dadurch seine Einbindung: Im Hauptmodul AS.PAS muß le-
diglich die USES-Liste um dieses Modul erweitert werden.  Ob
diese Modul auch als Overlay definiert werden soll, ist eine Abwä-
gung zwischen Geschwindigkeit und freiem Speicherplatz.


	Schreiben des eigentlichen Codegenerators
	- - - - - - - - - - - - - - - - - - - - -

Hier ist nun endlich eigene Kreativität gefragt: Wie Sie es schaffen,
aus dem Mnemonic und den Argumenten die Code-Bytes zu erzeugen, ist
weitgehend Ihnen überlassen.  Zur Verfügung stehen dafür natürlich
über den Formelparser die Symboltabellen sowie die Routinen aus
ASMSUB.  Ich kann hier nur einige generelle Regeln aufstellen:

  - Versuchen Sie, die Prozessorbefehle in Gruppen aufzusplitten, die
    gleiche Operanden erwarten und sich nur in einigen Kennbits unter-
    scheiden.  Alle argumentlosen Befehle kann man z.B. so in einer
    Tabelle abhandeln.

  - Die meisten Prozessoren haben ein festes Repertoire von Adres-
    sierungsarten.  Verlagern Sie das Parsing eines Adreßausdrucks
    in eine getrennte Unterroutine.

  - Die Routine WrError definiert eine Vielzahl von möglichen Fehler-
    meldungen und ist bei Bedarf leicht erweiterbar.  Nutzen Sie
    das!  Bei allen Fehler nur lapidar einen "Syntaxfehler" zu melden,
    nützt niemandem!

Mit Sicherheit wird auch das Studium der vorhandenen Module weiter-
helfen.


	Modifikation der Dienstprogramme
	- - - - - - - - - - - - - - - -

Damit PLIST Codedateien weiterhin vollständig anzeigen kann, muß das
Feld mit den vorhandenen Code-Headern erweitert werden.

Sollte ein Segment eine andere Granularität als 1 Byte/Adresse
aufweisen (s. die Variable Grans oben), so muß die Funktion Granula-
rity in TOOLS.PAS erweitert werden.  Damit P2HEX sich nicht mit einer
Fehlermeldung abmeldet, muß noch entschieden werden, welches Hex-
Format defaultmäßig für diesen Prozessor verwendet werden soll.
P2HEX kennt bisher Motorola S-Records (bis 32-Bit-Adressen) sowie
Intel-, Tektronix- und MOS-HEX (16-Bit-Adressen).  Die CASE-Abfrage in
ProcessFile muß nur entsprechend erweitert werden.


	H.4 RSC...was ist das denn?
	---------------------------

Falls es einmal erforderlich sein sollte, AS auf eine andere Sprache
anzupassen, sind sämtliche String-Konstanten im Programm zu ändern.
Damit dies einigermaßen leicht möglich ist, finden sich diese konzen-
triert in den RSC-Dateien.  IOERRORS.RSC enthält alle E/A-Fehlermel-
dungen und wird sowohl von AS als auch den Dienstprogrammen genutzt.
TOOLS.RSC enthält die von allen Dienstprogrammen gleichermaßen be-
nötigten Stringkonstanten.  Ansonsten hat jedes Programm seine eigene
Datei.  Solange Sie nicht vorhaben, AS in eine andere Sprache zu
übersetzen, brauchen Sie sich nicht weiter um diese Dateien zu küm-
mern.


	I. Literaturhinweise/Referenzen
	===============================

[Williams]	Steve Williams:
		68030 Assembly Language Reference
		Addison-Wesley, Reading, Massachusetts, 1989

[AMD29K]	Advanced Micro Devices:
		AM29240, AM29245, and AM29243 RISC Microcontrollers.
		1993

[AtAVR]         Atmel Corp.:
                AVR Enhanced RISC Microcontroller Data Book.
                May 1996

[CMD816]  	CMD Microcircuits:
		G65SC802/G65SC816 CMOS 8/16-Bit Microprocessor
		Family Data Sheet.

[CPM68K]  	Digital Research:
		CP/M 68K Operating System User's Guide
        	1983

[Cyrix]  	Cyrix Corp.:
		FasMath 83D87 User's Manual
		1990

[Dallas320]  	Dallas Semiconductor:
		DS80C320 High-Speed Micro User's Guide.
		Version 1.30, 1/94

[Hit180]  	Hitachi Ltd.:
		8-/16-Bit Microprocessor Data Book
		1986

[Hit63]  	Trevor J.Terrel & Robert J. Simpson:
		Understanding HD6301X/03X CMOS Microprocessor Systems
		erschienen bei Hitachi

[HitH8_3]  	Hitachi Microcomputer:
		H8/300H Series Programming Manual.
		(21-032, keine Jahresangabe)

[SH7000] 	Hitachi Semiconductor Design & Development Center:
		SH Microcomputer Hardware Manual (Preliminary)

[HitH8_5] 	Hitachi Semiconductor and IC Div:
        	H8/500 Series Programming Manual
        	(21-20, 1st Edition Feb. 1989)

[HitH8_532] 	Hitachi Ltd.:
        	H8/532 Hardware Manual
		(21-30, keine Jahresangabe)

[HitH8_534] 	Hitachi Ltd.:
        	H8/534,H8/536 Hardware Manual
		(21-19A, keine Jahresangabe)

[PPC403] 	IBM Corp.:
		PPC403GA Embedded Controller User's Manual.
        	First Edition, September 1994

[IntEmb] 	Intel Corp.:
		Embedded Controller Handbook
		1987

[IntMic] 	Intel Corp.:
		Microprocessor and Peripheral Handbook.
		Volume I Microprocessor
		1988

[Int196]        Intel Corp.:
                8XC196NT Microcontroller User's Manual
                June 1995 

[Int251]        Intel Corp.:
                8XC251SB High Performance CHMOS Single-Chip
                Microcontroller
                Sept. 1995, Order Number 272616-003

[Int296]        Intel Corp.:
                80296SA Microcontroller User's Manual
                Sept. 1996 

[Kaku] 		Hirotsugu Kakugawa:
		A memo on the secret features of 6309.
        	(erhältlich über World Wide Web:
        	http://www.cs.umd.edu/users/fms/comp/CPUs/6309.txt)

[MicroChip] 	Microchip Technology Inc.:
		Microchip Data Book.
		1993 Edition

[Mit41] 	Mitsubishi Electric:
		Single-Chip 8-Bit Microcomputers.
        	Vol.2, 1987

[Mit16] 	Mitsubishi Electric:
		Single-Chip 16-Bit Microcomputers.
		Enlarged edition, 1991

[Mit8] 		Mitsubishi Electric:
		Single-Chip 8 Bit Microcomputers.
        	Vol.2, 1992

[Mit4500] 	Mitsubishi Electric:
		M34550Mx-XXXFP Users's Manual.
		Jan. 1994

[MitM16] 	Mitsubishi Electric:
        	M16 Family Software Manual.
        	First Edition, Sept. 1994

[MitM16C] 	Mitsubishi Electric:
        	M16C Software Manual.
        	First Edition, Rev. C, 1996

[Mit30600]      Mitsubishi Electric:
                M30600-XXXFP Data Sheet
                First Edition, April 1996

[GreenM16] 	Dokumentation zum M16/M32-Entwicklungspaket von Green
     		Hills Software

[MotMic] 	Motorola Inc.:
		Microprocessor, Microcontroller and Peripheral Data.
		Vol. I+II, 1988

[Mot81] 	Motorola Inc.:
		MC68881/882 Floating Point Coprocessor User's Manual.
		Second Edition, Prentice-Hall, Englewood Cliffs 1989

[Mot51] 	Motorola Inc.:
		MC68851 Paged Memory Management Unit User's Manual.
		Second Edition, Prentice-Hall, Englewood Cliffs 1989,1988

[Mot32] 	Motorola Inc.:
		CPU32 Reference Manual.
        	Rev. 1, 1990

[Mot56] 	Motorola Inc.:
		DSP56000/DSP56001 Digital Signal Processor User's Manual.
		Rev. 2, 1990

[Mot340] 	Motorola Inc.:
		MC68340 Technical Summary.
        	Rev. 2, 1991

[Mot16]         Motorola Inc.:
                CPU16 Reference Manual.
                Rev. 1, 1991

[Mot332] 	Motorola Inc.:
		MC68332 Technical Summary.
        	Rev. 2, 1993

[Mot601] 	Motorola Inc.:
		PowerPC 601 RISC Microprocessor User's Manual.
		1993

[Mot505]	Motorola Inc.:
		PowerPC(tm) MPC505 RISC Microcontroller Technical Summary.
        	1994

[Mot12]         Motorola Inc.:
                CPU12 Reference Manual.
                1st edition, 1996

[Mot08]         Motorola Inc.:
                CPU08 Reference Manual.
                Rev. 1 (keine Jahresangabe im PDF-File)

[Mot360]        Motorola Inc:
                MC68360 User's Manual

[SCMP]          National Semiconductor:
                SC/MP Programmier- und Assembler-Handbuch.
                Publication Number 4200094A, Aug. 1976

[AsmCop]        National Semiconductor:
                COP800 Assembler/Linker/Librarian User's Manual.
                Customer Order Number COP8-ASMLNK-MAN
                NSC Publication Number 424421632-001B
                August 1993

[Cop87L84]      National Semiconductor:
                COP87L84BC microCMOS One-Time-Programmable (OTP) Microcontroller.
                Preliminary, March 1996

[NECV] 		NEC Corp.:
		µpD70108/µpD70116/µpD70208/µpD70216/µpD72091 Data Book.
		(keine Jahresangabe)

[NEC78] 	NEC Electronics Europe GmbH:
		User's Manual µCOM-87 AD Family.
		(keine Jahresangabe)

[NEC75] 	NEC Corp.:
		µCOM-75x Family 4-bit CMOS Microcomputer User's Manual.
        	Vol. I+II (keine Jahresangabe)

[NEC78]         NEC Corp.:
                µPD78070A, 78070AY 8-Bit Single-Chip Microcontroller
                User's Manual.
                Document No. U10200EJ1V0UM00 (1st edition), August 1995

[NEC7814]       NEC Corp.:
                Data Sheet $\mu$PD78014.

[PhilXA]        Philips Semiconductor: 
                16-bit 80C51XA Microcontrollers (eXtended Architecture)
                Data Handbook IC25, 1996

[SGS04] 	SGS-Thomson Microelectronics:
		8 Bit MCU Families EF6801/04/05 Databook.
		1st edition, 1989

[SGS62] 	SGS-Thomson Microelectronics:
		ST6210/ST6215/ST6220/ST6225 Databook.
		1st edition, 1991

[ST7Man]        SGS-Thomson Microelectronics:
                ST7 Family Programming Manual.
                June 1995

[SGS9]          SGS-Thomson Microelectronics:
                ST9 Programming Manual.
                3rd edition, 1993

[Siem166] 	Siemens AG:
		SAB80C166/83C166 User's Manual.
		Edition 6.90

[Siem167] 	Siemens AG:
		SAB C167 Preliminary User's Manual.
		Revision 1.0, July 1992

[Siem502]       Siemens AG:
                SAB-C502 8-Bit Single-Chip Microcontroller User's Manual.
                Edition 8.94

[Siem501]       Siemens AG:
                SAB-C501 8-Bit Single-Chip Microcontroller User's Manual.
                Edition 2.96

[Siem504]       Siemens AG:
                C504 8-Bit CMOS Microcontroller User's Manual.
                Edition 5.96

[Syb68K] 	C.Vieillefond:
		Programmierung des 68000
		Sybex-Verlag Düsseldorf, 1985

[Ti9900]        Texas Instruments:
                TMS9995 16-Bit Microcomputer 
                Preliminary Data Manual
                1981

[TiC10] 	Texas Instruments:
		First-Generation TMS320 User's Guide.
		1988, ISBN 2-86886-024-9

[Ti7000]        Texas Instruments:
                TMS7000 family Data Manual
                1991, DB103

[TiC30] 	Texas Instruments:
		TMS320C3x User's Guide.
		Revision E, 1991

[TiC20] 	Texas Instruments:
		TMS320C2x User's Guide.
		Revision C, Jan. 1993

[Ti370] 	Texas Instruments:
		TMS370 Family Data Manual.
		1994, SPNS014B

[Ti430FamSoft]  Texas Instruments:
                MSP430 Family Software User's Guide.
                1994, SLAUE11

[Ti430Met]      Texas Instruments:
                MSP430 Metering Application.
                1996, SLAAE10A

[Ti430FamArch]  Texas Instruments:
                MSP430 Family Architecture User's Guide.
                1995, SLAUE10A

[Tosh90] 	Toshiba Corp.:
		8-Bit Microcontroller TLCS-90 Development System Manual.
		1990

[Tosh870] 	Toshiba Corp.:
		8-Bit Microcontroller TLCS-870 Series Data Book.
		1992

[Tosh900] 	Toshiba Corp.:
		16-Bit Microcontroller TLCS-900 Series Users Manual.
		1992

[Tosh900L] 	Toshiba Corp.:
		16-Bit Microcontroller TLCS-900 Series Data Book:
		TMP93CM40F/TMP93CM41F
		1993

[Tosh47] 	Toshiba Corp.:
		4-Bit Microcontroller TLCS-47E/47/470/470A Development
		System Manual.
		1993

[Tosh9000] 	Toshiba Corp.:
		TLCS-9000/16 Instruction Set Manual Version 2.2
		10. Feb 1994

[Val8X]         Valvo GmbH:
                Bipolare Mikroprozessoren und bipolare
                LSI-Schaltungen
                Datenbuch, 1985, ISBN 3-87095-186-9

[Zilog] 	Datenblätter der Firma Zilog zur Z80-Familie

[ZilZ8] 	Zilog Inc.:
		Z8 Microcontrollers Databook.
		1992

[ZilZ8_2]       Zilog Inc.:
                Discrete Z8 Microcontrollers Databook.
                (keine Jahresangabe)

[ZilZ380] 	Zilog Inc.:
		Z380 CPU Central Processing Unit User's Manual.
        	(keine Jahresangabe)

