CAS ― The 8051 C-Assembler
━━━━━━━━━━━━━━━━━━━━━━━━━━
0. Introduction
───────────────
a. Features
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
This is a free full-featured one-pass 8051 assembler, it could very well be the first one-pass assembler
for the popular MCS-51 family of microprocessors.
What you get are the following features:
∙	Seperately assembleable files. There are two stages of assembly:
	―	Pass 1: Creation of object files
	―	Pass 1 1/3: Linking of object files
∙	Segmentation
	―	«Relative Addressing» supported for all segment types
∙	Conditional assembly, with a C-like syntax.
	Example:
		if (Condition) {
			Assembly instructions...
		} else {
			Assembly instructions...
		}
∙	Multiple statements per line with C-like syntax.
∙	C-like expression syntax.
∙	Command-line options similar to those of *NIX C compilers.
∙	An extensive archive of real-life assembly language programs,
	including a multi-tasking library and an 8051 disassembler.

Plus, if you don't want to learn all the elaborate ins and outs of this tool right away,
it is just as easy to use the first time out as any minimal assembler.

You simply will not find anything this extensive anywhere in the public domain.
But it's yours, here, for free.

Also under works: a compatible 8051 simulator kit for software developers.
What makes this kit unique is that you can (and usually must) link in your own C code
to define any arbitrary 8051 environment at all.
This gives you the flexibility to simulate the 8051 in your favorite embedded application
and to even simulate the I/O on a desktop.
A Standard Environment file is included with the package.

b. Design Philosophy ... everything is done in one pass.
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
A clean distinction is made between the two phases of assembly:
∙	creating segments and formatting image files,
∙	mapping segments and resolving references to variable addresses.

An assembly language program will normally consist of a set of assembly language modules (or source files).
Each will typically be named with the suffix ‟.s” or ‟.asm”.
In addition, there will also be a set of files, with names ending in ‟.h”
whose purpose is to provide common points of reference for declarations of objects in or related to modules.
They are incorporated in *.s or *.asm files using the ‟include” directive.

The first stage of assembly will create «Object» files, whose names end in ‟.o”: one for each assembly language module.
For instance, a module named Kernel.s will be assembled to the object file Kernel.o.

The second stage will take all the object files that have been created and «link» them together.
This process will consist mainly of completing the definitions of variables defined in one module and used in another,
and in mapping the memory segments defined in each module onto a memory image.

These two stages correspond roughly to the first and second pass of a traditional two-pass assembler.
But there are now two major differences:
(a)	the second stage can now be deferred.
	It is possible to assemble object files only, and defer the linking phase.
	Furthermore, it is possible to use the «same» object file in more than one project.
(b)	the second stage is now considerably shortened compared to the second pass of a traditional two-pass assembler
	because object files tend to be much smaller than source files
	and because the assembler no longer has to process the assembly language itself by the second stage.

1. Command line arguments
─────────────────────────
The cas assembler's command line basically follows that of a typical C compiler.
In the examples:
	(a)	cas -c kernel.s
	(b)	cas -c math.s data.s stdio.s kernel.s
	(c)	cas math.s data.s stdio.s kernel.s
	(d)	cas -o data.hex math.o data.s stdio.o kernel.s

(a)	will assemble the file kernel.s, creating kernel.o.
(b)	will assemble all the files listed, creating .o files in the process.
	If a .o file is listed with the -c option, it is ignored.
(c)	will assemble all the files listed, as in (b), and then link all the corresponding .o files.
	The output file will take the same base name as the first file listed, and will have the suffix .hex.
	Therefore, the output in this example will be math.hex.
(d)	will do the same as (c), but will name the output file data.hex.
	If a .o file is listed in either of these two command lines it will be ignored during assembly,
	but will be used during linking.

2. Directives
―――――――――――――
The following is a summary of the directives available in this language.

a. «File Inclusion» ― include "FILE"
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
This command will read the contents of the file named (FILE) into the current location of the current file.
By convention, include files should have names ending in ‟.h” or ‟.i” and should only consist of declarations.

Include files generally serve two purposes:
∙	to provide a place to store related constant definitions and declarations,
∙	to declare the globally visible objects of an assembly language module.

b. Setting current «Segment» and «Location» ― seg, at, org
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
At any point in scanning a *.s or *.asm assembly language file, the assembler will recognize a current segment and current location.
The latter can be referred to by the user as $.

To see how these items can be set, look at the following examples:
	seg code
	seg xdata at 0x8000
	seg xdata org 0x8000
	org 50
	at 50

The first example sets the current segment to the type ‟code”.
The current location is left unspecified.
«This is how relative addressing is initiated».
The actual address of the segment's start will not be determined when the object file is created,
but is deferrred until the object file is linked.

Why do things this way?
One simple reason: «Modularity».
You can now define your own assembly language module,
and convert it into an object file ready to be linked in with the rest of whatever program might be using it.
You don't have to worry about the exact address where you memory segments will be located
each time you include this module in a new program.
This makes it possible to create reuseable libraries of common assembly language functions.

The second and third example do exactly the same things because ‟at” and ‟org” are synonymous.
The latter is included only for compatibility with other assembly language programs and for familiarity's sake,
but I strongly recommend you using the former.
It simply reads nicer.

The effect of this operation is to set the current segment to ‟xdata” and the current location to 0x8000.

The last two examples are equivalent to one another and set the current location to 50 without changing the current segment.

At the very start of assembly, the current segment is set to the first segment (‟code”), and the address is left indefinite.
When different modules are linked together,
the linker will attempt to take all the segments of each type and place them in non-overlapping areas of memory,
shifting the relative segments around as needed to accomplish this goal.

What if you want to control the placement of objects, say to exclude addresses 0 to 4000 hex?
An easy way is to simply write up a module to the effect:
	seg code at 0
	ds 4000h
assemble it seperately and link it in with any program where you want to reserve this address space.

The linker tries to place your segments in exclusive areas in as tight a fit as possible.
So this module will result in the address space 0 to 4000h being excluded from the rest of your program.

The segments types supported by this 8051 assembler are the following:
∙	code:	the 8051 code address space, ranges from 0 to ffff hex.
∙	xdata:	the external data address space, same range.
∙	data:	the internal data/register space.
		Ranges from 0 to ff hex.
		Only addresses under 80 hex can be used in mnemonics involving direct addressing.

Other segment types are internally used by the assembler.
They are:
∙	sfr:	the Special Function Register space ― ranges from 80(hex) to ff(hex).
∙	bit:	the bit addressible address space.
		These comprise the individual bits in registers 20(hex) to 2f(hex),
		and the sfr addresses (hexadecimal) 80, 88, 90, 98, ..., f0, f8.

Defining a new segment with one of these types will result in an error.

c. Defining new «Labels» ― LABEL {equ,Type,set,=} Exp and LABEL:
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
These operations are defined as follows:
∙	LABEL equ Exp
		defines a constant value LABEL and sets it to the value Exp.
∙	LABEL Type Exp
		defines a constant address ‟LABEL” of the indicated type and sets it to the address given by ‟Exp”.
		The types recognized by this assembler are: code, xdata, data, sfr, and bit.
∙	LABEL:
		sets a constant address ‟LABEL” to the current address in the current segment.
∙	LABEL set Exp
		defines a variable, LABEL, and sets it to the value Exp.
∙	LABEL = Exp
		the same thing as ‟set”.

The following assembly language fragment is an illustration of these operations:
	seg code at 0
	Start: ds 0x4000
	Size equ $ - Start
	End code Start + Size

The first statement sets the current segment and location to ‟code” and 0.
The next statement is preceded by the label, ‟Start:”.
This is equivalent to the statement:
	Start code $.
What it does is define ‟Start” as a code address, and sets it to the current location (which is 0).
Following this is an instruction to reserve 4000(hex) units (bytes) of storage.
After this operation, the current location is now 0x4000.

The third instruction sets the numerical constant ‟Size” to 0x4000 - 0, or just 0x4000.
The final directive defines a code address with the name ‟End” and sets it to the address Start + Size (or just 0x4000).

Variable differ from constants in that they can be redefined.
Constants cannot be redefined.

d. Numeric labels
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
One can also define anonymous numeric labels, as in the following example:
	1:	cjne A, #0, 1f
		inc A
		movx @DPTR, A
		inc DPTR
		mov A, @R1
		inc R1
		jz 2f
		sjmp 1b
	1:	setb C
		ret
	2:	clr C
		ret
Each occurrence of ‟1:” stands for a unique anonymous label, likewise for ‟2:”.
Any number may be used in this way to denote an anonymous label.

When a label is referenced by the number followed by an ‟f”,
then the first matching numeric label «in the current segment» forward of the current location is being referred to.
In the example above, 1f and 2f refer respectively to the occurrences of 1: and 2: toward the end of the example.

When a label is referenced by the number followed by a ‟b”,
then the first matching numeric label «in the current segmment» behind the current location is being referred to.
In the example above, 1b refers to the 1: at the top of the example.

Thus, this segment is equivalent to the following:
	X1:	cjne A, #0, Y1
		inc A
		movx @DPTR, A
		inc DPTR
		mov A, @R1
		inc R1
		jz Y2
		sjmp X1
	Y1:	setb C
		ret
	Y2:	clr C
		ret

This feature saves you from the burden of defining needless names for labels that really serve as nothing more than place-holders.

e. Declaring «Global» labels ― global, public
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
Any constant directive:
	LABEL equ Exp
	LABEL Type Exp
	LABEL:
can be prefixed by ‟global” or ‟public” to result in:
	global LABEL equ Exp
	global LABEL Type Exp
	global LABEL:
or
	public LABEL equ Exp
	public LABEL Type Exp
	public LABEL:
What this does is to make these labels visible to modules other than the one where these labels are defined.
By default, all labels are visible only in the file where they are used.

f. Declaring «External» labels ― extern {Type,equ} LABEL, ..., LABEL
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
For each global label defined in a *.s or *.asm module file,
a corresponding external declaration should be made be made in whatever other module this label is to be used.
Typically, one will make these and other related declarations in a *.h file
and then «include» this file in whatever module needs the declarations.
The type must match the type of the label being referenced, if it is an address,
or it must be ‟equ” if the label referenced was a numeric constant.

For example if one declared global labels in a module Kernel.s as follows:
	public STACK_BASE data 0x80
		...
	seg code
	public Spawn:
		...
	public Resume:
		...
one would generally make the corresponding declarations:
	extern data STACK_BASE
	extern code Spawn, Resume
in a header file (say, Kernel.h),
and then include this file in any source module where the addresses STACK_BASE and Spawn might be needed.

g. Memory «Allocation» ― ds, rb, rw
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
The following operations can be used in any segment.
They are generally used to allocate space for objects and so are generally used in conjunction with ‟LABEL:” type definitions.
These are examples:
	seg code at 0
	BASIC_SEG: ds 0x4000

	seg xdata
	Byte: ds 1
	ByteArray: rb 5
	WordArray: rw 5

The first example reserves 0x4000 units (bytes) in the current segment for the variable BASIC_SEG
and then increments the current location by 0x4000.
Basically, this operation behaves as if the assignment ‟$ = $ + 0x4000” had just been carried out.

Both ‟ds” and ‟rb” are exactly equivalent, but the latter more descriptively states: reserve single-byte units.
So the second example reserves 1 byte for the variable ‟Byte”, and 5 bytes for ‟ByteArray”.

«No memory image is generated for any space skipped by ds/rb/rw.»

The third example is equivalent to:
	WordArray: rb 10
Each unit following a ‟rw” is a word, which consists of two bytes.

h. Memory «Formatting» ― db, dw
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
These operations can be used in the code segment only.
They are the only directives that can generate memory images.
The only other operations that generate memory image output are the 8051 mnemonics,
which likewise are restricted to the code segment only.

Two purpose served by these operations is mainly to initialize data, examples:
	ByteArray:	db 'a', 'b', 'c', 'd', 'e'
	String:		db "This is a string", 0

In the following examples:
	db 0x20, "String", 'c'
	dw 0x1234, 0x5678
the first operation lays out the byte 0x20 and equivalent character codes for 'S', 't', 'r', 'i', 'n', 'g', and 'c' in that order.
The current location is then increment by 8 to the location following the last item.

The second operation is equivalent to the following:
	db 0x12, 0x34, 0x56, 0x78
It formats 2-byte word units into memory.

Both of the operations: db, and dw can be followed by a comma-seperated series of numeric values or addresses.
In addition, db can accept strings, as shown in the examplex above.

i. «Conditional» assembly ― if (Ex) ST, if (Ex) ST else ST
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
These statements are used to selectively assemble different sets of statements.
For example
	if (STAND_ALONE) {
		at 0x03
			mov R0, #SP_IE0
			acall Pause
		reti
	} else {
		at 0x4003
			pop PSW
			mov R0, #SP_IE0
			acall Pause
		reti
	}
will assemble the first set of statements (at 0x03 ... reti) if the label STAND_ALONE is anything other than 0,
and the second set (at 0x4003...reti) if the label is 0.

An example with the exact same effect could be written as:
	if (STAND_ALONE) SEG equ 0; else SEG equ 0x4000
	at SEG + 3
		if (!STAND_ALONE) pop PSW
		mov R0, #SP_IE0
		acall Pause
	reti
Both the if and else part of the conditional will accept only one statement.
If more than one statement needs to be included, as in the first example, then they can be grouped within curly braces.

j. Statement «Grouping» ― { ... }, multiple statements on a line.
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
Any sequence of statement included within a matching set of curly brackets is treated as a single statement.
It can then be used in the body of any conditional just like any single statement can.

k. Special notes on statement formatting:
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
▪	«All statements (a) through (h) must end in semicolons.»
	However, this semicolon can be elided if it is the last item on a line.
	This allows compatibility with more traditional one-statement-on-a-line type assemblers.
	So normally, you don't have to even concern yourself with this if you adhere to one-statement per line style.
▪	«A basic statement ((a) through (h)) must be written all on one line.»
	It cannot be split up into two or more lines.
▪	«All comments are in C++ style.»
	Many assemblers use the semicolon to initiate comments.
	I have decided against this feature in favor of making this assembler more compatible with C++ syntax.
	Comments occur in the following two forms:
	(a)	Anything included between a matching pair /* ... */
	(b)	Anything included between a // and end of line.
	However, for increased compatibility, I also allow the following format:
	(c)	Anything included between a ;; and end of line.
	My personal style is to precede comments with a ;;;,
	so none of this impinges on the software included in the archive with the assembler.

There is a short C-program included that will blindly convert all single semicolons to double semicolons.
Since I've observed that semicolons rarely occur inside string or character constants in actual 8051 programs,
this should «almost» always be sufficient to resolve any incompatibilities with your older assembly language programs.

l. What goes in a *.s/*.asm file, what goes in a *.h file?
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
Generally speaking, declarations should be placed in a *.h header file.
The design of this assembler (especially with it being a one-pass assembler) is intended to support this usage.
Any of the following is a declaration:
	c. Defining new «Labels» ― LABEL {equ,Type,set,=} Exp
	f. Declaring «External» labels ― extern {Type,equ} LABEL, ..., LABEL
Declarations only meant to be accessed within one module should be made inside that module, instead of out in a header file.

The following should be used only in *.s/*.asm files:
	a. «File Inclusion» ― include "FILE"
	b. Setting current «Segment» and «Location» ― seg, at, org
	c. Defining new «Labels» ― LABEL:
	d. Numeric labels
	e. Declaring «Global» labels ― global, public
	g. Memory «Allocation» ― ds, rb, rw
	h. Memory «Formatting» ― db, dw
as they are generally used to:
∙	create memory images,
∙	define non-global objects, or
∙	define address values:
The last two items are generally used in many different contexts, and so can be used anywhere:
	i. «Conditional» assembly ― if (Ex) ST, if (Ex) ST else ST
	j. Statement «Grouping» ― { ... }, multiple statements on a line.

3. Expressions
──────────────
a. Operators
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
The syntax is the same as in C.
The following operations are defined:
∙	«bit-wise»:		~, &, ^, |, <<, >>
∙	«boolean»:		!, &&, ||, <, <=, >, >=, ==, !=
∙	«conditional»:		? :
∙	«arithmetic»:		prefix + and -; +, -, *, /, %
∙	«conversions»:		high, low, by
∙	«bit conversion»:	.

The operator precedences are all the same as in C.

The latter two groups, not defined in C, are described in more detail below.
The operator high, and low have the same precedence as all the other prefix operators (+, -, !, and ~).
The operators ‟by” and ‟.” have the lowest precedence of all infix operators, so for example
	A * B by C
is resolved as:
	A * (B by C)
and
	A.B + C
as:
	(A.B) + C

Parentheses may be used to enclose expressions as in C, for example:
	A + ((B << 2)&(C >> 3))

b. «Conversions» ― high X, low X, H by L
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
The following examples illustrate these operations:
	high 1234h	(result: 12h .. the upper byte of the word 1234h)
	low 1234h	(result: 34h .. the lower byte of the word 1234h)
	12h by 34h	(result: 1234h)

c. «Bit-conversion» ― Dir.Pos
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
This is an 8051-specific operation related to the bit-addressing structure of the processor.
The first argument represents a direct data register (of type ‟data” and value < 80h, or type ‟sfr” and value ≥ 80h).
The second represents a bit position (0, through 7).

The register, Dir, must be bit addressible.
These include only:
	data:	20h - 2fh
	sfr:	80h, 88h, 90h, 98h, 0a0h, 0a8h, 0b0h, 0b8h, 0c0h, 0c8h, 0d0h, 0d8h, 0e0h, 0e8h, 0f0h, 0f8h
The sfr registers and bit positions generally have meanings defined by the manufacturer of the 8051 processor
and vary between different versions of the 8051.
They are not generally free to be defined by the programmer for arbitrary use.
Most of them control or monitor the internal 8051 peripherals.

d. «Location counter» ― $
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
A variable address that denotes the current location within the current segment.
«Note»:
	dw $, $ - 2, $ - 4
«is equivalent to»:
	dw $; dw $ - 2; dw $ - 4
which is equivalent to:
	1: dw 1b; dw 1b; dw 1b
The location counter advances in the middle of a dw or db.

e. «Numeric constant»
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
This assembler accepts both C numeric syntax, as well as the Intel numeric syntax.
The relation between the (extended) C notation and Intel notation is illustrated below:
∙	«hexadecimal»:	0xa44f	= 0a44fh
			0x23	= 23h
∙	«decimal»:	23	= 23
			23	= 23d
∙	«octal»:	034	= 34q
			056	= 56o
∙	«binary»:	0b1001	= 1001b
Upper case may be used anywhere lower case is used, so the above can be written as:
∙	«hexadecimal»:	0XA44F	= 0A44FH
			0X23	= 23H
∙	«decimal»:	23	= 23
			23	= 23D
∙	«octal»:	034	= 34Q
			056	= 56O
∙	«binary»:	0B1001	= 1001B

f. «Labels»
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
Labels may consist of any sequence of letters, the _, and digits, not starting in a digit.
As with numerals, labels are «case insensitive».
So all of the following are equivalent:
	PPC, PPc, Ppc, pPC

4. Referencing Expressions
――――――――――――――――――――――――――
At any time during assembly, a label may be in one of 3 states:
∙	«defined» and «absolute»:
	This is either a numeric label, or a label denoting an address whose actual value is known.
∙	«defined» and «relative»:
	This is a label denoting an address whose location within its segment is known, but with the segment being relative.
∙	«undefined»:
	This is a label that is either defined elsewhere in another file,
	or defined later on in the file currently undergoing processing.

The following restrictions hold when using expressions:
∙	Only «absolute» labels can be used in any of the directives:
		at/org,
		ds/rb, rw
		if (...)
∙	Only «defined» labels can be used on the right-hand side of any of the follwing directives:
		LABEL equ Exp,
		LABEL Type Exp
		LABEL set Exp, LABEL = Exp
∙	Any expression can be used with any image generating statement:
		Mnemonics
		db, dw
If the expression's value is not known at the time of assembly, then the corresponding location in the image is zeroed out.
If the expression's value becomes known by the time the file is processed,
the assembler will go back and fill in the zero with the appropriate value(s).

5. Bugs (or ‟features”)
―――――――――――――――――――――――
∙	There is no way to tell the assembler to locate relatively addressed data registers in the directly addressible space.
	Consequently you may receive numerous errors during the linking phase
	telling you that such and such registers cannot be directly addressed.

	There are basically 2 ways to resolve this:
	(1)	give the registers absolute addresses,
	(2)	try listing the files in which these registers are defined first.
	The linker maps relative segments from the files in the order you list those files.

	In the makefile of the sample program provided (in 8051/assem/data), the linking phase is done with the command line:
		cas -o math.o data.o stdio.o kernel.o
	This ordering resolves the problem.
∙	The assembler won't recognize UNIX-style newlines on a DOS.
	Therefore, a conversion utility (nl.c) has been provided.
∙	No run-time checks are made against the object files processed.
	A corrupt object file will crash the assembler during the linking phase.

6. Diagnostics
――――――――――――――
The assembler will only print out a screenful of diagnostics (24) before it stops.
When applicable, the file and line number where the error occurred are given.
An attempt is made to indicate the line where the error actually occurred, rather than where its effects were first seen.

Assembly is stopped at certain points if errors have been detected, since it would make no sense to go on past the given point.

The following is an alphabetized listing of diagnostics classified by whether they are fatal or non-fatal.
Assembly always stops after the former but will continue after the latter (until the error limit is reached).

Internal errors should be reported to me,
see the README file at the FTP site csd4.csd.uwm.edu in the directory /pub/8051 or /pub/micro/8051 for more information.
If you get an internal error, you should display the object file using the object file display program provided with the assembler.
If you want me to resolve the bugs (if any exist) I would need to see this as well.

Alternatively, the source for the assembler is yours.
If you want to make modifications, try your hand at it,
and if something significant results let everyone know by placing it in the public domain.

a. Fatal Errors
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
These diagnostics will cause assembly to stop immediately,
they usually represent serious inconsistencies or serious points of confusion for the assembler
that makes further processing impossible or pointless.

∙	Address <Decimal Number> out of range
		The location counter points to the indicated address, which lies outside the address space of the current segment.
		These address spaces are as follows:
			Type	Low	High
			――――	―――	――――
			code	0	65535	(or ffff hexadecimal)
			xdata	0	65535	(or ffff hexadecimal)
			data	0	255	(or ff hexadecimal)

∙	Attempting to write to a non-code segment.
		This happens if you try to use any image generating statement (db/byte, dw/word, or any opcode)
		in a data or xdata segment.
		Only code segments will accept these statements.

∙	Bad opcode initialization.
		This is an internal error you should never see.
		It indicates an internal inconsistency in the assembler's opcode tables.
		These tables are used to process the 8051 mnemonics.

∙	Cannot fit segment.
		The linker tries its best to fit all the relatively addressed segment in the tightest fitting space it can.
		It may fail to pack them all in, if they can only fit real tightly, or your segments may actually not fit at all.
		Use the object file display program that accompanies this assembler to look at your object files in some detail.

∙	Cannot open <FILE>
		An file was lost sometime during processing, or the file named probably does not exist, or is not readible.

∙	Cannot open object file for <FILE>.
		The object file for the source file indicated was somehow lost or made inaccessible
		between the time it was created and the time it was processed by the linker.

∙	Cannot open output file.
		For some unexpected reason, the assembler could not create an .hex output file.
		If you're running this on a UNIX, then you're probably assembling output into a directory
		where you have no write access.
		Also possible: you ran out of disk space.

∙	Cannot reopen <FILE>
		A failure to reopen the current file after processing an include file occurred.
		This indicates either an internal flaw in the assembler or that something happened to the file during assembly.

∙	Corrupt object file <NAME>.
		A rudimentary check are made on object files.
		The file indicated didn't pass that check.
		It's was either corrupted, or the assembler itself has an internal flaw that made it produce corrupt object files.

∙	Could not restore <FILE>'s position.
		A failure to resume processing the current file past the most recent include statement occurred.
		This indicates either an internal flaw in the assembler
		or that the file undergoing processing was corrupted during assembly.

∙	Could not save <FILE>'s position.
		A transient error occurred while setting up to include another file.
		This is either a serious system flaw, or an internal flaw in the assembler.

∙	Expression too complex ... aborting.
		If you see this, you must be Lieutenant Commander Data.
		An expression has to be pretty complicated before it confuses the assembler.
		Break it up, by symbolically defining subexpressions first.

∙	Internal error (0).
		An inconsistency was detected by the linker in the object file undergoing processing.
		A relocation item of undefined type was found.

∙	Internal error (1).
		An inconsistency was detected by the linker in the object file undergoing processing.
		An undefined expression was found.

∙	Internal error (2).
		A flaw in the assembler made it lose track of all the code segments, even though at least one was defined.

∙	Internal error (3).
		A flaw in the assembler made it think
		that a ds/rb, or rw statement was reserving memory outside the segment where it was defined.

∙	Internal error (4).
		A flaw in the assembler caused it to try and relocate two or more items to the same address.
		This can also be caused by a corrupt object file.

∙	Internal error (5).
		A flaw in the assembler caused it to have trouble resolving an expression during linking.
		This can also be caused by a corrupt object file.

∙	Internal error (6).
		A flaw in the assembler made it fail to sort the list of items to be relocated.
		A corrupt object file can cause this too.

∙	Internal error (7).
		A flaw in the assembler made it think it was trying to patch up a hole of size other than 1 or 2 bytes.
		This can also be caused by a corrupt object file.

∙	Internal error (8).
		The assembler is expecting an object file larger than what it sees.
		This is the result of either an internal flaw or corrupt object file.

∙	Invalid object file <NAME>.
		The first type bytes of all object files are 55 and aa (hexadecimal).
		The object file undergoing processing doesn't show this.
		It's was either corrupted, or the assembler itself has an internal flaw that made it produce corrupt object files.

∙	Invalid option: -<OPTION>
		Only -c and -o are recognized.

∙	Missing ';' after include statement.
		The include statement (like all other statements) needs to be followed by a semicolon,
		or otherwise be the last statement on the line.

∙	Missing filename in 'include'
		The include statement has the form: include "FILE", with the file name enclosed in double-quotes, as indicated.

∙	Out of memory.
		The assembler's resources exceeded the system's available space.
		If this happens during linking it may point to the high degree of interconnectivity
		between modules thereby indicating a need to make the interfaces between modules more clean-cut.
		If it happens during assembly it may point to a need to break the assembly-language file into smaller modules.

∙	Overlapping segments: <FILE> [<LINE>] and <FILE> [<LINE>].
		The segments in the indicated places have overlapping ranges of addresses.
		Move one or both of them, if possible.

∙	Overlapping segments at [<LINE>] <FILE> and [<LINE>] <FILE>.
		This one is actually an internal error.

∙	Statement too complex
		If you see this, you must be Lieutenant Commander Data.
		A statement has to be pretty complicated with many layers of if's and else's and brackets '{' and '}'
		before it confuses the assembler.
		There is no direct recourse here other than to try and simplify your program.

∙	Too many nested include files.
		Up to 5 levels of nested includes are allowed.

∙	Too many segments.
		Up to 32 segments can be defined per file.
		Any occurrence of the org/at or seg statements will start a new segment.
		The first 5 segments are defined by and used internally by the assembler, which leaves you with 27.

∙	Undefined segment type.
		Only the types: code, xdata, or data can be used with the seg statement.

∙	Unexpected EOF.
		Attempted to read past the end of an object file.
		The object file is corrupt

∙	Use: <CAS> -c File... to assemble.
		At least one input file should be listed with the -c option.

∙	Use: <CAS> -o Output File... to link.
		At least one source or object file should be listed with the -o option.

∙	Use: <CAS> [-o Output] File... to link.
		At least one source or object file should be listed with the -o option or with no options.

b. Non-Fatal Errors
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
These are errors the assembler will attempt to recover from and continue processing after.

∙	Address <NAME> redeclared as number: <FILE> <FILE>
		The symbol indicated was declared as a global number in the first indicated files
		and as a global address in the second.

∙	Address cannot appear in: x? x: x.
		Addresses cannot be used as conditions of conditionals in the combination address? x: x.
		Only numeric values can be used there.

∙	Address cannot be used with infix operator.
		The only allowable combinations of addresses involving infix operations are pretty much like in C:
			number + address
			address + number
			address - number
		In addition, the combination
			reg.bit
		can be used for bit addressible registers "reg" and values of 0 to 7 for "bit".

∙	Address cannot be used with prefix operator.
		Prefix operators other than + (-, !, ~, high, low) can only be used with numeric values, not addresses.

∙	Address of wrong type in reg.pos
		Only data or sfr addresses can be used in the place referred to ("reg").

∙	Address type mismatch.
		Rudimentary type-checking is done for operations involving
		bit addresses, data and sfr addresses, or code addresses.
		Type checking is not done on xdata addresses, as there are not 8051 operations that directly involve such addresses.

∙	Addresses of different types cannot be subtracted.
		Addresses must be of the same type in order to be subtracted.
		They can be of different segments, however, as long as the segments have the same type.

∙	Attempting to make local label global.
		Local (numeric) labels cannot be made global.

∙	Attempting to redefine <NAME>
		The label indicated was used in the context LABEL:, but is already defined,

∙	Bad hexadecimal character.
		A hexadecimal character takes the form: \xHK or \XHK, where H and K are hexadecimal digits.
		Exactly two hex digits must be seen.
		An \x by itself without any following hexadecimal digits is interpreted as just x.

∙	Binary number has non-binary digits.
		A number with a binary prefix (0b, 0B) or binary suffix (b, B) can only contain the digits 0 and 1.

∙	Bit address out of range.
		Bit addresses range only from 0 to ff hex (0 to 255 decimal).

∙	Bit position out of range.
		The operation reg.pos only allows values of 0 to 7 for "pos".

∙	Byte value out of range (hex value).
		An immediate byte value in the range -80 (hex) to ff (hex) (or -128 to 255) is required in this context.

∙	Cannot use @A+A
		Only @A+DPTR, and @A+PC can be used with the 8051 language.

∙	Cannot use @A+AB.
		Only @A+DPTR, and @A+PC can be used with the 8051 language.

∙	Cannot use @A+C.
		Only @A+DPTR, and @A+PC can be used with the 8051 language.

∙	Cannot use @A+Rn
		Only @A+DPTR, and @A+PC can be used with the 8051 language.

∙	Cannot use @A.
		The only valid combinations using @ are @R0, @R1, @DPTR, @A+DPTR, and @A+PC.

∙	Cannot use @AB.
		The only valid combinations using @ are @R0, @R1, @DPTR, @A+DPTR, and @A+PC.

∙	Cannot use @C.
		The only valid combinations using @ are @R0, @R1, @DPTR, @A+DPTR, and @A+PC.

∙	Cannot use @PC.
		The only valid combinations using @ are @R0, @R1, @DPTR, @A+DPTR, and @A+PC.

∙	Cannot use PC as a register.
		PC only appears in the combination @A+PC in the statement movc A, @A+PC.

∙	Code address out of range.
		Code addresses can only range from 0 to ffff hex (or 0 to 65535 decimal).

∙	Data address out of range.
		Only direct data register addresses (0 to 7f hex, or 0 to 127),
		or special function register addresses can be used here.

∙	Decimal number has non-decimal digits.
		The number indicated has hexadecimal digits (a through f, or A through F)
		but no hexadecimal prefix (0x, 0X, 0h, 0H) or suffix (h, H, x, X).

∙	Division by 0.
		x / 0 is not defined.

∙	Empty character constant.
		A single quote cannot be quoted as a character (''').
		Use '\'' instead.
		Alternatively, you attempted to define an empty string ("") with single quotes.

∙	Expected an argument/prefix operator.
		The expression indicated is probably missing
		a prefix operator, a symbol or constant, or an opening parenthesis '('.

∙	Expected segment type.
		The statement: seg Type, must have Type code, xdata, or data.

∙	Expected symbol after 'global'
		Only symbols can be declared as global.

∙	Expected symbol in 'extern'
		Only symbols can be declared as external.

∙	Expected type or 'equ' after 'extern'.
		External symbols must be declared as a type (sfr, bit, code, data, xdata) or as a numeric constant (equ).
		The valid forms are:
			extern (sfr, bit, code, data, xdata, or equ) Symbol, ..., Symbol

∙	Expression type does not match.
		The expression occurring on the right hand side of the statement of the form:
			Symbol Type Value,
		does not have the indicated type.

∙	Extra ','.
		An extra command was inserted after the last operand.
		Alternatively, the operand following the last comma is missing.

∙	Illegal combination: address + address
		Only numeric values can be added to or subtracted from addresses.
		The rules for address arithmetic are basically like those in C.

∙	Illegal combination: number - address
		Numbers can only be subtracted from addresses, not the other way around.
		The rules for address arithmetic are basically like those in C.

∙	Illegal combination: reg.bit
		Only numeric values in the range 0 to 7 can be used in place of "bit", not addresses.

∙	Indirect registers are not bit addressible.
		The register referred to ("reg") must be a data address in the range 20-2f.
		The address referred to lies above 80 (hex).
		It is possible you may have meant to use a Special Function Register here, not a data address.

∙	Invalid addressing mode: <MNEMONIC>
		This mnemonic is not defined for this combination of operands.

∙	Missing '(' in 'if (...)'.
		The if statement must have the form: if (x) ..., as it does in C.

∙	Missing ')'
		An unmatched closing parenthesis, ')', or possibly an extra opening parenthesis, '(', occurred.

∙	Missing ')' in 'if (...)'.
		The if statement must have the form: if (x) ..., as it does in C.

∙	Missing ':'
		The conditional indicated is missing a colon.
		Conditional expressions have the form x? x: x.

∙	Missing ';'
		Semi-colons must be used between two or more statements on the same line.
		You may have mistyped a colon (:) insteady.

∙	Missing '}'.
		An opening bracket '{' was never closed off with a ')'.

∙	Missing DPTR or PC after @A+
		Only @A+DPTR, and @A+PC can be used with the 8051 language.

∙	Missing a ' in character constant.
		No more than one item can be enclosed between single quotes (e.g. 'ab', or 'a\n', though '\n' is okay).
		You may have meant to define a string here.
		Use double quotes.

∙	Modulo by 0
		x  684s not defined.

∙	Number <NAME> redeclared as address: <FILE> <FILE>
		The symbol indicated was declared as a global address in the first indicated files
		and as a global number in the second.

∙	Octal number has non-octal digits.
		A number with an octal prefix (0, other than those with an appropriate suffix),
		or an octal suffix (o, O, q, Q) can only contain the digits 0 through 7.

∙	Only code, xdata, or data segments allowed.
		The types sfr and bit cannot be used with segments.

∙	Paged address out of range.
		Paged jump or call instructions (ajmp, acall) must have destinations
		that lie on the same code page (every 800 hex bytes, starting at 0 is a code page).
		This only happens when your program gets beyond a certain size,
		or when it is located at an odd address (such as 7ff hex).
		Generally, it's a good idea to start your programs on even multiples of 800 hex.
		Stand-alone programs have to start at the reset address (0) anyway.

∙	Redeclaring address <NAME> as number.
		A symbol already defined as an address is being declared as an external numeric value.

∙	Redeclaring local symbol <NAME> as external.
		A symbol already defined as a local symbol is being defined as external.
		This may also be a name clash between a local and global symbol.

∙	Redeclaring number <NAME> as address.
		A symbol already defined as a number is being declared as an external address.

∙	Register address out of range.
		Only directly addressible data registers (0 to 7f hex, or 0 to 127) can be used here.
		This error may have inadvertently been created by the assembler
		if you defined relatively addresses data registers, and the assembler tried to map them beyond 80 hex.
		See the Bugs section of the document.

∙	Register in @Rn out of range.
		Only registers R0 or R1 can be used as register pointers.

∙	Register in reg.bit not bit addressible.
		The register referred to ("reg") must be a data address in the range 20-2f (hexadecimal, 32-47 decimal),
		or must be one of the Special Function
		Registers whose address is evenly divisible by 8 (in hexadecimal: 80, 88, 90, ..., f0, f8).

∙	Register must appear after @.
		Numeric or address expressions cannot appear after @.

∙	Relative address cannot be used here
		Only absolute addresses, or numeric values containing objects
		that have been previously defined (in terms of other such absolute objects)
		can appear in the conditional (if (E) ...), or in address setting/modifying statements (org/at, ds/rb, rw).

∙	Relative address out of range.
		Some jump instruction (cjne, djnz, sjmp, jz, jnz, jc, jnc, jbc, jb, jnb) require their destinations
		to be within a certain range (-80 hex to +7f hex) of the first byte following the jump instruction.
		Generally, you should not use these operations to jump across segment boundaries
		when one or more of the segments is relatively addressed.

∙	SFR address out of range.
		Special function register addresses can only have values in the range (80 to ff hex, or 128 to 255 decimal).

∙	Symbol <NAME> already declared as external number.
		The symbol indicated was declared as an external numeric constant but was defined as an address.

∙	Symbol <NAME> already declared as external.
		The symbol indicated was already declared as an external/global,
		and so cannot be defined as a variable, or local constant.
		If you had intended to define it as a global constant, precede the definition with the word 'global' or 'public'.

∙	Symbol <NAME> already declared as number.
		The symbol indicated was used in the context LABEL:, but is already declared as a numeric constant.

∙	Symbol <NAME> already defined as constant.
		Constant symbols cannot be redefined as variables.

∙	Symbol <NAME> already defined.
		Constant symbols can only be defined once.

∙	Symbol <NAME> cannot be equated to relative address.
		The symbol indicated was declared as an external numeric constant.
		It can only be set to an absolute address or numeric value.

∙	Symbol <NAME> cannot be set to relative address.
		Variables can only be set to absolute addresses, or numbers.

∙	Symbol <NAME> redefined: <FILE> <FILE>.
		The symbol indicated was defined as a global in both of the files listed.
		It can only be defined as a global once.

∙	Symbol <NAME>'s type does not match.
		The symbol indicated was declared as an external of one type and defined as a global of a different type.

∙	Syntax error
		This statement so totally eluded the assembler's ability to process it,
		that it didn't even know what you intended.
		This can also occur if it gets set off-track as a result of previous errors.

∙	Too many arguments specified.
		More operands were supplied than is accepted by this mnemonic.

∙	Too many gaps.
		Each time you issue a statement to the assembler to reserve space (ds/rb, rw)
		the assembler internally creates a gap for it.
		No more than 256 such statements can occur per file.
		You should probably break this file into smaller modules.

∙	Type mismatch <NAME>: <FILE> <FILE>
		The symbol indicated was declared as a global with different types in the files indicated.

∙	Type mismatch: <NAME>.
		A symbol already defined as an address of one type is being declared as an address of another type.

∙	Undefined expression
		The expression indicated must be defined either as an absolute or relative address, or number in this statemen.
		This occurs in any statement where a new label is being defined.

∙	Undefined label <DIGIT>
		A numeric label was used in a forward reference (e.g. 1f, 2f, 3f, ...),
		but was not defined anywhere in the current segment.
		Numeric labels can not be referenced across segments.

∙	Undefined local symbol <DIGIT>b
		A backward reference was made to a numeric label (e.g. 1b, 2b, 3b, ...)
		that was not previously defined in the current segment.
		References to numeric labels cannot be made across segments.

∙	Undefined symbol: <NAME>
		If a line number and file are indicated,
		then either the symbol is being used on the right hand side of a label definition
		(in which case, its value must be an already known absolute address, or number),
		you may be using a mnemonic not known to the assembler, may have misspelled one that is known,
		or you may have tried to write a label-defining statement but made an error somewhere.

		If no line and file numer are indicated, the symbol indicated was used in the file without ever being defined.
		It needs to be declared as an external (if it is defined in another file) or needs to be defined before it is used.

∙	Unexpected EOF inside // comment.
		A // comment occurred at the end of the current file, and no end of line marker was seen.
		This indicates your source file is not in text mode.

∙	Unexpected EOF inside ;; comment.
		A ;; comment occurred at the end of the current file, and no end of line marker was seen.
		This indicates your source file is not in text mode.

∙	Unexpected EOF inside comment.
		A /* comment was seen, but was never closed with a */.

∙	Unexpected EOF inside string.
		A double quote was seen without a matching pair anywhere.

∙	Unresolved external: <NAME>.
		A symbol was declared as an external but wasn't defined anywhere.
		If it's a register or bit address defined for one of the 8051 extensions (8052, or 8051fa),
		you will have to use one of the include files provided (8052.h or 8051fa.h), or make your own.

∙	Variables cannot be made global.
		The keyword 'global' cannot be used with the statements Var = Val, or Var set Val.
		Variables can only be defined as local symbols.

∙	Word value out of range.
		An immediate word value (range -8000 to ffff hex, or -32768 to 65535 decimal) is required here.
