/*
   MPC Library V1.1

   Multiply Divide and Modulus routines for the MPC
   Code Development System.  These routines are generated by
   the used by the compiler are the MPC.LIB library.

   These routines may be adapted for any purpose when
   used with the MPC Code Development system.  No
   warranty is implied or given as to their usability
   for any purpose.

   Parts of these routines are adapted with permission from
   software supplied by Microchip the remainder is a
   translation of the standard software routines developed
   by Byte Craft Limited for embedded system compiler support.

        (c) Copyright 1988,1991,1994

        Byte Craft Limited
        Waterloo, Ontario
        Canada N2J 4E4
        (519) 888-6911

        Walter Banks

   NOTES:
     There are times when users want to get both the result of
   the divide and the remainder.  This can be done with the
   following steps.

     1) LONG operations,

        Declare the following function prototype
          long __RMOD(void);

          long o,p,q,r;

          o = p / q;      /* do the divide                          */
          r = __RMOD();   /* Followed immediately by call to __RMOD */
                          /* r has remainder and o the quotient     */

     2) INT,SHORT and CHAR operations,

       The divide call __DIV8BY8() returns the remainder in the AC
       and the quotient in the index register. By executing a modulus
       operation the remainder is returned and the quotient is in the index.

          registerx index;

          int i,j,k,l;

          l = i % j;      /* Execute a modulus operation            */
          k = index;      /* get the quotient                       */
                          /* l has remainder and k the quotient     */


*/

/* ... */
          long __RMOD(void);

/*
void main(void)
  {

          long o,p,q,r;

          o = p / q;      /* do the divide                          */
          r = __RMOD();   /* Followed immediately by call to __RMOD */
                          /* r has remainder and o the quotient     */


          registerx index;

          int i,j,k,l;

          l = i % j;      /* Execute a modulus operation            */
          k = index;      /* get the quotient                       */
                          /* l has remainder and k the quotient     */
  }

*/

#pragma library /* Directive for Version 4.0 libraries */

int _wreg @ 0x0a;
int _pix  @ 0x01;
#define _carry 0

#if !(defined __MUL)
  #asm
   MACRO MUL8X8
   call __MUL8x8
   ENDM
  #endasm
#else
  #asm
   MACRO MUL8X8
   MUL
   ENDM
  #endasm
#endif

long __MUL16x16(void)
  {
    int R0;
    int R1;
    #asm
       movfp  __longAC+1,_pix
       movfp  __longIX+1,_wreg
       MUL8x8
       movpf  _wreg,R0
       movpf  _pix,R1
       movfp  __longAC,_pix
       movfp  __longIX+1,_wreg
       MUL8x8
       addwf  R1
;       STA  R1
       movfp  __longAC+1,_pix
       movfp  __longIX,_wreg
       MUL8x8
       addwf  R1
;       STA  R1
       movpf  _wreg,_pix
       movfp  R0,_wreg
   #endasm
   }

#if !(defined __MUL)
long __MUL8x8(void)
  {
   int R,Q,S;


#asm
;*******************************************************************
;                   8x8 Software Multiplier
;               ( Code Efficient : Looped Code )
;
;   The 16 bit result is stored in 2 bytes
;
; Before calling the subroutine " mpy ", the multiplier should
; be loaded in pseudo index reg 1, and the multiplicand in
; W register. The 16 bit result returned in Register 1 and W register.
;
;
; This routine is optimized for code efficiency ( looped code )
; For time efficiency code refer to "mult8x8F.asm" ( straight line code )
;*******************************************************************
;
mpy8x8_S
        movwf   Q
        movpf   _pix,_wreg
	clrf    _pix         ; index
	clrf    S
	clrf    R
	bsf     R,3         ; set R = 8
	bcf     3,_carry    ; Clear the carry bit in the status Reg.
loop
	btfsc   Q,0
	addwf   _pix         ; High Byte
	rrcf    _pix
	rrcf    S
	rrncf   Q
	decfsz  R
	goto    loop
        movfp   S,_wreg
     #endasm
   }
#endif

void __DIV8BY8(void)
  {
   int R,Q;
   #asm
       movfp  R,_pix
       movfp  Q,_wreg
       movlw  0
       movpf  _wreg,_pix
       incf   _pix
LOOP1  rlcf   Q
       rlcf   _wreg
       subwf  R
       btfss  3,_carry    ; BCC
       goto   LOOP1
       rlcf   _pix
       addwf  R
       bsf    3,_carry    ; Set Carry bit
SS     rlcf   _pix
       btfss  3,_carry    ; BCC
       goto   LOOP1
       comf   _pix
   #endasm
   }

void __LDIV(void)
  {
   #asm
al    rmb    1
ah    rmb    1
xh    rmb    1
LDIV  clrf   xh
      clrf   _pix
      clrf   al
      clrf   ah
      incf   _pix
LOOP2 rlcf   __longAC+1
      rlcf   __longAC
      rlcf   al
      rlcf   ah
      movfp  __longIX+1,_wreg
      subwf  al
      movfp  __longIX,_wreg
      subwfb ah
      btfsc  3,_carry    ; BCS
      goto   TT
      movfp  __longIX+1,_wreg
      addwf  al
      movfp  __longIX,_wreg
      addwfc ah
      bcf    3,_carry    ; Clear Carry bit
TT    rlcf   _pix
      rlcf   xh
      btfsc  3,_carry    ; BCS
      goto   LOOP2
   #endasm
    }


long __RDIV(void)
  {
   #asm
     comf   _pix
     movfp  _pix,_wreg
     movfp  xh,_pix
     comf   _pix
   #endasm
  }


long __RMOD(void)
  {
   #asm
     movfp  ah,_pix
     movfp  al,_wreg
   #endasm
  }

#pragma endlibrary /* Directive for Version 4.0 libraries */

